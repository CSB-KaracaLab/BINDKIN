! dna-rna_restraints.def
!    Define backbone dihedral angles, hbonds and planarity restraints
!    for nucleic acids
!
! ***********************************************************************
! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           *
! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       *
! * All rights reserved.                                                *
! * This code is part of the HADDOCK software and governed by its       *
! * license. Please see the LICENSE file that should have been included *
! * as part of this package.                                            *
! ***********************************************************************
!
{+ file: dna-rna_restraints.def       directory: protocols +}
{+ description: Creates restraints to maintain conformation of DNA/RNA
            <br><br>
Additions and changes were made to allow for flexibility during docking<br><br>
Changes include: <br>
<ul>
<li> flags to turn all options on or off
<li> separation of sugar
<li> pucker restraints and phosphate backbone restraints
<li> option to have sugar-phosphate backbone dihedrals measured and restrained within a user defined error range
<li> option to have the length of the Watson-Crick hydrogen bonds measured from the structure measured and restrained within a user defined error range.
</ul>

 +}
{+ comment:This file is to be read by refinement files that modify atom coordinates +}
{+ authors: Axel T. Brunger, and Paul D. Adams, <br>
            modified by Alexandre Bonvin and Marc van Dijk for HADDOCK use +}

set message=normal echo=on end

{- begin block parameter definition -} define(

{=========================================== base-pair planarity ===========================================}

{* Use planarity restraints for Watson-Crick base pairing *}
{+ choice: true false +}
{===>} basepair_planar=false;

{============================================== base planarity =============================================}

{* Restrain base planarity. This selection must only include nucleotide residues *}
{===>} bases_planar=((resid 1:20 or resid 21:40) and segid B);

{=================================== sugar-pucker dihedral angle restraints ================================}

{* Pick the dihedral angles of the sugar pucker from the input structure 
   and restrain them within the given error range *}
{+ choice: true false +}
{===>} dna_pick_pucdih=true;

{* residues with sugar pucker restrained - group 1 *}
{===>} pucker_1=(resid 1:20 and segid B);

{* conformation of group 1 *}
{+ choice: "a-form" "b-form" "other" +}
{===>} form_1="other";

{* user defined sugar pucker for group 1 *}

{* dihedral C1'-C2'-C3'-C4' *}
{===>} dihedral_nu2_1=-34.9; 
{* dihedral C1'-C2'-C3'-C4' error range *}
{===>} error_nu2_1=0.0;
{* dihedral C5'-C4'-C3'-C2' *}
{===>} dihedral_nu3_1=-86.4; 
{* dihedral C5'-C4'-C3'-C2' error range *}
{===>} error_nu3_1=0.0;
{* dihedral C1'-O4'-C4'-C5' *}
{===>} dihedral_nu4_1=106.4; 
{* dihedral C1'-O4'-C4'-C5' error range *}
{===>} error_nu4_1=0.0;

{* residues with sugar pucker restrained - group 2 *}
{===>} pucker_2=(resid 21:40 and segid B);

{* conformation of group 2 *}
{+ choice: "a-form" "b-form" "other" +}
{===>} form_2="other";

{* user defined sugar pucker for group 2 *}

{* dihedral C1'-C2'-C3'-C4' *}
{===>} dihedral_nu2_2=-34.9; 
{* dihedral C1'-C2'-C3'-C4' error range *}
{===>} error_nu2_2=0.0;
{* dihedral C5'-C4'-C3'-C2' *}
{===>} dihedral_nu3_2=-86.4; 
{* dihedral C5'-C4'-C3'-C2' error range *}
{===>} error_nu3_2=0.0;
{* dihedral C1'-O4'-C4'-C5' *}
{===>} dihedral_nu4_2=106.4; 
{* dihedral C1'-O4'-C4'-C5' error range *}
{===>} error_nu4_2=0.0;

{* residues with sugar pucker restrained - group 3 *}
{===>} pucker_3=(none);

{* conformation of group 3 *}
{+ choice: "a-form" "b-form" "other" +}
{===>} form_3="b-form";

{* user defined sugar pucker for group 3 *}

{* dihedral C1'-C2'-C3'-C4' *}
{===>} dihedral_nu2_3=-34.9; 
{* dihedral C1'-C2'-C3'-C4' error range *}
{===>} error_nu2_3=10.0;
{* dihedral C5'-C4'-C3'-C2' *}
{===>} dihedral_nu3_3=-86.4; 
{* dihedral C5'-C4'-C3'-C2' error range *}
{===>} error_nu3_3=10.0;
{* dihedral C1'-O4'-C4'-C5' *}
{===>} dihedral_nu4_3=106.4; 
{* dihedral C1'-O4'-C4'-C5' error range *}
{===>} error_nu4_3=10.0;

{* residues with sugar pucker restrained - group 4 *}
{===>} pucker_4=(none);

{* conformation of group 4 *}
{+ choice: "a-form" "b-form" "other" +}
{===>} form_4="b-form";

{* user defined sugar pucker for group 4 *}

{* dihedral C1'-C2'-C3'-C4' *}
{===>} dihedral_nu2_4=-34.9; 
{* dihedral C1'-C2'-C3'-C4' error range *}
{===>} error_nu2_4=10.0;
{* dihedral C5'-C4'-C3'-C2' *}
{===>} dihedral_nu3_4=-86.4; 
{* dihedral C5'-C4'-C3'-C2' error range *}
{===>} error_nu3_4=10.0;
{* dihedral C1'-O4'-C4'-C5' *}
{===>} dihedral_nu4_4=106.4; 
{* dihedral C1'-O4'-C4'-C5' error range *}
{===>} error_nu4_4=10.0;

{================================ phosphate backbone dihedral angle restraints =============================}

{* Pick the dihedral angles of the phosphate backbone from the input structure and
   restrain them within the given error range *}
{+ choice: true false +}
{===>} dna_pick_bacdih=true;

{* residues with phosphate backbone restrained - group 1 *}
{===>} dihedral_1=(resid 1:20 and segid B);

{* conformation of group 1 *}
{+ choice: "a-form" "b-form" "other" +}
{===>} form_1="other";

{* user defined sugar pucker for group 1 *}

{* alpha dihedral O3'-P-O5'-C5' *}
{===>} dihedral_alpha_1=-10.0; 
{* alpha dihedral range *}
{===>} error_alpha_1=10.0; 
{* beta dihedral P-O5'-C5'-C4' *}
{===>} dihedral_beta_1=136.4; 
{* beta dihedral range *}
{===>} error_beta_1=40.0; 
{* gamma dihedral O5'-C5'-C4'-C3' *}
{===>} dihedral_gamma_1=31.1; 
{* gamma dihedral range *}
{===>} error_gamma_1=20.0; 
{* delta dihedral C5'-C4'-C3'-O3' *}
{===>} dihedral_delta_1=-165.0; 
{* delta dihedral range *}
{===>} error_delta_1=50.0; 
{* epsilon dihedral C4'-C3'-O3'-P *}
{===>} dihedral_eps_1=-165.0; 
{* epsilon dihedral range *}
{===>} error_eps_1=10.0; 
{* zeta dihedral C3'-O3'-P-O5' *}
{===>} dihedral_zeta_1=-150.8; 
{* zeta dihedral range *}
{===>} error_zeta_1=50.0; 

{* residues with phosphate backbone restrained - group 2 *}
{===>} dihedral_2=(resid 21:40 and segid B);

{* conformation of group 2 *}
{+ choice: "a-form" "b-form" "other" +}
{===>} form_2="other";

{* user defined sugar pucker for group 2 *}

{* alpha dihedral O3'-P-O5'-C5' *}
{===>} dihedral_alpha_2=-10.0; 
{* alpha dihedral range *}
{===>} error_alpha_2=10.0; 
{* beta dihedral P-O5'-C5'-C4' *}
{===>} dihedral_beta_2=136.4; 
{* beta dihedral range *}
{===>} error_beta_2=40.0; 
{* gamma dihedral O5'-C5'-C4'-C3' *}
{===>} dihedral_gamma_2=31.1; 
{* gamma dihedral range *}
{===>} error_gamma_2=20.0; 
{* delta dihedral C5'-C4'-C3'-O3' *}
{===>} dihedral_delta_2=-165.0; 
{* delta dihedral range *}
{===>} error_delta_2=50.0; 
{* epsilon dihedral C4'-C3'-O3'-P *}
{===>} dihedral_eps_2=-165.0; 
{* epsilon dihedral range *}
{===>} error_eps_2=10.0; 
{* zeta dihedral C3'-O3'-P-O5' *}
{===>} dihedral_zeta_2=-150.8; 
{* zeta dihedral range *}
{===>} error_zeta_2=50.0; 

{* residues with phosphate backbone restrained - group 3 *}
{===>} dihedral_3=(none);

{* conformation of group 3 *}
{+ choice: "a-form" "b-form" "other" +}
{===>} form_3="other";

{* user defined sugar pucker for group 3 *}

{* alpha dihedral O3'-P-O5'-C5' *}
{===>} dihedral_alpha_3=-10.0; 
{* alpha dihedral range *}
{===>} error_alpha_3=10.0; 
{* beta dihedral P-O5'-C5'-C4' *}
{===>} dihedral_beta_3=136.4; 
{* beta dihedral range *}
{===>} error_beta_3=40.0; 
{* gamma dihedral O5'-C5'-C4'-C3' *}
{===>} dihedral_gamma_3=31.1; 
{* gamma dihedral range *}
{===>} error_gamma_3=20.0; 
{* delta dihedral C5'-C4'-C3'-O3' *}
{===>} dihedral_delta_3=-165.0; 
{* delta dihedral range *}
{===>} error_delta_3=50.0; 
{* epsilon dihedral C4'-C3'-O3'-P *}
{===>} dihedral_eps_3=-165.0; 
{* epsilon dihedral range *}
{===>} error_eps_3=10.0; 
{* zeta dihedral C3'-O3'-P-O5' *}
{===>} dihedral_zeta_3=-150.8; 
{* zeta dihedral range *}
{===>} error_zeta_3=50.0; 

{* residues with phosphate backbone restrained - group 4 *}
{===>} dihedral_4=(none);

{* conformation of group 4 *}
{+ choice: "a-form" "b-form" "other" +}
{===>} form_4="other";

{* user defined sugar pucker for group 4 *}

{* alpha dihedral O3'-P-O5'-C5' *}
{===>} dihedral_alpha_4=-10.0; 
{* alpha dihedral range *}
{===>} error_alpha_4=10.0; 
{* beta dihedral P-O5'-C5'-C4' *}
{===>} dihedral_beta_4=136.4; 
{* beta dihedral range *}
{===>} error_beta_4=40.0; 
{* gamma dihedral O5'-C5'-C4'-C3' *}
{===>} dihedral_gamma_4=31.1; 
{* gamma dihedral range *}
{===>} error_gamma_4=20.0; 
{* delta dihedral C5'-C4'-C3'-O3' *}
{===>} dihedral_delta_4=-165.0; 
{* delta dihedral range *}
{===>} error_delta_4=50.0; 
{* epsilon dihedral C4'-C3'-O3'-P *}
{===>} dihedral_eps_4=-165.0; 
{* epsilon dihedral range *}
{===>} error_eps_4=10.0; 
{* zeta dihedral C3'-O3'-P-O5' *}
{===>} dihedral_zeta_4=-150.8; 
{* zeta dihedral range *}
{===>} error_zeta_4=50.0; 

{============================================= C1'-C1' restraints ==========================================}

{* Have the length of the C1'-C1' virtual bonds measured and restraints. *}
{+ choice: true false +}
{===>} dna_pick_c1=false;

{* Error range used for C1'-C1' virtual bonds  *}
{===>} c1_low=0.05;
{===>} c1_up=0.05;

{=========================================== Watson-Crick base pairs =======================================}

{* pick Watson-Crick restraint values from structure *}
{+ choice: true false +}
{===>} dna_pick_wc=true;
{* error range used for dna_pick_wc defined Watson-Crick restraints *}
{===>} wc_low=0.05;
{===>} wc_up=0.05;
{* for URI, for default much lower range... why?*}
{===>} wc_low_uri=0.01;
{===>} wc_up_uri=0.01;

{* residues which form Watson-Crick pairs *}

{* selection for pair 1 base A *}
{===>} base_a_1=(resid 1 and segid B);
{* selection for pair 1 base B *}
{===>} base_b_1=(resid 40 and segid B);

{* selection for pair 2 base A *}
{===>} base_a_2=(resid 2 and segid B);
{* selection for pair 2 base B *}
{===>} base_b_2=(resid 39 and segid B);

{* selection for pair 3 base A *}
{===>} base_a_2=(resid 3 and segid B);
{* selection for pair 3 base B *}
{===>} base_b_2=(resid 38 and segid B);

{* selection for pair 4 base A *}
{===>} base_a_4=(resid 4 and segid B);
{* selection for pair 4 base B *}
{===>} base_b_4=(resid 37 and segid B);

{* selection for pair 5 base A *}
{===>} base_a_5=(resid 5 and segid B);
{* selection for pair 5 base B *}
{===>} base_b_5=(resid 36 and segid B);

{* selection for pair 6 base A *}
{===>} base_a_6=(resid 6 and segid B);
{* selection for pair 6 base B *}
{===>} base_b_6=(resid 35 and segid B);

{* selection for pair 7 base A *}
{===>} base_a_7=(resid 7 and segid B);
{* selection for pair 7 base B *}
{===>} base_b_7=(resid 34 and segid B);

{* selection for pair 8 base A *}
{===>} base_a_8=(resid 8 and segid B);
{* selection for pair 8 base B *}
{===>} base_b_8=(resid 33 and segid B);

{* selection for pair 9 base A *}
{===>} base_a_9=(resid 9 and segid B);
{* selection for pair 9 base B *}
{===>} base_b_9=(resid 32 and segid B);

{* selection for pair 10 base A *}
{===>} base_a_10=(resid 10 and segid B);
{* selection for pair 10 base B *}
{===>} base_b_10=(resid 31 and segid B);

{* selection for pair 11 base A *}
{===>} base_a_11=(resid 11 and segid B);
{* selection for pair 11 base B *}
{===>} base_b_11=(resid 30 and segid B);

{* selection for pair 12 base A *}
{===>} base_a_12=(resid 12 and segid B);
{* selection for pair 12 base B *}
{===>} base_b_12=(resid 29 and segid B);

{* selection for pair 13 base A *}
{===>} base_a_13=(resid 13 and segid B);
{* selection for pair 13 base B *}
{===>} base_b_13=(resid 28 and segid B);

{* selection for pair 14 base A *}
{===>} base_a_14=(resid 14 and segid B);
{* selection for pair 14 base B *}
{===>} base_b_14=(resid 27 and segid B);

{* selection for pair 15 base A *}
{===>} base_a_15=(resid 15 and segid B);
{* selection for pair 15 base B *}
{===>} base_b_15=(resid 26 and segid B);

{* selection for pair 16 base A *}
{===>} base_a_16=(resid 16 and segid B);
{* selection for pair 16 base B *}
{===>} base_b_16=(resid 25 and segid B);

{* selection for pair 17 base A *}
{===>} base_a_17=(resid 17 and segid B);
{* selection for pair 17 base B *}
{===>} base_b_17=(resid 24 and segid B);

{* selection for pair 18 base A *}
{===>} base_a_18=(resid 18 and segid B);
{* selection for pair 18 base B *}
{===>} base_b_18=(resid 23 and segid B);

{* selection for pair 19 base A *}
{===>} base_a_19=(resid 19 and segid B);
{* selection for pair 19 base B *}
{===>} base_b_19=(resid 22 and segid B);

{* selection for pair 20 base A *}
{===>} base_a_20=(resid 20 and segid B);
{* selection for pair 20 base B *}
{===>} base_b_20=(resid 21 and segid B);

{=========================================================================================================}
{                        things below this line do not normally need to be changed                        }
{=========================================================================================================}

 ) {- end block parameter definition -}

{- the planarity restraints for Watson-Crick base pairing -}

if (&basepair_planar=true) then
 evaluate ($pair=1)
 evaluate ($done=false)
 while ( $done = false ) loop plan_paired
   if ( &exist_base_a_$pair = true ) then
     if ( &exist_base_b_$pair = true ) then
       show (segid) ( &base_a_$pair and name C1' ) 
       evaluate ($Asegid=$result)
       show (resid) ( &base_a_$pair and name C1' ) 
       evaluate ($Aresid=$result)
       show (segid) ( &base_b_$pair and name C1' ) 
       evaluate ($Bsegid=$result)
       show (resid) ( &base_b_$pair and name C1' ) 
       evaluate ($Bresid=$result)
       evaluate ($plweight = 20)			! Enforce planarity by increasing plweight value.

       restraints plane

         group
           selection=(((segid $Asegid and resid $Aresid) or (segid $Bsegid and resid $Bresid)) and
                      (resn THY or resn CYT or resn GUA or resn ADE or resn URI or
		       resn T   or resn C   or resn G   or resn A   or resn U or
		       resn DT  or resn DC  or resn DG  or resn DA) and
                       not (name c#' or name h#' or name h#'' or name o#p or
                            name h7# or name o#' or name p or name h#t or name o#t))
           weight=$plweight
         end
       end
     end if
   else
     evalute ($done = true)
   end if
     evaluate ($pair = $pair + 1)
 end loop plan_paired
else
end if
flag include plan end

{- the planarity restraints single bases -}

 for $id in id ( &bases_planar and tag and not (resn WAT or resn HOH or resn TIP*) ) loop plan
   show (segid) (id $id)
   evaluate ($segid=$result)
   show (resid) (id $id)
   evaluate ($resid=decode($result))
   evaluate ($plweight = 20)

   restraints plane

     group
       selection=( segid $segid and resid $resid and
                  (resn THY or resn CYT or resn GUA or resn ADE or resn URI or
		   resn T   or resn C   or resn G   or resn A   or resn U or
		   resn DT  or resn DC  or resn DG  or resn DA) and
                   not (name c#' or name h#' or name h#'' or name o#p or
                        name h7# or name o#' or name p or name h#t or name o#t))
       weight=$plweight
     end
   end
 end loop plan

{- Dihedral restraints for the sugar pucker -}

if (&dna_pick_pucdih=true) then
  evaluate ($group=1)
  evaluate ($done=false)
  while ( $done = false ) loop dihe
   if ( &exist_pucker_$group = true ) then
     show sum(1) ( &pucker_$group )
     if ( $result > 0 ) then
       evaluate ($min_resid_$group = 99999)
       evaluate ($max_resid_$group = -99999)
       evaluate ($error_nu2=&error_nu2_$group)
       evaluate ($error_nu3=&error_nu3_$group)
       evaluate ($error_nu4=&error_nu4_$group)	 
       for $id in id ( &pucker_$group and tag and not (resn WAT or resn HOH or resn TIP*) ) loop resid
         show (segid) (id $id)
         evaluate ($segid=$result)
         show (resid) ( id $id )
         evaluate ($resid=decode($result))
	 evaluate ($min_resid_$group = max($min_resid_$group,$resid))
	 evaluate ($max_resid_$group = max($max_resid_$group,$resid))
         pick dihedral
                   ( segid $segid and resid $resid and name c1' )
                   ( segid $segid and resid $resid and name c2' )
                   ( segid $segid and resid $resid and name c3' )
                   ( segid $segid and resid $resid and name c4' ) 
		  geometry
	 evaluatate ($dihedral_nu2=$result)
	 pick dihedral
                   ( segid $segid and resid $resid and name c5' )
                   ( segid $segid and resid $resid and name c4' )
                   ( segid $segid and resid $resid and name c3' )
                   ( segid $segid and resid $resid and name c2' ) 
		  geometry
	 evaluatate ($dihedral_nu3=$result)
	 pick dihedral
                   ( segid $segid and resid $resid and name c1' )
                   ( segid $segid and resid $resid and name o4' )
                   ( segid $segid and resid $resid and name c4' )
                   ( segid $segid and resid $resid and name c5' ) 
		  geometry
	 evaluatate ($dihedral_nu4=$result)
	  
      restraints dihedral
           assign  ( segid $segid and resid $resid and name c1' )
                   ( segid $segid and resid $resid and name c2' )
                   ( segid $segid and resid $resid and name c3' )
                   ( segid $segid and resid $resid and name c4' ) 
                                                       20.0 $dihedral_nu2 $error_nu2 2
           assign  ( segid $segid and resid $resid and name c5' )
                   ( segid $segid and resid $resid and name c4' )
                   ( segid $segid and resid $resid and name c3' )
                   ( segid $segid and resid $resid and name c2' ) 
                                                       20.0 $dihedral_nu3 $error_nu3 2
           assign  ( segid $segid and resid $resid and name c1' )
                   ( segid $segid and resid $resid and name o4' )
                   ( segid $segid and resid $resid and name c4' )
                   ( segid $segid and resid $resid and name c5' ) 
                                                       20.0 $dihedral_nu4 $error_nu4 2
           scale=20.0
         end
       end loop resid
     end if
   else
     evaluate ($done=true)
   end if
   evaluate ($group=$group+1)
  end loop dihe

 else

 evaluate ($group=1)
 evaluate ($done=false)
 while ( $done = false ) loop dihe
   if ( &exist_pucker_$group = true ) then
     show sum(1) ( &pucker_$group )
     if ( $result > 0 ) then
       if ( &form_$group = "a-form" ) then
         evaluate ($dihedral_nu2=37.053)
         evaluate ($dihedral_nu3=-155.59)
         evaluate ($dihedral_nu4=144.26)
       elseif ( &form_$group = "b-form" ) then
         evaluate ($dihedral_nu2=-34.9)
         evaluate ($dihedral_nu3=-86.4)
         evaluate ($dihedral_nu4=106.4)
       elseif ( &form_$group = "other" ) then
         evaluate ($dihedral_nu2=&dihedral_nu2_$group)
         evaluate ($dihedral_nu3=&dihedral_nu3_$group)
         evaluate ($dihedral_nu4=&dihedral_nu4_$group)
       end if

       evaluate ($min_resid_$group = 99999)
       evaluate ($max_resid_$group = -99999)

       for $id in id ( &pucker_$group and tag and not (resn WAT or resn HOH or resn TIP*) ) loop resid

         show (segid) (id $id)
         evaluate ($segid=$result)
         show (resid) ( id $id )
         evaluate ($resid=decode($result))
	 evaluate ($min_resid_$group = max($min_resid_$group,$resid))
	 evaluate ($max_resid_$group = max($max_resid_$group,$resid))

         restraints dihedral
           assign  ( segid $segid and resid $resid and name c1' )
                   ( segid $segid and resid $resid and name c2' )
                   ( segid $segid and resid $resid and name c3' )
                   ( segid $segid and resid $resid and name c4' ) 
                                                       20.0 $dihedral_nu2 0.0 2
           assign  ( segid $segid and resid $resid and name c5' )
                   ( segid $segid and resid $resid and name c4' )
                   ( segid $segid and resid $resid and name c3' )
                   ( segid $segid and resid $resid and name c2' ) 
                                                       20.0 $dihedral_nu3 0.0 2
           assign  ( segid $segid and resid $resid and name c1' )
                   ( segid $segid and resid $resid and name o4' )
                   ( segid $segid and resid $resid and name c4' )
                   ( segid $segid and resid $resid and name c5' ) 
                                                       20.0 $dihedral_nu4 0.0 2
  
           scale=20.0
         end
       end loop resid
     end if
   else
     evaluate ($done=true)
   end if
   evaluate ($group=$group+1)
 end loop dihe
end if
flags include cdih end

{- Dihedral restraints for the phosphate backbone -}

if (&dna_pick_bacdih=true) then
  evaluate ($group=1)
  evaluate ($done=false)
  while ( $done = false ) loop bdihe
   if ( &exist_dihedral_$group = true ) then
     show sum(1) ( &dihedral_$group )
     if ( $result > 0 ) then
       evaluate ($resid=$min_resid_$group)
       evaluate ($nres=$max_resid_$group - $min_resid_$group + 1)
       evaluate ($error_alpha=&error_alpha_$group)
       evaluate ($error_beta=&error_beta_$group)
       evaluate ($error_gamma=&error_gamma_$group)
       evaluate ($error_zeta=&error_zeta_$group)
       evaluate ($error_epsilon=&error_eps_$group)
       evaluate ($error_delta=&error_delta_$group)
       for $id in id ( &dihedral_$group and tag and not (resn WAT or resn HOH or resn TIP*) ) loop resid
         show (segid) (id $id)
         evaluate ($segid=$result)
         show (resid) ( id $id )
         evaluate ($resid=decode($result))
         if ($resid > $min_resid_$group) then
           evaluate ($rprec = $resid - 1)
	   pick dihedral
                     ( segid $segid and resid $rprec and name O3' )
                     ( segid $segid and resid $resid and name P )
                     ( segid $segid and resid $resid and name O5' )
                     ( segid $segid and resid $resid and name C5' ) 
		  geometry
	   evaluatate ($dihedral_alpha=$result)
	   pick dihedral
                     ( segid $segid and resid $resid and name P )
                     ( segid $segid and resid $resid and name O5' )
                     ( segid $segid and resid $resid and name C5' )
                     ( segid $segid and resid $resid and name C4' ) 
		  geometry
	   evaluatate ($dihedral_beta=$result)
	   
           restraint dihedral
	    ! alpha
             assign  ( segid $segid and resid $rprec and name O3' )
                     ( segid $segid and resid $resid and name P )
                     ( segid $segid and resid $resid and name O5' )
                     ( segid $segid and resid $resid and name C5' ) 
                                                       1.0 $dihedral_alpha $error_alpha 2
	    ! beta					       
             assign  ( segid $segid and resid $resid and name P )
                     ( segid $segid and resid $resid and name O5' )
                     ( segid $segid and resid $resid and name C5' )
                     ( segid $segid and resid $resid and name C4' ) 
                                                       1.0 $dihedral_beta $error_beta 2
             scale 200.0
           end
         end if

	 pick dihedral
                     ( segid $segid and resid $resid and name O5' )
                     ( segid $segid and resid $resid and name C5' )
                     ( segid $segid and resid $resid and name C4' )
                     ( segid $segid and resid $resid and name C3' ) 
	  	  geometry
	 evaluatate ($dihedral_gamma=$result)
         pick dihedral
                     ( segid $segid and resid $resid and name C5' )
                     ( segid $segid and resid $resid and name C4' )
                     ( segid $segid and resid $resid and name C3' )
                     ( segid $segid and resid $resid and name O3' ) 
		  geometry
	   evaluatate ($dihedral_delta=$result)
	 
	 restraints dihedral
	    ! gamma
             assign  ( segid $segid and resid $resid and name O5' )
                     ( segid $segid and resid $resid and name C5' )
                     ( segid $segid and resid $resid and name C4' )
                     ( segid $segid and resid $resid and name C3' ) 
                                                       1.0 $dihedral_gamma $error_gamma 2
	    ! delta					       
             assign  ( segid $segid and resid $resid and name C5' )
                     ( segid $segid and resid $resid and name C4' )
                     ( segid $segid and resid $resid and name C3' )
                     ( segid $segid and resid $resid and name O3' ) 
                                                       1.0 $dihedral_delta $error_delta 2		    
	      scale=200.0
            end
          
	  if ($resid < $max_resid_$group) then
           evaluate ($rfoll = $resid + 1)
	   pick dihedral
                     ( segid $segid and resid $resid and name C4' )
                     ( segid $segid and resid $resid and name C3' )
                     ( segid $segid and resid $resid and name O3' )
                     ( segid $segid and resid $rfoll and name P ) 
		  geometry
	   evaluatate ($dihedral_epsilon=$result)
	   pick dihedral
                     ( segid $segid and resid $resid and name C3' )
                     ( segid $segid and resid $resid and name O3' )
                     ( segid $segid and resid $rfoll and name P )
                     ( segid $segid and resid $rfoll and name O5' ) 
		  geometry
	   evaluatate ($dihedral_zeta=$result)
           restraint dihedral
             ! epsilon
	     assign  ( segid $segid and resid $resid and name C4' )
                     ( segid $segid and resid $resid and name C3' )
                     ( segid $segid and resid $resid and name O3' )
                     ( segid $segid and resid $rfoll and name P ) 
                                                       1.0 $dihedral_epsilon $error_epsilon 2
             ! zeta
	     assign  ( segid $segid and resid $resid and name C3' )
                     ( segid $segid and resid $resid and name O3' )
                     ( segid $segid and resid $rfoll and name P )
                     ( segid $segid and resid $rfoll and name O5' ) 
                                                       1.0 $dihedral_zeta $error_zeta 2
             scale 200.0
           end
         end if
       end loop resid
     end if
   else
     evaluate ($done=true)
   end if
     evaluate ($group=$group+1)
 end loop bdihe

 else

 evaluate ($group=1)
 evaluate ($done=false)
 while ( $done = false ) loop bdihe
 if ( &exist_dihedral_$group = true ) then
     show sum(1) ( &dihedral_$group )
     if ( $result > 0 ) then
       evaluate ($resid=$min_resid_$group)
       evaluate ($nres=$max_resid_$group - $min_resid_$group + 1)
       if ( &form_$group = "a-form" ) then
         evaluate ($dihedral_alpha=-70)
	 evaluate ($error_alpha=50)
         evaluate ($dihedral_beta=180)
	 evaluate ($error_beta=50)
         evaluate ($dihedral_gamma=60)
	 evaluate ($error_gamma=35)
         evaluate ($dihedral_delta=81)
         evaluate ($error_delta=20)
         evaluate ($dihedral_zeta=-85)
	 evaluate ($error_zeta=50)
         evaluate ($dihedral_epsilon=180)
	 evaluate ($error_epsilon=35)
       elseif ( &form_$group = "b-form" ) then
         evaluate ($dihedral_alpha=-63.6)
	 evaluate ($error_alpha=6)
         evaluate ($dihedral_beta=176)
	 evaluate ($error_beta=7)
         evaluate ($dihedral_gamma=51.4)
	 evaluate ($error_gamma=7)
         evaluate ($dihedral_delta=128)
         evaluate ($error_delta=13)
         evaluate ($dihedral_epsilon=-171.7)
	 evaluate ($error_epsilon=3.7)
         evaluate ($dihedral_zeta=-103.8)
	 evaluate ($error_zeta=10)
       elseif ( &form_$group = "other" ) then
         evaluate ($dihedral_alpha=&dihedral_alpha_$group)
	 evaluate ($error_alpha=&error_alpha_$group)
         evaluate ($dihedral_beta=&dihedral_beta_$group)
	 evaluate ($error_beta=&error_beta_$group)
         evaluate ($dihedral_gamma=&dihedral_gamma_$group)
	 evaluate ($error_gamma=&error_gamma_$group)
         evaluate ($dihedral_delta=&dihedral_delta_$group)
	 evaluate ($error_delta=&error_delta_$group)
	 evaluate ($dihedral_zeta=&dihedral_zeta_$group)
	 evaluate ($error_zeta=&error_zeta_$group)
         evaluate ($dihedral_epsilon=&dihedral_eps_$group)
	 evaluate ($error_epsilon=&error_eps_$group)
       end if

       for $id in id ( &dihedral_$group and tag and not (resn WAT or resn HOH or resn TIP*) ) loop resid
         show (segid) (id $id)
         evaluate ($segid=$result)
         show (resid) ( id $id )
         evaluate ($resid=decode($result))
         if ($resid > $min_resid_$group) then
           evaluate ($rprec = $resid - 1)
           restraint dihedral
             ! alpha
	     assign  ( segid $segid and resid $rprec and name O3' )
                     ( segid $segid and resid $resid and name P )
                     ( segid $segid and resid $resid and name O5' )
                     ( segid $segid and resid $resid and name C5' ) 
                                                       1.0 $dihedral_alpha $error_alpha 2
             ! beta
	     assign  ( segid $segid and resid $resid and name P )
                     ( segid $segid and resid $resid and name O5' )
                     ( segid $segid and resid $resid and name C5' )
                     ( segid $segid and resid $resid and name C4' ) 
                                                       1.0 $dihedral_beta $error_beta 2
             scale 200.0
           end
         end if

         restraints dihedral
             ! gamma
	     assign  ( segid $segid and resid $resid and name O5' )
                     ( segid $segid and resid $resid and name C5' )
                     ( segid $segid and resid $resid and name C4' )
                     ( segid $segid and resid $resid and name C3' ) 
                                                       1.0 $dihedral_gamma $error_gamma 2
             !delta
	     assign  ( segid $segid and resid $resid and name C5' )
                     ( segid $segid and resid $resid and name C4' )
                     ( segid $segid and resid $resid and name C3' )
                     ( segid $segid and resid $resid and name O3' ) 
                                                       1.0 $dihedral_delta $error_delta 2	         
	     scale=200.0
           end
         
	 if ($resid < $max_resid_$group) then
           evaluate ($rfoll = $resid + 1)
           restraint dihedral
             ! epsilon
	     assign  ( segid $segid and resid $resid and name C4' )
                     ( segid $segid and resid $resid and name C3' )
                     ( segid $segid and resid $resid and name O3' )
                     ( segid $segid and resid $rfoll and name P ) 
                                                       1.0 $dihedral_epsilon $error_epsilon 2
             ! zeta
	     assign  ( segid $segid and resid $resid and name C3' )
                     ( segid $segid and resid $resid and name O3' )
                     ( segid $segid and resid $rfoll and name P )
                     ( segid $segid and resid $rfoll and name O5' ) 
                                                       1.0 $dihedral_zeta $error_zeta 2
             scale 200.0
           end
         end if
       end loop resid
     end if
   else
     evaluate ($done=true)
   end if
   evaluate ($group=$group+1)
  end loop bdihe
 end if
flags include cdih end

{- C1'-C1' virtual bond length restraints -}

noe
   class hres
   averaging hres cent
   potential hres square
   sqconstant hres 1.
   sqexponent hres 2
   scale hres 70.
 end           

if (&dna_pick_c1 = true) then
  evaluate ($pair=1)
  evaluate ($done=false)
  while ( $done = false ) loop noe
   if ( &exist_base_a_$pair = true ) then
     if ( &exist_base_b_$pair = true ) then
       show ( resn ) ( &base_a_$pair and name C1' ) 
       evaluate ($ares=$result)
       show ( resn ) ( &base_b_$pair and name C1' ) 
       evaluate ($bres=$result)
        pick bond
			(&base_a_$pair and name C1') 
			(&base_b_$pair and name C1')
	   geometry
        evaluate ($c1c1=$result)
        noe
        assign (&base_a_$pair and name C1') 
               (&base_b_$pair and name C1') $c1c1 &c1_low &c1_up 
        end
     end if
   else
     evaluate ($done=true)
   end if         
     evaluate ($pair=$pair+1)
  end loop noe
 else
end if
flags include noe end

{- Watson-Crick base pairing -}

 noe
   class hres
   averaging hres cent
   potential hres square
   sqconstant hres 1.
   sqexponent hres 2
   scale hres 70.
 end           

 if (&dna_pick_wc = true) then
  evaluate ($pair=1)
  evaluate ($done=false)
  while ( $done = false ) loop noe
   if ( &exist_base_a_$pair = true ) then
     if ( &exist_base_b_$pair = true ) then
       show ( resn ) ( &base_a_$pair and name C1' ) 
       evaluate ($ares=$result)
       show ( resn ) ( &base_b_$pair and name C1' ) 
       evaluate ($bres=$result)
       if ( $ares = THY ) then
        pick bond
                  (&base_a_$pair and name o4) 
                  (&base_b_$pair and name n6)
		  geometry
        evaluate ($o4n6=$result)
        pick bond
                  (&base_a_$pair and name n3) 
                  (&base_b_$pair and name n1)
		  geometry
        evaluate ($n3n1=$result)
        pick bond
                  (&base_a_$pair and name h3) 
                  (&base_b_$pair and name n1)
		  geometry
        evaluate ($h3n1=$result)
        pick bond
                  (&base_a_$pair and name o2) 
                  (&base_b_$pair and name h2)
		  geometry
        evaluate ($o2h2=$result)
        pick bond
                  (&base_a_$pair and name o4) 
                  (&base_b_$pair and name n1)
		  geometry
        evaluate ($o4n1=$result)
        pick bond
                  (&base_a_$pair and name o2) 
                  (&base_b_$pair and name n1)
		  geometry
        evaluate ($o2n1=$result)
       elseif ( $ares = URI ) then
        pick bond
                  (&base_a_$pair and name o4) 
                  (&base_b_$pair and name n6)
		  geometry
        evaluate ($o4n6=$result)
        pick bond
                  (&base_a_$pair and name n3) 
                  (&base_b_$pair and name n1)
		  geometry
        evaluate ($n3n1=$result)
        pick bond
                  (&base_a_$pair and name o4) 
                  (&base_b_$pair and name n1)
		  geometry
        evaluate ($o4n1=$result)
        pick bond
                  (&base_a_$pair and name o2) 
                  (&base_b_$pair and name n6)
		  geometry
        evaluate ($o2n6=$result)
       elseif ( $ares = ADE ) then
        pick bond
                  (&base_b_$pair and name o4) 
                  (&base_a_$pair and name n6)
		  geometry
        evaluate ($o4n6=$result)
        pick bond
                  (&base_b_$pair and name n3) 
                  (&base_a_$pair and name n1)
		  geometry
        evaluate ($n3n1=$result)
        pick bond
                  (&base_b_$pair and name h3) 
                  (&base_a_$pair and name n1)
		  geometry
        evaluate ($h3n1=$result)
        pick bond
                  (&base_b_$pair and name o2) 
                  (&base_a_$pair and name h2)
		  geometry
        evaluate ($o2h2=$result)
        pick bond
                  (&base_b_$pair and name o4) 
                  (&base_a_$pair and name n1)
		  geometry
        evaluate ($o4n1=$result)
        pick bond
                  (&base_b_$pair and name o2) 
                  (&base_a_$pair and name n1)
		  geometry
        evaluate ($o2n1=$result)
       elseif ( $ares = CYT ) then
        pick bond
                  (&base_a_$pair and name n3) 
                  (&base_b_$pair and name n1)
		  geometry
        evaluate ($n3n1=$result)
        pick bond
                  (&base_a_$pair and name n3) 
                  (&base_b_$pair and name h1)
		  geometry
        evaluate ($n3h1=$result)
        pick bond
                  (&base_a_$pair and name n4) 
                  (&base_b_$pair and name o6)
		  geometry
        evaluate ($n4o6=$result)
        pick bond
                  (&base_a_$pair and name o2) 
                  (&base_b_$pair and name n2)
		  geometry
        evaluate ($o2n2=$result)
        pick bond
                  (&base_a_$pair and name n3) 
                  (&base_b_$pair and name o6)
		  geometry
        evaluate ($n3o6=$result)
        pick bond
                  (&base_a_$pair and name n3) 
                  (&base_b_$pair and name n2)
		  geometry
        evaluate ($n3n2=$result)
       elseif ( $ares = GUA ) then
        pick bond
                  (&base_b_$pair and name n3) 
                  (&base_a_$pair and name n1)
		  geometry
        evaluate ($n3n1=$result)
        pick bond
                  (&base_b_$pair and name n3) 
                  (&base_a_$pair and name h1)
		  geometry
        evaluate ($n3h1=$result)
        pick bond
                  (&base_b_$pair and name n4) 
                  (&base_a_$pair and name o6)
		  geometry
        evaluate ($n4o6=$result)
        pick bond
                  (&base_b_$pair and name o2) 
                  (&base_a_$pair and name n2)
		  geometry
        evaluate ($o2n2=$result)
        pick bond
                  (&base_b_$pair and name n3) 
                  (&base_a_$pair and name o6)
		  geometry
        evaluate ($n3o6=$result)
        pick bond
                  (&base_b_$pair and name n3) 
                  (&base_a_$pair and name n2)
		  geometry
        evaluate ($n3n2=$result)

       end if
       noe
         if ( $ares = THY ) then
           assign (&base_a_$pair and name o4) 
                  (&base_b_$pair and name n6) $o4n6 &wc_low &wc_up 
           assign (&base_a_$pair and name n3) 
                  (&base_b_$pair and name n1) $n3n1 &wc_low &wc_up
           assign (&base_a_$pair and name h3) 
                  (&base_b_$pair and name n1) $h3n1 &wc_low &wc_up 
           assign (&base_a_$pair and name o2) 
                  (&base_b_$pair and name h2) $o2h2 &wc_low &wc_up
           assign (&base_a_$pair and name o4) 
                  (&base_b_$pair and name n1) $o4n1 &wc_low &wc_up
           assign (&base_a_$pair and name o2) 
                  (&base_b_$pair and name n1) $o2n1 &wc_low &wc_up
         elseif ( $ares = URI ) then
           assign (&base_a_$pair and name o4) 
                  (&base_b_$pair and name n6) $o4n6 &wc_low_uri &wc_up_uri 
           assign (&base_a_$pair and name n3) 
                  (&base_b_$pair and name n1) $n3n1 &wc_low_uri &wc_up_uri
           assign (&base_a_$pair and name o4) 
                  (&base_b_$pair and name n1) $o4n1 &wc_low_uri &wc_up_uri 
           assign (&base_a_$pair and name o2) 
                  (&base_b_$pair and name n6) $o2n6 &wc_low_uri &wc_up_uri
         elseif ( $ares = ADE ) then
           assign (&base_b_$pair and name o4) 
                  (&base_a_$pair and name n6) $o4n6 &wc_low &wc_up 
           assign (&base_b_$pair and name n3) 
                  (&base_a_$pair and name n1) $n3n1 &wc_low &wc_up
           assign (&base_b_$pair and name h3) 
                  (&base_a_$pair and name n1) $h3n1 &wc_low &wc_up 
           assign (&base_b_$pair and name o2) 
                  (&base_a_$pair and name h2) $o2h2 &wc_low &wc_up
           assign (&base_b_$pair and name o4) 
                  (&base_a_$pair and name n1) $o4n1 &wc_low &wc_up
           assign (&base_b_$pair and name o2) 
                  (&base_a_$pair and name n1) $o2n1 &wc_low &wc_up
         elseif ( $ares = CYT ) then
           assign (&base_a_$pair and name n3) 
                  (&base_b_$pair and name n1) $n3n1 &wc_low &wc_up 
           assign (&base_a_$pair and name n3) 
                  (&base_b_$pair and name h1) $n3h1 &wc_low &wc_up
           assign (&base_a_$pair and name n4)
                  (&base_b_$pair and name o6) $n4o6 &wc_low &wc_up
           assign (&base_a_$pair and name o2)
                  (&base_b_$pair and name n2) $o2n2 &wc_low &wc_up 
           assign (&base_a_$pair and name n3)
                  (&base_b_$pair and name o6) $n3o6 &wc_low &wc_up
           assign (&base_a_$pair and name n3)
                  (&base_b_$pair and name n2) $n3n2 &wc_low &wc_up
         elseif ( $ares = GUA ) then
           assign (&base_b_$pair and name n3) 
                  (&base_a_$pair and name n1) $n3n1 &wc_low &wc_up 
           assign (&base_b_$pair and name n3) 
                  (&base_a_$pair and name h1) $n3h1 &wc_low &wc_up
           assign (&base_b_$pair and name n4)
                  (&base_a_$pair and name o6) $n4o6 &wc_low &wc_up
           assign (&base_b_$pair and name o2)
                  (&base_a_$pair and name n2) $o2n2 &wc_low &wc_up 
           assign (&base_b_$pair and name n3)
                  (&base_a_$pair and name o6) $n3o6 &wc_low &wc_up
           assign (&base_b_$pair and name n3)
                  (&base_a_$pair and name n2) $n3n2 &wc_low &wc_up
         end if
       end
     end if
   else
     evaluate ($done=true)
   end if         
   evaluate ($pair=$pair+1)
  end loop noe

 else
 
 evaluate ($pair=1)
 evaluate ($done=false)
 while ( $done = false ) loop noe
   if ( &exist_base_a_$pair = true ) then
     if ( &exist_base_b_$pair = true ) then
       show ( resn ) ( &base_a_$pair and name C1' ) 
       evaluate ($ares=$result)
       show ( resn ) ( &base_b_$pair and name C1' ) 
       evaluate ($bres=$result)
       noe
         if ( $ares = THY ) then
           assign (&base_a_$pair and name o4) 
                  (&base_b_$pair and name n6) 2.89 0.2 0.2 
           assign (&base_a_$pair and name n3) 
                  (&base_b_$pair and name n1) 2.92 0.2 0.2
           assign (&base_a_$pair and name h3) 
                  (&base_b_$pair and name n1) 1.87 0.2 0.2 
           assign (&base_a_$pair and name o2) 
                  (&base_b_$pair and name h2) 2.94 0.2 0.2
           assign (&base_a_$pair and name o4) 
                  (&base_b_$pair and name n1) 3.69 0.2 0.2
           assign (&base_a_$pair and name o2) 
                  (&base_b_$pair and name n1) 3.67 0.2 0.2	    
         elseif ( $ares = URI ) then
           assign (&base_a_$pair and name o4) 
                  (&base_b_$pair and name n6) 2.95 0.01 0.01 
           assign (&base_a_$pair and name n3) 
                  (&base_b_$pair and name n1) 2.82 0.01 0.01
           assign (&base_a_$pair and name o4) 
                  (&base_b_$pair and name n1) 3.63 0.01 0.01 
           assign (&base_a_$pair and name o2) 
                  (&base_b_$pair and name n6) 5.40 0.01 0.01
         elseif ( $ares = ADE ) then
           assign (&base_b_$pair and name o4) 
                  (&base_a_$pair and name n6) 2.89 0.2 0.2 
           assign (&base_b_$pair and name n3) 
                  (&base_a_$pair and name n1) 2.92 0.2 0.2
           assign (&base_b_$pair and name h3) 
                  (&base_a_$pair and name n1) 1.87 0.2 0.2 
           assign (&base_b_$pair and name o2) 
                  (&base_a_$pair and name h2) 2.94 0.2 0.2
           assign (&base_b_$pair and name o4) 
                  (&base_a_$pair and name n1) 3.69 0.2 0.2
           assign (&base_b_$pair and name o2) 
                  (&base_a_$pair and name n1) 3.67 0.2 0.2
         elseif ( $ares = CYT ) then
           assign (&base_a_$pair and name n3) 
                  (&base_b_$pair and name n1) 2.87 0.2 0.2 
           assign (&base_a_$pair and name n3) 
                  (&base_b_$pair and name h1) 1.86 0.2 0.2
           assign (&base_a_$pair and name n4)
                  (&base_b_$pair and name o6) 2.81 0.2 0.2
           assign (&base_a_$pair and name o2)
                  (&base_b_$pair and name n2) 2.81 0.2 0.2 
           assign (&base_a_$pair and name n3)
                  (&base_b_$pair and name o6) 3.58 0.2 0.2
           assign (&base_a_$pair and name n3)
                  (&base_b_$pair and name n2) 3.63 0.2 0.2
         elseif ( $ares = GUA ) then
           assign (&base_b_$pair and name n3) 
                  (&base_a_$pair and name n1) 2.87 0.2 0.2 
           assign (&base_b_$pair and name n3) 
                  (&base_a_$pair and name h1) 1.86 0.2 0.2
           assign (&base_b_$pair and name n4)
                  (&base_a_$pair and name o6) 2.81 0.2 0.2
           assign (&base_b_$pair and name o2)
                  (&base_a_$pair and name n2) 2.81 0.2 0.2 
           assign (&base_b_$pair and name n3)
                  (&base_a_$pair and name o6) 3.58 0.2 0.2
           assign (&base_b_$pair and name n3)
                  (&base_a_$pair and name n2) 3.63 0.2 0.2
         end if
       end
     end if
   else
     evaluate ($done=true)
   end if         
   evaluate ($pair=$pair+1)
 end loop noe
 end if
 flags include noe end

set message=off echo=off end


