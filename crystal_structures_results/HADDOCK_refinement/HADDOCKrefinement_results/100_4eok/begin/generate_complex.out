          ============================================================
          |                                                          |
          |            Crystallography & NMR System (CNS)            |
          |                         CNSsolve                         |
          |                                                          |
          ============================================================
           Version: 1.3 at patch level U
           Status: Special UU release with Rg and paramagnetic
                   restraints (A. Bonvin, UU 2011)
          ============================================================
           Written by: A.T.Brunger, P.D.Adams, G.M.Clore, W.L.DeLano,
                       P.Gros, R.W.Grosse-Kunstleve,J.-S.Jiang,J.M.Krahn,
                       J.Kuszewski, M.Nilges, N.S.Pannu, R.J.Read,
                       L.M.Rice, G.F.Schroeder, T.Simonson, G.L.Warren.
           Copyright (c) 1997-2010 Yale University
          ============================================================
           Running on machine: node011 (x86_64/Linux,64-bit)
           Program started by: enmr
           Program started at: 00:14:55 on 29-Dec-2019
          ============================================================

 FFT3C: Using FFTPACK4.1

 CNSsolve>! generate_complex.inp 
 CNSsolve>!    Merge the coordinates and topologies of the various components of the complex 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{- begin block parameter definition -} define( 
 DEFINE> 
 DEFINE>{================== parameter files ===================} 
 DEFINE> 
 DEFINE>{* protein parameter file *} 
 DEFINE>{===>} prot_parameter_infile="RUN:toppar/protein-allhdg5-4.param"; 
 DEFINE> 
 DEFINE>{* nucleic acid parameter file *} 
 DEFINE>{===>} nucl_parameter_infile="RUN:/toppar/dna-rna-allatom-hj-opls-1.3.param"; 
 DEFINE> 
 DEFINE>{* carbohydrate parameter file *} 
 DEFINE>{===>} carbo_parameter_infile="RUN:/toppar/carbohydrate.param"; 
 DEFINE> 
 DEFINE>{* solvent parameter file *} 
 DEFINE>{===>} solv_parameter_infile="RUN:/toppar/water-allhdg5-4.param"; 
 DEFINE> 
 DEFINE>{* co-factor parameter file *} 
 DEFINE>{===>} cofac_parameter_infile="RUN:/toppar/ligand.param"; 
 DEFINE> 
 DEFINE>{* ligands parameter file *} 
 DEFINE>{===>} ligands_parameter_infile="RUN:/toppar/fragment_probes.param"; 
 DEFINE> 
 DEFINE>{* ion parameter file *} 
 DEFINE>{===>} ion_parameter_infile="RUN:/toppar/ion.param"; 
 DEFINE> 
 DEFINE>{* heme parameter file *} 
 DEFINE>{===>} heme_parameter_infile="RUN:/toppar/hemes-allhdg.param"; 
 DEFINE> 
 DEFINE> ) {- end block parameter definition -} 
 CNSsolve> 
 CNSsolve>! a maximum number of structures to be written to avoid 
 CNSsolve>! filling the disk space 
 CNSsolve>evalute ($maxstruc = 4000) 
 EVALUATE: symbol $MAXSTRUC set to    4000.00     (real)
 CNSsolve> 
 CNSsolve>@RUN:protocols/initialize.cns(iteration=$iteration;) 
 ASSFIL: file initialize.cns opened.
 CNSsolve>! initialize.cns 
 CNSsolve>!    Iteration initialization 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module (iteration;) 
 &_2_ITERATION set to $_1_ITERATION 
 CNSsolve>evaluate (&iteration = "") 
 EVALUATE: symbol $_1_ITERATION set to "" (string)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>@RUN:begin/iteration.cns(iteration=$iteration;) 
 ASSFIL: file iteration.cns opened.
 CNSsolve>module ( iteration ) 
 &_2_ITERATION set to $_1_ITERATION 
 CNSsolve>evaluate (&iteration=0) 
 EVALUATE: symbol $_1_ITERATION set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>@RUN:run.cns( 
 ASSFIL: file run.cns opened.
 CNSsolve>! run.cns-milou 
 CNSsolve>!    The file containing all parameters for HADDOCK 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>module( 
 MODULE-DECLARATION>iteration; 
 MODULE-DECLARATION>filenames; 
 MODULE-DECLARATION>data; 
 MODULE-DECLARATION>iterations; 
 MODULE-DECLARATION>saprotocol; 
 MODULE-DECLARATION>refine; 
 MODULE-DECLARATION>toppar; 
 MODULE-DECLARATION>analysis; 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>iteration =$iteration; 
 &_2_ITERATION set to $_1_ITERATION 
 MODULE-INVOCATION>filenames =$filenames; 
 &_2_FILENAMES set to $_1_FILENAMES 
 MODULE-INVOCATION>Data      =$Data; 
 &_2_DATA set to $_1_DATA 
 MODULE-INVOCATION>iterations=$iterations; 
 &_2_ITERATIONS set to $_1_ITERATIONS 
 MODULE-INVOCATION>saprotocol=$saprotocol; 
 &_2_SAPROTOCOL set to $_1_SAPROTOCOL 
 MODULE-INVOCATION>refine    =$refine; 
 &_2_REFINE set to $_1_REFINE 
 MODULE-INVOCATION>toppar    =$toppar; 
 &_2_TOPPAR set to $_1_TOPPAR 
 MODULE-INVOCATION>analysis  =$analysis;) 
 &_2_ANALYSIS set to $_1_ANALYSIS 
 CNSsolve>{+ File: run.cns +} 
 CNSsolve>{+ Description: this file contains all necessary information to run HADDOCK. +} 
 CNSsolve>{+ Authors: Alexandre Bonvin<br> 
 CNSsolve>Version: 2.2, Aug 22, 2012 <br><br> 
 CNSsolve>Initially adapted from ARIA of Nilges and Linge +} 
 CNSsolve>! Please cite the following references when using this protocol: 
 CNSsolve>{+ reference: Cyril Dominguez, Rolf Boelens and Alexandre M.J.J. Bonvin (2003).  HADDOCK: a protein-protein docking approach 
 CNSsolve>based on biochemical and/or biophysical information. <i>J. Am. Chem. Soc.</i> <b>125</b>, 1731-1737. 
 CNSsolve><p> 
 CNSsolve><b>When using <i>residual dipolar couplings</i> in HADDOCK cite in addition:</b><p> 
 CNSsolve><LI>A.D.J. van Dijk, D. Fushman and A.M.J.J. Bonvin (2005). Various strategies of using residual dipolar 
 CNSsolve>couplings in NMR-driven protein docking: Application to Lys48-linked di-ubiquitin and validation against 
 CNSsolve>15N-relaxation data. <EM>Proteins: Struc. Funct. & Bioinformatics</EM>, <STRONG>60</STRONG>, 367-381.</li> 
 CNSsolve><p> 
 CNSsolve><b>When using <i>diffusion anisotropy data</i> in HADDOCK cite in addition:</b><p> 
 CNSsolve><li>A.D.J. van Dijk, R. Kaptein, R. Boelens and A.M.J.J. Bonvin (2006). Combining NMR relaxation with 
 CNSsolve>chemical shift perturbation data to drive protein-protein docking. <EM>J. Biomol. NMR</EM>, 
 CNSsolve><STRONG>34</STRONG>, 237-244.</li> 
 CNSsolve><p> 
 CNSsolve><b>When using <i>solvated docking</i> in HADDOCK cite in addition:</b><p> 
 CNSsolve><li>A.D.J. van Dijk and A.M.J.J. Bonvin (2006). Solvated docking: introducing water into the modelling 
 CNSsolve>of biomolecular complexes. <EM>Bioinformatics</EM>,  <STRONG>22</STRONG> 2340-2347. 
 CNSsolve><p> 
 CNSsolve><b>When performing <i>flexible protein-DNA docking</i> using HADDOCK cite in addition:</b><p> 
 CNSsolve><li>M. van Dijk, A.D.J. van Dijk, V. Hsu, R. Boelens and  A.M.J.J. Bonvin (2006). 
 CNSsolve>Information-driven Protein-DNA Docking using HADDOCK: it is a matter of flexibility. 
 CNSsolve><EM>Nucl. Acids Res.</EM>, <STRONG>34</STRONG> 3317-3325.</li> 
 CNSsolve>+} 
 CNSsolve>{- Guidelines for using this file: 
 CNSsolve>   - all strings must be quoted by double-quotes 
 CNSsolve>   - logical variables (true/false) are not quoted 
 CNSsolve>   - do not remove any evaluate statements from the file 
 CNSsolve>   - pathnames should not exceed 80 characters -} 
 CNSsolve>{- begin block parameter definition -} define( 
 DEFINE>{======== number of molecules for docking ==================} 
 DEFINE>{* number of components *} 
 DEFINE>{===>} ncomponents=2; 
 DEFINE>{======================= filenames =========================} 
 DEFINE>{*  the name of your current project *} 
 DEFINE>{*  this will be used as name for the generated structures *} 
 DEFINE>{===>} fileroot="complex"; 
 DEFINE>{* RUN directory *} 
 DEFINE>{*  the absolute path of your current run, e.g. /home/haddock/server/run1*} 
 DEFINE>{===>} run_dir="/home/enmr/services-enmr/HADDOCK2.2/server/run/userrun000126/run1"; 
 DEFINE>{* PDB file of molecule (protein) A *} 
 DEFINE>{===>} prot_coor_A="protein1.pdb"; 
 DEFINE>{* PSF file of molecule (protein) A *} 
 DEFINE>{===>} prot_psf_A="protein1.psf"; 
 DEFINE>{* segid of molecule (protein) A *} 
 DEFINE>{===>} prot_segid_A="A"; 
 DEFINE>{* fileroot of molecule (protein) A *} 
 DEFINE>{===>} prot_root_A="protein1"; 
 DEFINE>{* Is molecule A DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_A=false; 
 DEFINE>{* PDB file of molecule (protein) B *} 
 DEFINE>{===>} prot_coor_B="protein2.pdb"; 
 DEFINE>{* PSF file of molecule (protein) B *} 
 DEFINE>{===>} prot_psf_B="protein2.psf"; 
 DEFINE>{* segid of molecule (protein) B *} 
 DEFINE>{===>} prot_segid_B="B"; 
 DEFINE>{* fileroot of molecule (protein) B *} 
 DEFINE>{===>} prot_root_B="protein2"; 
 DEFINE>{* Is molecule B DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_B=false; 
 DEFINE>{* PDB file of molecule (protein) C *} 
 DEFINE>{===>} prot_coor_C=""; 
 DEFINE>{* PSF file of molecule (protein) C *} 
 DEFINE>{===>} prot_psf_C=""; 
 DEFINE>{* segid of molecule (protein) C *} 
 DEFINE>{===>} prot_segid_C="C"; 
 DEFINE>{* fileroot of molecule (protein) C *} 
 DEFINE>{===>} prot_root_C=""; 
 DEFINE>{* Is molecule C DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_C=false; 
 DEFINE>{* PDB file of molecule (protein) D *} 
 DEFINE>{===>} prot_coor_D=""; 
 DEFINE>{* PSF file of molecule (protein) D *} 
 DEFINE>{===>} prot_psf_D=""; 
 DEFINE>{* segid of molecule (protein) D *} 
 DEFINE>{===>} prot_segid_D="D"; 
 DEFINE>{* fileroot of molecule (protein) D *} 
 DEFINE>{===>} prot_root_D=""; 
 DEFINE>{* Is molecule D DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_D=false; 
 DEFINE>{* PDB file of molecule (protein) E *} 
 DEFINE>{===>} prot_coor_E=""; 
 DEFINE>{* PSF file of molecule (protein) E *} 
 DEFINE>{===>} prot_psf_E=""; 
 DEFINE>{* segid of molecule (protein) E *} 
 DEFINE>{===>} prot_segid_E="E"; 
 DEFINE>{* fileroot of molecule (protein) E *} 
 DEFINE>{===>} prot_root_E=""; 
 DEFINE>{* Is molecule E DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_E=false; 
 DEFINE>{* PDB file of molecule (protein) F *} 
 DEFINE>{===>} prot_coor_F=""; 
 DEFINE>{* PSF file of molecule (protein) F *} 
 DEFINE>{===>} prot_psf_F=""; 
 DEFINE>{* segid of molecule (protein) F *} 
 DEFINE>{===>} prot_segid_F="F"; 
 DEFINE>{* fileroot of molecule (protein) F *} 
 DEFINE>{===>} prot_root_F=""; 
 DEFINE>{* Is molecule F DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_F=false; 
 DEFINE>{ Atomname nomenclature } 
 DEFINE>{ set true if you have IUPAC (e.g. LEU HB2 and HB3 and not HB2 and HB1) data (e.g. from XEASY) } 
 DEFINE>{ choice: true false } 
 DEFINE>xplortodiana=false; 
 DEFINE>{* Remove non-polar hydrogens? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} delenph=true; 
 DEFINE>{* HADDOCK directory *} 
 DEFINE>{*  the absolute path of the HADDOCK program files *} 
 DEFINE>{===>} haddock_dir="/home/enmr/software/haddock2.2-grid"; 
 DEFINE>{* Logfile directory *} 
 DEFINE>{* specify a directory for the large CNS log files *} 
 DEFINE>{===>} temptrash_dir="/home/enmr/services-enmr/HADDOCK2.2/server/run/userrun000126/run1"; 
 DEFINE>{==================== histidine patches =====================} 
 DEFINE>{* Patch to change doubly protonated HIS to singly protonated histidine (HD1) *} 
 DEFINE>{* just give the residue number of the histidines for the HISD patch, set them to zero if you don't want them *} 
 DEFINE>numhisd=10; 
 DEFINE>{+ table: rows=6 "molecule (Protein) A" "molecule (Protein) B"  "molecule (Protein) C"  "molecule (Protein) D"  "molecule (Protein) E"  "molecule (Protein) F" cols=10 "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" +} 
 DEFINE>{===>} A_hisd_resid_1=72; 
 DEFINE>{===>} A_hisd_resid_2=122; 
 DEFINE>{===>} A_hisd_resid_3=0; 
 DEFINE>{===>} A_hisd_resid_4=0; 
 DEFINE>{===>} A_hisd_resid_5=0; 
 DEFINE>{===>} A_hisd_resid_6=0; 
 DEFINE>{===>} A_hisd_resid_7=0; 
 DEFINE>{===>} A_hisd_resid_8=0; 
 DEFINE>{===>} A_hisd_resid_9=0; 
 DEFINE>{===>} A_hisd_resid_10=0; 
 DEFINE>{===>} B_hisd_resid_1=0; 
 DEFINE>{===>} B_hisd_resid_2=0; 
 DEFINE>{===>} B_hisd_resid_3=0; 
 DEFINE>{===>} B_hisd_resid_4=0; 
 DEFINE>{===>} B_hisd_resid_5=0; 
 DEFINE>{===>} B_hisd_resid_6=0; 
 DEFINE>{===>} B_hisd_resid_7=0; 
 DEFINE>{===>} B_hisd_resid_8=0; 
 DEFINE>{===>} B_hisd_resid_9=0; 
 DEFINE>{===>} B_hisd_resid_10=0; 
 DEFINE>{===>} C_hisd_resid_1=0; 
 DEFINE>{===>} C_hisd_resid_2=0; 
 DEFINE>{===>} C_hisd_resid_3=0; 
 DEFINE>{===>} C_hisd_resid_4=0; 
 DEFINE>{===>} C_hisd_resid_5=0; 
 DEFINE>{===>} C_hisd_resid_6=0; 
 DEFINE>{===>} C_hisd_resid_7=0; 
 DEFINE>{===>} C_hisd_resid_8=0; 
 DEFINE>{===>} C_hisd_resid_9=0; 
 DEFINE>{===>} C_hisd_resid_10=0; 
 DEFINE>{===>} D_hisd_resid_1=0; 
 DEFINE>{===>} D_hisd_resid_2=0; 
 DEFINE>{===>} D_hisd_resid_3=0; 
 DEFINE>{===>} D_hisd_resid_4=0; 
 DEFINE>{===>} D_hisd_resid_5=0; 
 DEFINE>{===>} D_hisd_resid_6=0; 
 DEFINE>{===>} D_hisd_resid_7=0; 
 DEFINE>{===>} D_hisd_resid_8=0; 
 DEFINE>{===>} D_hisd_resid_9=0; 
 DEFINE>{===>} D_hisd_resid_10=0; 
 DEFINE>{===>} E_hisd_resid_1=0; 
 DEFINE>{===>} E_hisd_resid_2=0; 
 DEFINE>{===>} E_hisd_resid_3=0; 
 DEFINE>{===>} E_hisd_resid_4=0; 
 DEFINE>{===>} E_hisd_resid_5=0; 
 DEFINE>{===>} E_hisd_resid_6=0; 
 DEFINE>{===>} E_hisd_resid_7=0; 
 DEFINE>{===>} E_hisd_resid_8=0; 
 DEFINE>{===>} E_hisd_resid_9=0; 
 DEFINE>{===>} E_hisd_resid_10=0; 
 DEFINE>{===>} F_hisd_resid_1=0; 
 DEFINE>{===>} F_hisd_resid_2=0; 
 DEFINE>{===>} F_hisd_resid_3=0; 
 DEFINE>{===>} F_hisd_resid_4=0; 
 DEFINE>{===>} F_hisd_resid_5=0; 
 DEFINE>{===>} F_hisd_resid_6=0; 
 DEFINE>{===>} F_hisd_resid_7=0; 
 DEFINE>{===>} F_hisd_resid_8=0; 
 DEFINE>{===>} F_hisd_resid_9=0; 
 DEFINE>{===>} F_hisd_resid_10=0; 
 DEFINE>{* Patch to change doubly protonated HIS to singly protonated histidine (HE2) *} 
 DEFINE>{* just give the residue number of the histidines for the HISE patch, set them to zero if you don't want them *} 
 DEFINE>numhise=10; 
 DEFINE>{+ table: rows=6 "molecule (Protein) A" "molecule (Protein) B"  "molecule (Protein) C"  "molecule (Protein) D"  "molecule (Protein) E"  "molecule (Protein) F" cols=10 "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" +} 
 DEFINE>{===>} A_hise_resid_1=162; 
 DEFINE>{===>} A_hise_resid_2=269; 
 DEFINE>{===>} A_hise_resid_3=296; 
 DEFINE>{===>} A_hise_resid_4=120; 
 DEFINE>{===>} A_hise_resid_5=284; 
 DEFINE>{===>} A_hise_resid_6=61; 
 DEFINE>{===>} A_hise_resid_7=126; 
 DEFINE>{===>} A_hise_resid_8=0; 
 DEFINE>{===>} A_hise_resid_9=0; 
 DEFINE>{===>} A_hise_resid_10=0; 
 DEFINE>{===>} B_hise_resid_1=0; 
 DEFINE>{===>} B_hise_resid_2=0; 
 DEFINE>{===>} B_hise_resid_3=0; 
 DEFINE>{===>} B_hise_resid_4=0; 
 DEFINE>{===>} B_hise_resid_5=0; 
 DEFINE>{===>} B_hise_resid_6=0; 
 DEFINE>{===>} B_hise_resid_7=0; 
 DEFINE>{===>} B_hise_resid_8=0; 
 DEFINE>{===>} B_hise_resid_9=0; 
 DEFINE>{===>} B_hise_resid_10=0; 
 DEFINE>{===>} C_hise_resid_1=0; 
 DEFINE>{===>} C_hise_resid_2=0; 
 DEFINE>{===>} C_hise_resid_3=0; 
 DEFINE>{===>} C_hise_resid_4=0; 
 DEFINE>{===>} C_hise_resid_5=0; 
 DEFINE>{===>} C_hise_resid_6=0; 
 DEFINE>{===>} C_hise_resid_7=0; 
 DEFINE>{===>} C_hise_resid_8=0; 
 DEFINE>{===>} C_hise_resid_9=0; 
 DEFINE>{===>} C_hise_resid_10=0; 
 DEFINE>{===>} D_hise_resid_1=0; 
 DEFINE>{===>} D_hise_resid_2=0; 
 DEFINE>{===>} D_hise_resid_3=0; 
 DEFINE>{===>} D_hise_resid_4=0; 
 DEFINE>{===>} D_hise_resid_5=0; 
 DEFINE>{===>} D_hise_resid_6=0; 
 DEFINE>{===>} D_hise_resid_7=0; 
 DEFINE>{===>} D_hise_resid_8=0; 
 DEFINE>{===>} D_hise_resid_9=0; 
 DEFINE>{===>} D_hise_resid_10=0; 
 DEFINE>{===>} E_hise_resid_1=0; 
 DEFINE>{===>} E_hise_resid_2=0; 
 DEFINE>{===>} E_hise_resid_3=0; 
 DEFINE>{===>} E_hise_resid_4=0; 
 DEFINE>{===>} E_hise_resid_5=0; 
 DEFINE>{===>} E_hise_resid_6=0; 
 DEFINE>{===>} E_hise_resid_7=0; 
 DEFINE>{===>} E_hise_resid_8=0; 
 DEFINE>{===>} E_hise_resid_9=0; 
 DEFINE>{===>} E_hise_resid_10=0; 
 DEFINE>{===>} F_hise_resid_1=0; 
 DEFINE>{===>} F_hise_resid_2=0; 
 DEFINE>{===>} F_hise_resid_3=0; 
 DEFINE>{===>} F_hise_resid_4=0; 
 DEFINE>{===>} F_hise_resid_5=0; 
 DEFINE>{===>} F_hise_resid_6=0; 
 DEFINE>{===>} F_hise_resid_7=0; 
 DEFINE>{===>} F_hise_resid_8=0; 
 DEFINE>{===>} F_hise_resid_9=0; 
 DEFINE>{===>} F_hise_resid_10=0; 
 DEFINE>{========= Definition of semi-flexible interface ============} 
 DEFINE>{* Define the interface of each molecule.*} 
 DEFINE>{* Side-chains and backbone of these residues will be allowed to move during semi-flexible refinement*} 
 DEFINE>{* number of semi-flexible segments for molecule (protein) A (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_A=-1; 
 DEFINE>{* Residues of molecule (protein) A at interface *} 
 DEFINE>{+ table: rows=10 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" "segment 6" "segment 7" "segment 8" "segment 9" "segment 10" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} A_start_seg_1=""; 
 DEFINE>{===>} A_end_seg_1=""; 
 DEFINE>{===>} A_start_seg_2=""; 
 DEFINE>{===>} A_end_seg_2=""; 
 DEFINE>{===>} A_start_seg_3=""; 
 DEFINE>{===>} A_end_seg_3=""; 
 DEFINE>{===>} A_start_seg_4=""; 
 DEFINE>{===>} A_end_seg_4=""; 
 DEFINE>{===>} A_start_seg_5=""; 
 DEFINE>{===>} A_end_seg_5=""; 
 DEFINE>{===>} A_start_seg_6=""; 
 DEFINE>{===>} A_end_seg_6=""; 
 DEFINE>{===>} A_start_seg_7=""; 
 DEFINE>{===>} A_end_seg_7=""; 
 DEFINE>{===>} A_start_seg_8=""; 
 DEFINE>{===>} A_end_seg_8=""; 
 DEFINE>{===>} A_start_seg_9=""; 
 DEFINE>{===>} A_end_seg_9=""; 
 DEFINE>{===>} A_start_seg_10=""; 
 DEFINE>{===>} A_end_seg_10=""; 
 DEFINE>{* number of semi-flexible segments for molecule (protein) B (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_B=-1; 
 DEFINE>{* Residues of molecule (protein) B at interface *} 
 DEFINE>{+ table: rows=10 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" "segment 6" "segment 7" "segment 8" "segment 9" "segment 10" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} B_start_seg_1=""; 
 DEFINE>{===>} B_end_seg_1=""; 
 DEFINE>{===>} B_start_seg_2=""; 
 DEFINE>{===>} B_end_seg_2=""; 
 DEFINE>{===>} B_start_seg_3=""; 
 DEFINE>{===>} B_end_seg_3=""; 
 DEFINE>{===>} B_start_seg_4=""; 
 DEFINE>{===>} B_end_seg_4=""; 
 DEFINE>{===>} B_start_seg_5=""; 
 DEFINE>{===>} B_end_seg_5=""; 
 DEFINE>{===>} B_start_seg_6=""; 
 DEFINE>{===>} B_end_seg_6=""; 
 DEFINE>{===>} B_start_seg_7=""; 
 DEFINE>{===>} B_end_seg_7=""; 
 DEFINE>{===>} B_start_seg_8=""; 
 DEFINE>{===>} B_end_seg_8=""; 
 DEFINE>{===>} B_start_seg_9=""; 
 DEFINE>{===>} B_end_seg_9=""; 
 DEFINE>{===>} B_start_seg_10=""; 
 DEFINE>{===>} B_end_seg_10=""; 
 DEFINE>{* number of semi-flexible segments for molecule (protein) C (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_C=-1; 
 DEFINE>{* Residues of molecule (protein) C at interface *} 
 DEFINE>{+ table: rows=10 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" "segment 6" "segment 7" "segment 8" "segment 9" "segment 10" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} C_start_seg_1=""; 
 DEFINE>{===>} C_end_seg_1=""; 
 DEFINE>{===>} C_start_seg_2=""; 
 DEFINE>{===>} C_end_seg_2=""; 
 DEFINE>{===>} C_start_seg_3=""; 
 DEFINE>{===>} C_end_seg_3=""; 
 DEFINE>{===>} C_start_seg_4=""; 
 DEFINE>{===>} C_end_seg_4=""; 
 DEFINE>{===>} C_start_seg_5=""; 
 DEFINE>{===>} C_end_seg_5=""; 
 DEFINE>{===>} C_start_seg_6=""; 
 DEFINE>{===>} C_end_seg_6=""; 
 DEFINE>{===>} C_start_seg_7=""; 
 DEFINE>{===>} C_end_seg_7=""; 
 DEFINE>{===>} C_start_seg_8=""; 
 DEFINE>{===>} C_end_seg_8=""; 
 DEFINE>{===>} C_start_seg_9=""; 
 DEFINE>{===>} C_end_seg_9=""; 
 DEFINE>{===>} C_start_seg_10=""; 
 DEFINE>{===>} C_end_seg_10=""; 
 DEFINE>{* number of semi-flexible segments for molecule (protein) D (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_D=-1; 
 DEFINE>{* Residues of molecule (protein) D at interface *} 
 DEFINE>{+ table: rows=10 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" "segment 6" "segment 7" "segment 8" "segment 9" "segment 10" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} D_start_seg_1=""; 
 DEFINE>{===>} D_end_seg_1=""; 
 DEFINE>{===>} D_start_seg_2=""; 
 DEFINE>{===>} D_end_seg_2=""; 
 DEFINE>{===>} D_start_seg_3=""; 
 DEFINE>{===>} D_end_seg_3=""; 
 DEFINE>{===>} D_start_seg_4=""; 
 DEFINE>{===>} D_end_seg_4=""; 
 DEFINE>{===>} D_start_seg_5=""; 
 DEFINE>{===>} D_end_seg_5=""; 
 DEFINE>{===>} D_start_seg_6=""; 
 DEFINE>{===>} D_end_seg_6=""; 
 DEFINE>{===>} D_start_seg_7=""; 
 DEFINE>{===>} D_end_seg_7=""; 
 DEFINE>{===>} D_start_seg_8=""; 
 DEFINE>{===>} D_end_seg_8=""; 
 DEFINE>{===>} D_start_seg_9=""; 
 DEFINE>{===>} D_end_seg_9=""; 
 DEFINE>{===>} D_start_seg_10=""; 
 DEFINE>{===>} D_end_seg_10=""; 
 DEFINE>{* number of semi-flexible segments for molecule (protein) E (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_E=-1; 
 DEFINE>{* Residues of molecule (protein) E at interface *} 
 DEFINE>{+ table: rows=10 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" "segment 6" "segment 7" "segment 8" "segment 9" "segment 10" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} E_start_seg_1=""; 
 DEFINE>{===>} E_end_seg_1=""; 
 DEFINE>{===>} E_start_seg_2=""; 
 DEFINE>{===>} E_end_seg_2=""; 
 DEFINE>{===>} E_start_seg_3=""; 
 DEFINE>{===>} E_end_seg_3=""; 
 DEFINE>{===>} E_start_seg_4=""; 
 DEFINE>{===>} E_end_seg_4=""; 
 DEFINE>{===>} E_start_seg_5=""; 
 DEFINE>{===>} E_end_seg_5=""; 
 DEFINE>{===>} E_start_seg_6=""; 
 DEFINE>{===>} E_end_seg_6=""; 
 DEFINE>{===>} E_start_seg_7=""; 
 DEFINE>{===>} E_end_seg_7=""; 
 DEFINE>{===>} E_start_seg_8=""; 
 DEFINE>{===>} E_end_seg_8=""; 
 DEFINE>{===>} E_start_seg_9=""; 
 DEFINE>{===>} E_end_seg_9=""; 
 DEFINE>{===>} E_start_seg_10=""; 
 DEFINE>{===>} E_end_seg_10=""; 
 DEFINE>{* number of semi-flexible segments for molecule (protein) F (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_F=-1; 
 DEFINE>{* Residues of molecule (protein) F at interface *} 
 DEFINE>{+ table: rows=10 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" "segment 6" "segment 7" "segment 8" "segment 9" "segment 10" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} F_start_seg_1=""; 
 DEFINE>{===>} F_end_seg_1=""; 
 DEFINE>{===>} F_start_seg_2=""; 
 DEFINE>{===>} F_end_seg_2=""; 
 DEFINE>{===>} F_start_seg_3=""; 
 DEFINE>{===>} F_end_seg_3=""; 
 DEFINE>{===>} F_start_seg_4=""; 
 DEFINE>{===>} F_end_seg_4=""; 
 DEFINE>{===>} F_start_seg_5=""; 
 DEFINE>{===>} F_end_seg_5=""; 
 DEFINE>{===>} F_start_seg_6=""; 
 DEFINE>{===>} F_end_seg_6=""; 
 DEFINE>{===>} F_start_seg_7=""; 
 DEFINE>{===>} F_end_seg_7=""; 
 DEFINE>{===>} F_start_seg_8=""; 
 DEFINE>{===>} F_end_seg_8=""; 
 DEFINE>{===>} F_start_seg_9=""; 
 DEFINE>{===>} F_end_seg_9=""; 
 DEFINE>{===>} F_start_seg_10=""; 
 DEFINE>{===>} F_end_seg_10=""; 
 DEFINE> 
 DEFINE>{=========== Definition of fully flexible segments ==========} 
 DEFINE>{* Define the fully flexible segment of each molecule.*} 
 DEFINE>{* These segments will be allowed to move at all stages of it1 *} 
 DEFINE>{* Fully flexible segments for molecule (protein) A            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_A=0; 
 DEFINE>{* Residues of molecule (protein) A at interface *} 
 DEFINE>{+ table: rows=5 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} A_start_fle_1=""; 
 DEFINE>{===>} A_end_fle_1=""; 
 DEFINE>{===>} A_start_fle_2=""; 
 DEFINE>{===>} A_end_fle_2=""; 
 DEFINE>{===>} A_start_fle_3=""; 
 DEFINE>{===>} A_end_fle_3=""; 
 DEFINE>{===>} A_start_fle_4=""; 
 DEFINE>{===>} A_end_fle_4=""; 
 DEFINE>{===>} A_start_fle_5=""; 
 DEFINE>{===>} A_end_fle_5=""; 
 DEFINE>{* Fully flexible segments for molecule (protein) B            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_B=0; 
 DEFINE>{* Residues of molecule (protein) B at interface *} 
 DEFINE>{+ table: rows=5 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} B_start_fle_1=""; 
 DEFINE>{===>} B_end_fle_1=""; 
 DEFINE>{===>} B_start_fle_2=""; 
 DEFINE>{===>} B_end_fle_2=""; 
 DEFINE>{===>} B_start_fle_3=""; 
 DEFINE>{===>} B_end_fle_3=""; 
 DEFINE>{===>} B_start_fle_4=""; 
 DEFINE>{===>} B_end_fle_4=""; 
 DEFINE>{===>} B_start_fle_5=""; 
 DEFINE>{===>} B_end_fle_5=""; 
 DEFINE>{* Fully flexible segments for molecule (protein) C            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_C=0; 
 DEFINE>{* Residues of molecule (protein) C at interface *} 
 DEFINE>{+ table: rows=5 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} C_start_fle_1=""; 
 DEFINE>{===>} C_end_fle_1=""; 
 DEFINE>{===>} C_start_fle_2=""; 
 DEFINE>{===>} C_end_fle_2=""; 
 DEFINE>{===>} C_start_fle_3=""; 
 DEFINE>{===>} C_end_fle_3=""; 
 DEFINE>{===>} C_start_fle_4=""; 
 DEFINE>{===>} C_end_fle_4=""; 
 DEFINE>{===>} C_start_fle_5=""; 
 DEFINE>{===>} C_end_fle_5=""; 
 DEFINE>{* Fully flexible segments for molecule (protein) D            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_D=0; 
 DEFINE>{* Residues of molecule (protein) D at interface *} 
 DEFINE>{+ table: rows=5 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} D_start_fle_1=""; 
 DEFINE>{===>} D_end_fle_1=""; 
 DEFINE>{===>} D_start_fle_2=""; 
 DEFINE>{===>} D_end_fle_2=""; 
 DEFINE>{===>} D_start_fle_3=""; 
 DEFINE>{===>} D_end_fle_3=""; 
 DEFINE>{===>} D_start_fle_4=""; 
 DEFINE>{===>} D_end_fle_4=""; 
 DEFINE>{===>} D_start_fle_5=""; 
 DEFINE>{===>} D_end_fle_5=""; 
 DEFINE>{* Fully flexible segments for molecule (protein) E            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_E=0; 
 DEFINE>{* Residues of molecule (protein) E at interface *} 
 DEFINE>{+ table: rows=5 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} E_start_fle_1=""; 
 DEFINE>{===>} E_end_fle_1=""; 
 DEFINE>{===>} E_start_fle_2=""; 
 DEFINE>{===>} E_end_fle_2=""; 
 DEFINE>{===>} E_start_fle_3=""; 
 DEFINE>{===>} E_end_fle_3=""; 
 DEFINE>{===>} E_start_fle_4=""; 
 DEFINE>{===>} E_end_fle_4=""; 
 DEFINE>{===>} E_start_fle_5=""; 
 DEFINE>{===>} E_end_fle_5=""; 
 DEFINE>{* Fully flexible segments for molecule (protein) F            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_F=0; 
 DEFINE>{* Residues of molecule (protein) F at interface *} 
 DEFINE>{+ table: rows=5 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} F_start_fle_1=""; 
 DEFINE>{===>} F_end_fle_1=""; 
 DEFINE>{===>} F_start_fle_2=""; 
 DEFINE>{===>} F_end_fle_2=""; 
 DEFINE>{===>} F_start_fle_3=""; 
 DEFINE>{===>} F_end_fle_3=""; 
 DEFINE>{===>} F_start_fle_4=""; 
 DEFINE>{===>} F_end_fle_4=""; 
 DEFINE>{===>} F_start_fle_5=""; 
 DEFINE>{===>} F_end_fle_5=""; 
 DEFINE> 
 DEFINE>{====================== NCS restraints  =====================} 
 DEFINE>{* Do you want to use NCS restraints? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} ncs_on=false; 
 DEFINE>{* Force constant for NCS restraints *} 
 DEFINE>{===>} kncs=1.0; 
 DEFINE>{* Number of NCS pairs *} 
 DEFINE>{===>} numncs=0; 
 DEFINE>{* Define the segments pairs for NCS restraints *} 
 DEFINE>{+ table: rows=5 "pair 1" "pair 2" "pair 3" "pair 4" "pair 5" cols=6 "Start res seg1" "End res seg1" "Segid seg1" "Start res seg2" "End res seg2" "Segid seg2" +} 
 DEFINE>{===>} ncs_sta1_1=""; 
 DEFINE>{===>} ncs_end1_1=""; 
 DEFINE>{===>} ncs_seg1_1=""; 
 DEFINE>{===>} ncs_sta2_1=""; 
 DEFINE>{===>} ncs_end2_1=""; 
 DEFINE>{===>} ncs_seg2_1=""; 
 DEFINE>{===>} ncs_sta1_2=""; 
 DEFINE>{===>} ncs_end1_2=""; 
 DEFINE>{===>} ncs_seg1_2=""; 
 DEFINE>{===>} ncs_sta2_2=""; 
 DEFINE>{===>} ncs_end2_2=""; 
 DEFINE>{===>} ncs_seg2_2=""; 
 DEFINE>{===>} ncs_sta1_3=""; 
 DEFINE>{===>} ncs_end1_3=""; 
 DEFINE>{===>} ncs_seg1_3=""; 
 DEFINE>{===>} ncs_sta2_3=""; 
 DEFINE>{===>} ncs_end2_3=""; 
 DEFINE>{===>} ncs_seg2_3=""; 
 DEFINE>{===>} ncs_sta1_4=""; 
 DEFINE>{===>} ncs_end1_4=""; 
 DEFINE>{===>} ncs_seg1_4=""; 
 DEFINE>{===>} ncs_sta2_4=""; 
 DEFINE>{===>} ncs_end2_4=""; 
 DEFINE>{===>} ncs_seg2_4=""; 
 DEFINE>{===>} ncs_sta1_5=""; 
 DEFINE>{===>} ncs_end1_5=""; 
 DEFINE>{===>} ncs_seg1_5=""; 
 DEFINE>{===>} ncs_sta2_5=""; 
 DEFINE>{===>} ncs_end2_5=""; 
 DEFINE>{===>} ncs_seg2_5=""; 
 DEFINE>{==================== Symmetry restraints  ==================} 
 DEFINE>{* Do you want to use symmetry restraints ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} sym_on=false; 
 DEFINE>{* Force constant for symmetry restraints ? *} 
 DEFINE>{===>} ksym=10.0; 
 DEFINE>{* Number of C2 symmetry pairs *} 
 DEFINE>{===>} numc2sym=0; 
 DEFINE>{* Define the segment pairs for C2 symmetry restraints *} 
 DEFINE>{+ table: rows=10 "pair 1" "pair 2" "pair 3" "pair 4" "pair 5" "pair 6" "pair 7" "pair 8" "pair 9" "pair 10" cols=6 "Start res seg1" "End res seg1" "Segid seg1" "Start res seg2" "End res seg2" "Segid seg2" +} 
 DEFINE>{===>} c2sym_sta1_1=""; 
 DEFINE>{===>} c2sym_end1_1=""; 
 DEFINE>{===>} c2sym_seg1_1=""; 
 DEFINE>  {===>} c2sym_sta2_1=""; 
 DEFINE>{===>} c2sym_end2_1=""; 
 DEFINE>{===>} c2sym_seg2_1=""; 
 DEFINE>  {===>} c2sym_sta1_2=""; 
 DEFINE>{===>} c2sym_end1_2=""; 
 DEFINE>{===>} c2sym_seg1_2=""; 
 DEFINE>  {===>} c2sym_sta2_2=""; 
 DEFINE>{===>} c2sym_end2_2=""; 
 DEFINE>{===>} c2sym_seg2_2=""; 
 DEFINE>  {===>} c2sym_sta1_3=""; 
 DEFINE>{===>} c2sym_end1_3=""; 
 DEFINE>{===>} c2sym_seg1_3=""; 
 DEFINE>  {===>} c2sym_sta2_3=""; 
 DEFINE>{===>} c2sym_end2_3=""; 
 DEFINE>{===>} c2sym_seg2_3=""; 
 DEFINE>  {===>} c2sym_sta1_4=""; 
 DEFINE>{===>} c2sym_end1_4=""; 
 DEFINE>{===>} c2sym_seg1_4=""; 
 DEFINE>  {===>} c2sym_sta2_4=""; 
 DEFINE>{===>} c2sym_end2_4=""; 
 DEFINE>{===>} c2sym_seg2_4=""; 
 DEFINE>  {===>} c2sym_sta1_5=""; 
 DEFINE>{===>} c2sym_end1_5=""; 
 DEFINE>{===>} c2sym_seg1_5=""; 
 DEFINE>  {===>} c2sym_sta2_5=""; 
 DEFINE>{===>} c2sym_end2_5=""; 
 DEFINE>{===>} c2sym_seg2_5=""; 
 DEFINE>  {===>} c2sym_sta1_6=""; 
 DEFINE>{===>} c2sym_end1_6=""; 
 DEFINE>{===>} c2sym_seg1_6=""; 
 DEFINE>  {===>} c2sym_sta2_6=""; 
 DEFINE>{===>} c2sym_end2_6=""; 
 DEFINE>{===>} c2sym_seg2_6=""; 
 DEFINE>  {===>} c2sym_sta1_7=""; 
 DEFINE>{===>} c2sym_end1_7=""; 
 DEFINE>{===>} c2sym_seg1_7=""; 
 DEFINE>  {===>} c2sym_sta2_7=""; 
 DEFINE>{===>} c2sym_end2_7=""; 
 DEFINE>{===>} c2sym_seg2_7=""; 
 DEFINE>  {===>} c2sym_sta1_8=""; 
 DEFINE>{===>} c2sym_end1_8=""; 
 DEFINE>{===>} c2sym_seg1_8=""; 
 DEFINE>  {===>} c2sym_sta2_8=""; 
 DEFINE>{===>} c2sym_end2_8=""; 
 DEFINE>{===>} c2sym_seg2_8=""; 
 DEFINE>  {===>} c2sym_sta1_9=""; 
 DEFINE>{===>} c2sym_end1_9=""; 
 DEFINE>{===>} c2sym_seg1_9=""; 
 DEFINE>  {===>} c2sym_sta2_9=""; 
 DEFINE>{===>} c2sym_end2_9=""; 
 DEFINE>{===>} c2sym_seg2_9=""; 
 DEFINE>  {===>} c2sym_sta1_10=""; 
 DEFINE>{===>} c2sym_end1_10=""; 
 DEFINE>{===>} c2sym_seg1_10=""; 
 DEFINE>  {===>} c2sym_sta2_10=""; 
 DEFINE>{===>} c2sym_end2_10=""; 
 DEFINE>{===>} c2sym_seg2_10=""; 
 DEFINE> 
 DEFINE>{* Number of C3 symmetry triples *} 
 DEFINE>{===>} numc3sym=0; 
 DEFINE>{* Define the segment triples for C3 symmetry restraints *} 
 DEFINE>{+ table: rows=2 "triple 1" "triple 2" cols=9 "Start res seg1" "End res seg1" "Segid seg1" "Start res seg2" "End res seg2" "Segid seg2" "Start res seg3" "End res seg3" "Segid seg3" +} 
 DEFINE>{===>} c3sym_sta1_1=""; 
 DEFINE>{===>} c3sym_end1_1=""; 
 DEFINE>{===>} c3sym_seg1_1=""; 
 DEFINE>  {===>} c3sym_sta2_1=""; 
 DEFINE>{===>} c3sym_end2_1=""; 
 DEFINE>{===>} c3sym_seg2_1=""; 
 DEFINE>  {===>} c3sym_sta3_1=""; 
 DEFINE>{===>} c3sym_end3_1=""; 
 DEFINE>{===>} c3sym_seg3_1=""; 
 DEFINE>  {===>} c3sym_sta1_2=""; 
 DEFINE>{===>} c3sym_end1_2=""; 
 DEFINE>{===>} c3sym_seg1_2=""; 
 DEFINE>  {===>} c3sym_sta2_2=""; 
 DEFINE>{===>} c3sym_end2_2=""; 
 DEFINE>{===>} c3sym_seg2_2=""; 
 DEFINE>  {===>} c3sym_sta3_2=""; 
 DEFINE>{===>} c3sym_end3_2=""; 
 DEFINE>{===>} c3sym_seg3_2=""; 
 DEFINE> 
 DEFINE>{* Number of S3 symmetry triples *} 
 DEFINE>{===>} nums3sym=0; 
 DEFINE>{* Define the segment triples for S3 symmetry restraints *} 
 DEFINE>{+ table: rows=4 "triple 1" "triple 2" "triple 3" "triple 4" cols=9 "Start res seg1" "End res seg1" "Segid seg1" "Start res seg2" "End res seg2" "Segid seg2" "Start res seg3" "End res seg3" "Segid seg3" +} 
 DEFINE>{===>} s3sym_sta1_1=""; 
 DEFINE>{===>} s3sym_end1_1=""; 
 DEFINE>{===>} s3sym_seg1_1=""; 
 DEFINE>  {===>} s3sym_sta2_1=""; 
 DEFINE>{===>} s3sym_end2_1=""; 
 DEFINE>{===>} s3sym_seg2_1=""; 
 DEFINE>  {===>} s3sym_sta3_1=""; 
 DEFINE>{===>} s3sym_end3_1=""; 
 DEFINE>{===>} s3sym_seg3_1=""; 
 DEFINE>  {===>} s3sym_sta1_2=""; 
 DEFINE>{===>} s3sym_end1_2=""; 
 DEFINE>{===>} s3sym_seg1_2=""; 
 DEFINE>  {===>} s3sym_sta2_2=""; 
 DEFINE>{===>} s3sym_end2_2=""; 
 DEFINE>{===>} s3sym_seg2_2=""; 
 DEFINE>  {===>} s3sym_sta3_2=""; 
 DEFINE>{===>} s3sym_end3_2=""; 
 DEFINE>{===>} s3sym_seg3_2=""; 
 DEFINE>  {===>} s3sym_sta1_3=""; 
 DEFINE>{===>} s3sym_end1_3=""; 
 DEFINE>{===>} s3sym_seg1_3=""; 
 DEFINE>  {===>} s3sym_sta2_3=""; 
 DEFINE>{===>} s3sym_end2_3=""; 
 DEFINE>{===>} s3sym_seg2_3=""; 
 DEFINE>  {===>} s3sym_sta3_3=""; 
 DEFINE>{===>} s3sym_end3_3=""; 
 DEFINE>{===>} s3sym_seg3_3=""; 
 DEFINE>  {===>} s3sym_sta1_4=""; 
 DEFINE>{===>} s3sym_end1_4=""; 
 DEFINE>{===>} s3sym_seg1_4=""; 
 DEFINE>  {===>} s3sym_sta2_4=""; 
 DEFINE>{===>} s3sym_end2_4=""; 
 DEFINE>{===>} s3sym_seg2_4=""; 
 DEFINE>  {===>} s3sym_sta3_4=""; 
 DEFINE>{===>} s3sym_end3_4=""; 
 DEFINE>{===>} s3sym_seg3_4=""; 
 DEFINE> 
 DEFINE>{* Number of C4 symmetry quadruples *} 
 DEFINE>{===>} numc4sym=0; 
 DEFINE>{* Define the segment quadruples for C4 symmetry restraints *} 
 DEFINE>{+ table: rows=2 "quadruple 1" "quadruple 2" cols=12 "Start res seg1" "End res seg1" "Segid seg1" "Start res seg2" "End res seg2" "Segid seg2" "Start res seg3" "End res seg3" "Segid seg3" "Start res seg4" "End res seg4" "Segid seg4" +} 
 DEFINE>{===>} c4sym_sta1_1=""; 
 DEFINE>{===>} c4sym_end1_1=""; 
 DEFINE>{===>} c4sym_seg1_1=""; 
 DEFINE>  {===>} c4sym_sta2_1=""; 
 DEFINE>{===>} c4sym_end2_1=""; 
 DEFINE>{===>} c4sym_seg2_1=""; 
 DEFINE>  {===>} c4sym_sta3_1=""; 
 DEFINE>{===>} c4sym_end3_1=""; 
 DEFINE>{===>} c4sym_seg3_1=""; 
 DEFINE>  {===>} c4sym_sta4_1=""; 
 DEFINE>{===>} c4sym_end4_1=""; 
 DEFINE>{===>} c4sym_seg4_1=""; 
 DEFINE>  {===>} c4sym_sta1_2=""; 
 DEFINE>{===>} c4sym_end1_2=""; 
 DEFINE>{===>} c4sym_seg1_2=""; 
 DEFINE>  {===>} c4sym_sta2_2=""; 
 DEFINE>{===>} c4sym_end2_2=""; 
 DEFINE>{===>} c4sym_seg2_2=""; 
 DEFINE>  {===>} c4sym_sta3_2=""; 
 DEFINE>{===>} c4sym_end3_2=""; 
 DEFINE>{===>} c4sym_seg3_2=""; 
 DEFINE>  {===>} c4sym_sta4_2=""; 
 DEFINE>{===>} c4sym_end4_2=""; 
 DEFINE>{===>} c4sym_seg4_2=""; 
 DEFINE> 
 DEFINE>{* Number of C5 symmetry *} 
 DEFINE>{===>} numc5sym=0; 
 DEFINE>{* Define the segments for C5 symmetry restraints *} 
 DEFINE>{+ table: rows=5 "Segment1" "Segment2" "Segment3" "Segment4" "Segment5" cols=3 "Start residue" "End residue" "Segid" +} 
 DEFINE>{===>} c5sym_sta1_1=""; 
 DEFINE>{===>} c5sym_end1_1=""; 
 DEFINE>{===>} c5sym_seg1_1=""; 
 DEFINE>  {===>} c5sym_sta2_1=""; 
 DEFINE>{===>} c5sym_end2_1=""; 
 DEFINE>{===>} c5sym_seg2_1=""; 
 DEFINE>  {===>} c5sym_sta3_1=""; 
 DEFINE>{===>} c5sym_end3_1=""; 
 DEFINE>{===>} c5sym_seg3_1=""; 
 DEFINE>  {===>} c5sym_sta4_1=""; 
 DEFINE>{===>} c5sym_end4_1=""; 
 DEFINE>{===>} c5sym_seg4_1=""; 
 DEFINE>  {===>} c5sym_sta5_1=""; 
 DEFINE>{===>} c5sym_end5_1=""; 
 DEFINE>{===>} c5sym_seg5_1=""; 
 DEFINE> 
 DEFINE>{=========================== Distance restraints  ========================} 
 DEFINE>{* Turn on/off and energy constants for distance restraints *} 
 DEFINE>{+ table: rows=3 "distances" "AIR (ambig)" "hbonds" cols=6 "firstIteration" "lastIteration" "hot" "cool1" "cool2" "cool3"+} 
 DEFINE>{===>} unamb_firstit=0; 
 DEFINE>{===>} unamb_lastit=2; 
 DEFINE>{===>} unamb_hot=10; 
 DEFINE>{===>} unamb_cool1=10; 
 DEFINE>{===>} unamb_cool2=50; 
 DEFINE>{===>} unamb_cool3=50; 
 DEFINE>{===>} amb_firstit=0; 
 DEFINE>{===>} amb_lastit=2; 
 DEFINE>{===>} amb_hot=10; 
 DEFINE>{===>} amb_cool1=10; 
 DEFINE>{===>} amb_cool2=50; 
 DEFINE>{===>} amb_cool3=50; 
 DEFINE>{===>} hbond_firstit=1; 
 DEFINE>{===>} hbond_lastit=2; 
 DEFINE>{===>} hbond_hot=10; 
 DEFINE>{===>} hbond_cool1=10; 
 DEFINE>{===>} hbond_cool2=50; 
 DEFINE>{===>} hbond_cool3=50; 
 DEFINE>{* Do you want to randomly exclude a fraction of the ambiguous restraints (AIRs)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} noecv=true; 
 DEFINE>{* Number of partitions for random exclusion (%excluded=100/number of partitions)? *} 
 DEFINE>{===>} ncvpart=2.0; 
 DEFINE>{* Do you want to use hydrogen bond restraints? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} hbonds_on=false; 
 DEFINE>{* Do you want to define randomly ambiguous interaction restraints from accessible residues? *} 
 DEFINE>{* Only residues in the defined flexible segments will be considered *} 
 DEFINE>{* Note that this option is exclusive with any other distance restraints and only for it0    *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} ranair=false; 
 DEFINE>{* Do you want to define center of mass restraints to enforce contact between the molecules? *} 
 DEFINE>{* Note that these are only active during it0 and it1 *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cmrest=true; 
 DEFINE>{* Force constant for center of mass restraints *} 
 DEFINE>{===>} kcont=1.0; 
 DEFINE>{* Do you want to define surface contact restraints to enforce contact between the molecules? *} 
 DEFINE>{* Note that these are only active during it0 and it1 *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} surfrest=true; 
 DEFINE>{* Force constant for surface contact restraints *} 
 DEFINE>{===>} ksurf=1.0; 
 DEFINE>{* Do you want to define a radius of gyration restraint (e.g. from SAXS)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rgrest=false; 
 DEFINE>{* Radius of gyration *} 
 DEFINE>{===>} rgtarg=17.78; 
 DEFINE>{* Force constant for radius of gyration restraint *} 
 DEFINE>{===>} krg_hot=100; 
 DEFINE>{===>} krg_cool1=100; 
 DEFINE>{===>} krg_cool2=100; 
 DEFINE>{===>} krg_cool3=100; 
 DEFINE>{* Atom selections for the radius of gyration restraint *} 
 DEFINE>{===>} rgsele="all"; 
 DEFINE>{ Use automated distance restraints weighting } 
 DEFINE>{ choice: true false } 
 DEFINE>air_scaling=false; 
 DEFINE>{ Define the number of distance restraints for automated weighting } 
 DEFINE>tot_unamb=25; 
 DEFINE>{ Define the number of AIR restraints for automated weighting } 
 DEFINE>tot_amb=0; 
 DEFINE>{ potential shape } 
 DEFINE>mrswi_hot=0.5; 
 DEFINE>mrswi_cool1=0.5; 
 DEFINE>mrswi_cool2=0.5; 
 DEFINE>mrswi_cool3=0.5; 
 DEFINE>rswi_hot=0.5; 
 DEFINE>rswi_cool1=0.5; 
 DEFINE>rswi_cool2=0.5; 
 DEFINE>rswi_cool3=0.5; 
 DEFINE>masy_hot=-1.0; 
 DEFINE>masy_cool1=-1.0; 
 DEFINE>masy_cool2=-0.1; 
 DEFINE>masy_cool3=-0.1; 
 DEFINE>asy_hot=1.0; 
 DEFINE>asy_cool1=1.0; 
 DEFINE>asy_cool2=0.1; 
 DEFINE>asy_cool3=0.1; 
 DEFINE>{======================DNA-RNA restraints ============================} 
 DEFINE>{* Use DNA/RNA restraints (dna-rna_restraints.def in data/sequence)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dnarest_on=false; 
 DEFINE>{=========================== dihedrals restraints ====================} 
 DEFINE>{* energy constants *} 
 DEFINE>{+ table: rows=1 "dihedrals" cols=5 "use?" "hot" "cool1" "cool2" "cool3" +} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dihedrals_on=false; 
 DEFINE>{===>} dihedrals_hot=5; 
 DEFINE>{===>} dihedrals_cool1=5; 
 DEFINE>{===>} dihedrals_cool2=50; 
 DEFINE>{===>} dihedrals_cool3=200; 
 DEFINE>{* Automatically define backbone dihedral angle restraints from structure? *} 
 DEFINE>{+ choice: none all alpha alphabeta +} 
 DEFINE>{===>} ssdihed=none; 
 DEFINE>{=========================== Karplus coupling restraints ====================} 
 DEFINE>{* Karplus coefficients: edit manually the run.cns file to specify them if needed   *} 
 DEFINE>{* The jcoupling restraint files should be present in the data/jcouplings directory *} 
 DEFINE>{* and named c1.tbl, c2.tbl, ... *} 
 DEFINE> c1_on=false; 
 DEFINE> c1_karplusa=6.98; 
 DEFINE> c1_karplusb=-1.38; 
 DEFINE> c1_karplusc=1.72; 
 DEFINE> c1_karplusd=-60.0; 
 DEFINE> c1_hot=0.0; 
 DEFINE> c1_cool1=0.2; 
 DEFINE> c1_cool2=1.0; 
 DEFINE> c1_cool3=1.0; 
 DEFINE> c2_on=false; 
 DEFINE> c2_karplusa=6.98; 
 DEFINE> c2_karplusb=-1.38; 
 DEFINE> c2_karplusc=1.72; 
 DEFINE> c2_karplusd=-120.0; 
 DEFINE> c2_hot=0.0; 
 DEFINE> c2_cool1=0.2; 
 DEFINE> c2_cool2=1.0; 
 DEFINE> c2_cool3=1.0; 
 DEFINE> c3_on=false; 
 DEFINE> c3_karplusa=6.98; 
 DEFINE> c3_karplusb=-1.38; 
 DEFINE> c3_karplusc=1.72; 
 DEFINE> c3_karplusd=-120.0; 
 DEFINE> c3_hot=0.0; 
 DEFINE> c3_cool1=0.2; 
 DEFINE> c3_cool2=1.0; 
 DEFINE> c3_cool3=1.0; 
 DEFINE> c4_on=false; 
 DEFINE> c4_karplusa=6.98; 
 DEFINE> c4_karplusb=-1.38; 
 DEFINE> c4_karplusc=1.72; 
 DEFINE> c4_karplusd=-120.0; 
 DEFINE> c4_hot=0.0; 
 DEFINE> c4_cool1=0.2; 
 DEFINE> c4_cool2=1.0; 
 DEFINE> c4_cool3=1.0; 
 DEFINE> c5_on=false; 
 DEFINE> c5_karplusa=6.98; 
 DEFINE> c5_karplusb=-1.38; 
 DEFINE> c5_karplusc=1.72; 
 DEFINE> c5_karplusd=-120.0; 
 DEFINE> c5_hot=0.0; 
 DEFINE> c5_cool1=0.2; 
 DEFINE> c5_cool2=1.0; 
 DEFINE> c5_cool3=1.0; 
 DEFINE>{=========================== residual dipolar couplings ======================} 
 DEFINE>{* Parameters *} 
 DEFINE>{+ table: rows=5 "class1" "class2" "class3" "class4" "class5" 
 DEFINE>          cols=25 "type" "firstIt" "lastIt" "Ksani<br>(hot)" "Ksani<br>(cool1)" "Ksani<br>(cool2)" "Ksani<br>(cool3)" "R" "D" 
 DEFINE> "Kvean<br>(ini_bor_hot)" "Kvean<br>(fin_bor_hot)" 
 DEFINE> "Kvean<br>(ini_bor_cool1)" "Kvean<br>(fin_bor_cool1)" 
 DEFINE> "Kvean<br>(ini_bor_cool2)" "Kvean<br>(fin_bor_cool2)" 
 DEFINE> "Kvean<br>(ini_bor_cool3)" "Kvean<br>(fin_bor_cool3)" 
 DEFINE> "Kvean<br>(ini_cen_hot)" "Kvean<br>(fin_cen_hot)" 
 DEFINE> "Kvean<br>(ini_cen_cool1)" "Kvean<br>(fin_cen_cool1)" 
 DEFINE> "Kvean<br>(ini_cen_cool2)" "Kvean<br>(fin_cen_cool2)" 
 DEFINE> "Kvean<br>(ini_cen_cool3)" "Kvean<br>(fin_cen_cool3)"+} 
 DEFINE>{+ choice: "NO" "SANI" "XRDC" "VANGLE" +} 
 DEFINE>{===>} rdc1_choice="NO"; 
 DEFINE>{===>} rdc1_firstIt=0; 
 DEFINE>{===>} rdc1_lastIt=2; 
 DEFINE>{===>} rdc1_hot=0.1; 
 DEFINE>{===>} rdc1_cool1=1.0; 
 DEFINE>{===>} rdc1_cool2=1.0; 
 DEFINE>{===>} rdc1_cool3=1.0; 
 DEFINE>{===>} rdc1_r=0.4; 
 DEFINE>{===>} rdc1_d=8.0; 
 DEFINE>{===>} ini_bor_hot_1=1.0; 
 DEFINE>{===>} fin_bor_hot_1=10.0; 
 DEFINE>{===>} ini_bor_cool1_1=10.0; 
 DEFINE>{===>} fin_bor_cool1_1=40.0; 
 DEFINE>{===>} ini_bor_cool2_1=40.0; 
 DEFINE>{===>} fin_bor_cool2_1=40.0; 
 DEFINE>{===>} ini_bor_cool3_1=40.0; 
 DEFINE>{===>} fin_bor_cool3_1=40.0; 
 DEFINE>{===>} ini_cen_hot_1=0.25; 
 DEFINE>{===>} fin_cen_hot_1=2.5; 
 DEFINE>{===>} ini_cen_cool1_1=2.5; 
 DEFINE>{===>} fin_cen_cool1_1=10.0; 
 DEFINE>{===>} ini_cen_cool2_1=10.0; 
 DEFINE>{===>} fin_cen_cool2_1=10.0; 
 DEFINE>{===>} ini_cen_cool3_1=10.0; 
 DEFINE>{===>} fin_cen_cool3_1=10.0; 
 DEFINE>{+ choice: "NO" "SANI" "XRDC" "VANGLE" +} 
 DEFINE>{===>} rdc2_choice="NO"; 
 DEFINE>{===>} rdc2_firstIt=0; 
 DEFINE>{===>} rdc2_lastIt=2; 
 DEFINE>{===>} rdc2_hot=0.1; 
 DEFINE>{===>} rdc2_cool1=1.0; 
 DEFINE>{===>} rdc2_cool2=1.0; 
 DEFINE>{===>} rdc2_cool3=1.0; 
 DEFINE>{===>} rdc2_r=0.4; 
 DEFINE>{===>} rdc2_d=8.0; 
 DEFINE>{===>} ini_bor_hot_2=1.0; 
 DEFINE>{===>} fin_bor_hot_2=10.0; 
 DEFINE>{===>} ini_bor_cool1_2=10.0; 
 DEFINE>{===>} fin_bor_cool1_2=40.0; 
 DEFINE>{===>} ini_bor_cool2_2=40.0; 
 DEFINE>{===>} fin_bor_cool2_2=40.0; 
 DEFINE>{===>} ini_bor_cool3_2=40.0; 
 DEFINE>{===>} fin_bor_cool3_2=40.0; 
 DEFINE>{===>} ini_cen_hot_2=0.25; 
 DEFINE>{===>} fin_cen_hot_2=2.5; 
 DEFINE>{===>} ini_cen_cool1_2=2.5; 
 DEFINE>{===>} fin_cen_cool1_2=10.0; 
 DEFINE>{===>} ini_cen_cool2_2=10.0; 
 DEFINE>{===>} fin_cen_cool2_2=10.0; 
 DEFINE>{===>} ini_cen_cool3_2=10.0; 
 DEFINE>{===>} fin_cen_cool3_2=10.0; 
 DEFINE>{+ choice: "NO" "SANI" "XRDC" "VANGLE" +} 
 DEFINE>{===>} rdc3_choice="NO"; 
 DEFINE>{===>} rdc3_firstIt=0; 
 DEFINE>{===>} rdc3_lastIt=2; 
 DEFINE>{===>} rdc3_hot=0.1; 
 DEFINE>{===>} rdc3_cool1=1.0; 
 DEFINE>{===>} rdc3_cool2=1.0; 
 DEFINE>{===>} rdc3_cool3=1.0; 
 DEFINE>{===>} rdc3_r=0.4; 
 DEFINE>{===>} rdc3_d=8.0; 
 DEFINE>{===>} ini_bor_hot_3=1.0; 
 DEFINE>{===>} fin_bor_hot_3=10.0; 
 DEFINE>{===>} ini_bor_cool1_3=10.0; 
 DEFINE>{===>} fin_bor_cool1_3=40.0; 
 DEFINE>{===>} ini_bor_cool2_3=40.0; 
 DEFINE>{===>} fin_bor_cool2_3=40.0; 
 DEFINE>{===>} ini_bor_cool3_3=40.0; 
 DEFINE>{===>} fin_bor_cool3_3=40.0; 
 DEFINE>{===>} ini_cen_hot_3=0.25; 
 DEFINE>{===>} fin_cen_hot_3=2.5; 
 DEFINE>{===>} ini_cen_cool1_3=2.5; 
 DEFINE>{===>} fin_cen_cool1_3=10.0; 
 DEFINE>{===>} ini_cen_cool2_3=10.0; 
 DEFINE>{===>} fin_cen_cool2_3=10.0; 
 DEFINE>{===>} ini_cen_cool3_3=10.0; 
 DEFINE>{===>} fin_cen_cool3_3=10.0; 
 DEFINE>{+ choice: "NO" "SANI" "XRDC" "VANGLE" +} 
 DEFINE>{===>} rdc4_choice="NO"; 
 DEFINE>{===>} rdc4_firstIt=0; 
 DEFINE>{===>} rdc4_lastIt=2; 
 DEFINE>{===>} rdc4_hot=0.1; 
 DEFINE>{===>} rdc4_cool1=1.0; 
 DEFINE>{===>} rdc4_cool2=1.0; 
 DEFINE>{===>} rdc4_cool3=1.0; 
 DEFINE>{===>} rdc4_r=0.4; 
 DEFINE>{===>} rdc4_d=8.0; 
 DEFINE>{===>} ini_bor_hot_4=1.0; 
 DEFINE>{===>} fin_bor_hot_4=10.0; 
 DEFINE>{===>} ini_bor_cool1_4=10.0; 
 DEFINE>{===>} fin_bor_cool1_4=40.0; 
 DEFINE>{===>} ini_bor_cool2_4=40.0; 
 DEFINE>{===>} fin_bor_cool2_4=40.0; 
 DEFINE>{===>} ini_bor_cool3_4=40.0; 
 DEFINE>{===>} fin_bor_cool3_4=40.0; 
 DEFINE>{===>} ini_cen_hot_4=0.25; 
 DEFINE>{===>} fin_cen_hot_4=2.5; 
 DEFINE>{===>} ini_cen_cool1_4=2.5; 
 DEFINE>{===>} fin_cen_cool1_4=10.0; 
 DEFINE>{===>} ini_cen_cool2_4=10.0; 
 DEFINE>{===>} fin_cen_cool2_4=10.0; 
 DEFINE>{===>} ini_cen_cool3_4=10.0; 
 DEFINE>{===>} fin_cen_cool3_4=10.0; 
 DEFINE>{+ choice: "NO" "SANI" "XRDC" "VANGLE" +} 
 DEFINE>{===>} rdc5_choice="NO"; 
 DEFINE>{===>} rdc5_firstIt=0; 
 DEFINE>{===>} rdc5_lastIt=2; 
 DEFINE>{===>} rdc5_hot=0.1; 
 DEFINE>{===>} rdc5_cool1=1.0; 
 DEFINE>{===>} rdc5_cool2=1.0; 
 DEFINE>{===>} rdc5_cool3=1.0; 
 DEFINE>{===>} rdc5_r=0.4; 
 DEFINE>{===>} rdc5_d=8.0; 
 DEFINE>{===>} ini_bor_hot_5=1.0; 
 DEFINE>{===>} fin_bor_hot_5=10.0; 
 DEFINE>{===>} ini_bor_cool1_5=10.0; 
 DEFINE>{===>} fin_bor_cool1_5=40.0; 
 DEFINE>{===>} ini_bor_cool2_5=40.0; 
 DEFINE>{===>} fin_bor_cool2_5=40.0; 
 DEFINE>{===>} ini_bor_cool3_5=40.0; 
 DEFINE>{===>} fin_bor_cool3_5=40.0; 
 DEFINE>{===>} ini_cen_hot_5=0.25; 
 DEFINE>{===>} fin_cen_hot_5=2.5; 
 DEFINE>{===>} ini_cen_cool1_5=2.5; 
 DEFINE>{===>} fin_cen_cool1_5=10.0; 
 DEFINE>{===>} ini_cen_cool2_5=10.0; 
 DEFINE>{===>} fin_cen_cool2_5=10.0; 
 DEFINE>{===>} ini_cen_cool3_5=10.0; 
 DEFINE>{===>} fin_cen_cool3_5=10.0; 
 DEFINE>{=========================== pseudo contact shifts ===========================} 
 DEFINE>{* Parameters *} 
 DEFINE>{+ table: rows=10 "class1" "class2" "class3" "class4" "class5" "class6" "class7" "class8" "class9" "class10" 
 DEFINE>          cols=9 "type" "firstIt" "lastIt" "Kpcs<br>(hot)" "Kpcs<br>(cool1)" "Kpcs<br>(cool2)" "Kpcs<br>(cool3)" "R" "D" +} 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs1_choice="NO"; 
 DEFINE>{===>} pcs1_firstIt=0; 
 DEFINE>{===>} pcs1_lastIt=2; 
 DEFINE>{===>} pcs1_hot=100.0; 
 DEFINE>{===>} pcs1_cool1=100.0; 
 DEFINE>{===>} pcs1_cool2=100.0; 
 DEFINE>{===>} pcs1_cool3=1000.0; 
 DEFINE>{===>} pcs1_r=1000.0; 
 DEFINE>{===>} pcs1_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs2_choice="NO"; 
 DEFINE>{===>} pcs2_firstIt=0; 
 DEFINE>{===>} pcs2_lastIt=2; 
 DEFINE>{===>} pcs2_hot=100.0; 
 DEFINE>{===>} pcs2_cool1=100.0; 
 DEFINE>{===>} pcs2_cool2=100.0; 
 DEFINE>{===>} pcs2_cool3=1000.0; 
 DEFINE>{===>} pcs2_r=1000.0; 
 DEFINE>{===>} pcs2_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs3_choice="NO"; 
 DEFINE>{===>} pcs3_firstIt=0; 
 DEFINE>{===>} pcs3_lastIt=2; 
 DEFINE>{===>} pcs3_hot=100.0; 
 DEFINE>{===>} pcs3_cool1=100.0; 
 DEFINE>{===>} pcs3_cool2=100.0; 
 DEFINE>{===>} pcs3_cool3=1000.0; 
 DEFINE>{===>} pcs3_r=1000.0; 
 DEFINE>{===>} pcs3_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs4_choice="NO"; 
 DEFINE>{===>} pcs4_firstIt=0; 
 DEFINE>{===>} pcs4_lastIt=2; 
 DEFINE>{===>} pcs4_hot=100.0; 
 DEFINE>{===>} pcs4_cool1=100.0; 
 DEFINE>{===>} pcs4_cool2=100.0; 
 DEFINE>{===>} pcs4_cool3=1000.0; 
 DEFINE>{===>} pcs4_r=1000.0; 
 DEFINE>{===>} pcs4_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs5_choice="NO"; 
 DEFINE>{===>} pcs5_firstIt=0; 
 DEFINE>{===>} pcs5_lastIt=2; 
 DEFINE>{===>} pcs5_hot=100.0; 
 DEFINE>{===>} pcs5_cool1=100.0; 
 DEFINE>{===>} pcs5_cool2=100.0; 
 DEFINE>{===>} pcs5_cool3=1000.0; 
 DEFINE>{===>} pcs5_r=1000.0; 
 DEFINE>{===>} pcs5_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs6_choice="NO"; 
 DEFINE>{===>} pcs6_firstIt=0; 
 DEFINE>{===>} pcs6_lastIt=2; 
 DEFINE>{===>} pcs6_hot=100.0; 
 DEFINE>{===>} pcs6_cool1=100.0; 
 DEFINE>{===>} pcs6_cool2=100.0; 
 DEFINE>{===>} pcs6_cool3=1000.0; 
 DEFINE>{===>} pcs6_r=1000.0; 
 DEFINE>{===>} pcs6_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs7_choice="NO"; 
 DEFINE>{===>} pcs7_firstIt=0; 
 DEFINE>{===>} pcs7_lastIt=2; 
 DEFINE>{===>} pcs7_hot=100.0; 
 DEFINE>{===>} pcs7_cool1=100.0; 
 DEFINE>{===>} pcs7_cool2=100.0; 
 DEFINE>{===>} pcs7_cool3=1000.0; 
 DEFINE>{===>} pcs7_r=1000.0; 
 DEFINE>{===>} pcs7_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs8_choice="NO"; 
 DEFINE>{===>} pcs8_firstIt=0; 
 DEFINE>{===>} pcs8_lastIt=2; 
 DEFINE>{===>} pcs8_hot=100.0; 
 DEFINE>{===>} pcs8_cool1=100.0; 
 DEFINE>{===>} pcs8_cool2=100.0; 
 DEFINE>{===>} pcs8_cool3=1000.0; 
 DEFINE>{===>} pcs8_r=1000.0; 
 DEFINE>{===>} pcs8_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs9_choice="NO"; 
 DEFINE>{===>} pcs9_firstIt=0; 
 DEFINE>{===>} pcs9_lastIt=2; 
 DEFINE>{===>} pcs9_hot=100.0; 
 DEFINE>{===>} pcs9_cool1=100.0; 
 DEFINE>{===>} pcs9_cool2=100.0; 
 DEFINE>{===>} pcs9_cool3=1000.0; 
 DEFINE>{===>} pcs9_r=1000.0; 
 DEFINE>{===>} pcs9_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcsA_choice="NO"; 
 DEFINE>{===>} pcsA_firstIt=0; 
 DEFINE>{===>} pcsA_lastIt=2; 
 DEFINE>{===>} pcsA_hot=100.0; 
 DEFINE>{===>} pcsA_cool1=100.0; 
 DEFINE>{===>} pcsA_cool2=100.0; 
 DEFINE>{===>} pcsA_cool3=1000.0; 
 DEFINE>{===>} pcsA_r=1000.0; 
 DEFINE>{===>} pcsA_d=10000.0; 
 DEFINE>{=========================== relaxation data ======================} 
 DEFINE>{* Parameters *} 
 DEFINE>{+ table: rows=5 "class1" "class2" "class3" "class4" "class5" 
 DEFINE>          cols=12 "type" "firstIt" "lastIt" "Kdani(hot)" "Kdani(cool1)" "Kdani(cool2)" "Kdani(cool3)" "Correlation time" "D" "R" "H frequency" "N frequency" +} 
 DEFINE>{+ choice: "NO" "DANI" +} 
 DEFINE>{===>} dan1_choice="NO"; 
 DEFINE>{===>} dan1_firstIt=0; 
 DEFINE>{===>} dan1_lastIt=2; 
 DEFINE>{===>} dan1_hot=1; 
 DEFINE>{===>} dan1_cool1=5; 
 DEFINE>{===>} dan1_cool2=10; 
 DEFINE>{===>} dan1_cool3=10; 
 DEFINE>{===>} dan1_tc=9.771; 
 DEFINE>{===>} dan1_anis=1.557; 
 DEFINE>{===>} dan1_r=0.455; 
 DEFINE>{===>} dan1_wh=599.91; 
 DEFINE>{===>} dan1_wn=60.82; 
 DEFINE>{+ choice: "NO" "DANI" +} 
 DEFINE>{===>} dan2_choice="NO"; 
 DEFINE>{===>} dan2_firstIt=0; 
 DEFINE>{===>} dan2_lastIt=1; 
 DEFINE>{===>} dan2_hot=1; 
 DEFINE>{===>} dan2_cool1=5; 
 DEFINE>{===>} dan2_cool2=10; 
 DEFINE>{===>} dan2_cool3=10; 
 DEFINE>{===>} dan2_tc=9.84; 
 DEFINE>{===>} dan2_anis=-1.35; 
 DEFINE>{===>} dan2_r=0.308; 
 DEFINE>{===>} dan2_wh=599.91; 
 DEFINE>{===>} dan2_wn=60.82; 
 DEFINE>{+ choice: "NO" "DANI" +} 
 DEFINE>{===>} dan3_choice="NO"; 
 DEFINE>{===>} dan3_firstIt=1; 
 DEFINE>{===>} dan3_lastIt=1; 
 DEFINE>{===>} dan3_hot=1; 
 DEFINE>{===>} dan3_cool1=5; 
 DEFINE>{===>} dan3_cool2=10; 
 DEFINE>{===>} dan3_cool3=10; 
 DEFINE>{===>} dan3_tc=9.84; 
 DEFINE>{===>} dan3_anis=-1.35; 
 DEFINE>{===>} dan3_r=0.308; 
 DEFINE>{===>} dan3_wh=599.91; 
 DEFINE>{===>} dan3_wn=60.82; 
 DEFINE>{+ choice: "NO" "DANI" +} 
 DEFINE>{===>} dan4_choice="NO"; 
 DEFINE>{===>} dan4_firstIt=0; 
 DEFINE>{===>} dan4_lastIt=2; 
 DEFINE>{===>} dan4_hot=1; 
 DEFINE>{===>} dan4_cool1=5; 
 DEFINE>{===>} dan4_cool2=10; 
 DEFINE>{===>} dan4_cool3=10; 
 DEFINE>{===>} dan4_tc=9.84; 
 DEFINE>{===>} dan4_anis=-1.35; 
 DEFINE>{===>} dan4_r=0.308; 
 DEFINE>{===>} dan4_wh=599.91; 
 DEFINE>{===>} dan4_wn=60.82; 
 DEFINE>{+ choice: "NO" "DANI" +} 
 DEFINE>{===>} dan5_choice="NO"; 
 DEFINE>{===>} dan5_firstIt=0; 
 DEFINE>{===>} dan5_lastIt=2; 
 DEFINE>{===>} dan5_hot=1; 
 DEFINE>{===>} dan5_cool1=5; 
 DEFINE>{===>} dan5_cool2=10; 
 DEFINE>{===>} dan5_cool3=10; 
 DEFINE>{===>} dan5_tc=9.84; 
 DEFINE>{===>} dan5_anis=-1.35; 
 DEFINE>{===>} dan5_r=0.308; 
 DEFINE>{===>} dan5_wh=599.91; 
 DEFINE>{===>} dan5_wn=60.82; 
 DEFINE>{===================== topology and parameter files ======================} 
 DEFINE>{* topology file for molecule (protein) A *} 
 DEFINE>{===>} prot_top_A="protein-allhdg5-4.top"; 
 DEFINE>{* topology file for molecule (protein) B *} 
 DEFINE>{===>} prot_top_B="protein-allhdg5-4.top"; 
 DEFINE>{* topology file for molecule (protein) C *} 
 DEFINE>{===>} prot_top_C=""; 
 DEFINE>{* topology file for molecule (protein) D *} 
 DEFINE>{===>} prot_top_D=""; 
 DEFINE>{* topology file for molecule (protein) E *} 
 DEFINE>{===>} prot_top_E=""; 
 DEFINE>{* topology file for molecule (protein) F *} 
 DEFINE>{===>} prot_top_F=""; 
 DEFINE>{* linkage file for molecule (protein) A *} 
 DEFINE>{===>} prot_link_A="protein-allhdg5-4-noter.link"; 
 DEFINE>{* linkage file for molecule (protein) B *} 
 DEFINE>{===>} prot_link_B="protein-allhdg5-4-noter.link"; 
 DEFINE>{* linkage file for molecule (protein) C *} 
 DEFINE>{===>} prot_link_C=""; 
 DEFINE>{* linkage file for molecule (protein) D *} 
 DEFINE>{===>} prot_link_D=""; 
 DEFINE>{* linkage file for molecule (protein) E *} 
 DEFINE>{===>} prot_link_E=""; 
 DEFINE>{* linkage file for molecule (protein) F *} 
 DEFINE>{===>} prot_link_F=""; 
 DEFINE>{* energy parameter file for molecule (protein) A *} 
 DEFINE>{===>} prot_par_A="protein-allhdg5-4.param"; 
 DEFINE>{* energy parameter file for molecule (protein) B *} 
 DEFINE>{===>} prot_par_B="protein-allhdg5-4.param"; 
 DEFINE>{* energy parameter file for molecule (protein) C *} 
 DEFINE>{===>} prot_par_C=""; 
 DEFINE>{* energy parameter file for molecule (protein) D *} 
 DEFINE>{===>} prot_par_D=""; 
 DEFINE>{* energy parameter file for molecule (protein) E *} 
 DEFINE>{===>} prot_par_E=""; 
 DEFINE>{* energy parameter file for molecule (protein) F *} 
 DEFINE>{===>} prot_par_F=""; 
 DEFINE>{* type of non-bonded parameters *} 
 DEFINE>{* specify the type of non-bonded interaction *} 
 DEFINE>{+ choice: "PROLSQ" "PARMALLH6" "PARALLHDG" "OPLSX" +} 
 DEFINE>{===>} par_nonbonded="OPLSX"; 
 DEFINE>{===================== energy and interaction parameters ==================} 
 DEFINE>{ Do you want to include dihedral angle energy terms? } 
 DEFINE>{ choice: true false } 
 DEFINE>dihedflag=true; 
 DEFINE>{* Do you want to include the electrostatic energy term for docking? *} 
 DEFINE>{* Note that it will be automatically included in the solvent refinement *} 
 DEFINE>{* Include electrostatic during rigid body docking (it0)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} elecflag_0=true; 
 DEFINE>{* Include electrostatic during semi-flexible SA (it1)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} elecflag_1=true; 
 DEFINE>{* Give the epsilon constant for the electrostatic energy term? (Note: for water cdie with epsilon=1 is used) *} 
 DEFINE>{* Note that for explicit solvent refinement cdie with epsilon=1 is used *} 
 DEFINE>{===>} epsilon=10.0; 
 DEFINE>{* Use constant (cdie) or distance-dependent (rdie) dielectric? *} 
 DEFINE>{+ choice: cdie rdie +} 
 DEFINE>{===>} dielec=cdie; 
 DEFINE>{* - *} 
 DEFINE>{* Scaling of intermolecular interactions for rigid body EM*} 
 DEFINE>{===>} inter_rigid=1.0; 
 DEFINE>{* Scaling of intermolecular interactions for semi-flexible SA*} 
 DEFINE>{+ table: rows=3 "Rigid body dynamic " "SA with flexible side-chains (cool2)" "SA with flexible backbone and side-chains (cool3)" 
 DEFINE>          cols=2 "Init value" "Final value" +} 
 DEFINE>{===>} init_rigid=0.001; 
 DEFINE>{===>} fin_rigid=0.001; 
 DEFINE>{===>} init_cool2=0.001; 
 DEFINE>{===>} fin_cool2=1.0; 
 DEFINE>{===>} init_cool3=0.05; 
 DEFINE>{===>} fin_cool3=1.0; 
 DEFINE>{* Interaction matrix for non-bonded interactions*} 
 DEFINE>{+ table: rows=6 "Mol 1" "Mol 2" "Mol 3" "Mol 4" "Mol 5" "Mol 6" 
 DEFINE>          cols=6 "Mol 1" "Mol 2" "Mol 3" "Mol 4" "Mol 5" "Mol 6" +} 
 DEFINE>{===>} int_1_1=1.0; 
 DEFINE>{===>} int_1_2=1.0; 
 DEFINE>{===>} int_1_3=1.0; 
 DEFINE>{===>} int_1_4=1.0; 
 DEFINE>{===>} int_1_5=1.0; 
 DEFINE>{===>} int_1_6=1.0; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_2_1="N.A."; 
 DEFINE>{===>} int_2_2=1.0; 
 DEFINE>{===>} int_2_3=1.0; 
 DEFINE>{===>} int_2_4=1.0; 
 DEFINE>{===>} int_2_5=1.0; 
 DEFINE>{===>} int_2_6=1.0; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_3_1="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_3_2="N.A."; 
 DEFINE>{===>} int_3_3=1.0; 
 DEFINE>{===>} int_3_4=1.0; 
 DEFINE>{===>} int_3_5=1.0; 
 DEFINE>{===>} int_3_6=1.0; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_4_1="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_4_2="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_4_3="N.A."; 
 DEFINE>{===>} int_4_4=1.0; 
 DEFINE>{===>} int_4_5=1.0; 
 DEFINE>{===>} int_4_6=1.0; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_5_1="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_5_2="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_5_3="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_5_4="N.A."; 
 DEFINE>{===>} int_5_5=1.0; 
 DEFINE>{===>} int_5_6=1.0; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_6_1="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_6_2="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_6_3="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_6_4="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_6_5="N.A."; 
 DEFINE>{===>} int_6_6=1.0; 
 DEFINE>{===================== Number of structures to dock =======================} 
 DEFINE>{* Settings for the rigid body (it0) and semi-flexible refinement (it1) *} 
 DEFINE>{* number of structures for rigid body docking *} 
 DEFINE>{===>} structures_0=20; 
 DEFINE>   keepstruct_0=&structures_0; 
 DEFINE>{* number of structures for refinement *} 
 DEFINE>{===>} structures_1=20; 
 DEFINE>   keepstruct_1=&structures_1; 
 DEFINE>   keepstruct_2=&structures_1; 
 DEFINE>{* number of structures to be analysed*} 
 DEFINE>{===>} anastruc_1=20; 
 DEFINE>   anastruc_0=&anastruc_1; 
 DEFINE>   anastruc_2=&anastruc_1; 
 DEFINE>{* - *} 
 DEFINE>{* Sampling of symmetry related solutions                       *} 
 DEFINE>{* Sample 180 degrees rotated solutions during rigid body EM?   *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rotate180_0=false; 
 DEFINE>{* Sample 180 degrees rotated solutions during semi-flexible SA?*} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rotate180_1=false; 
 DEFINE>{=========================== DOCKING protocol =============================} 
 DEFINE>{* Cross-dock all combinations in the ensembles of starting structures? *} 
 DEFINE>{* Turn off this option if you only want to dock structure 1 of ensemble A *} 
 DEFINE>{*   to structure 1 of ensemble B, structure 2 to structure 2, etc. *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} crossdock=false; 
 DEFINE>{* Randomize starting orientations? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} randorien=false; 
 DEFINE>{* Perform initial rigid body minimisation? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rigidmini=false; 
 DEFINE>{* Allow translation in rigid body minimisation? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rigidtrans=false; 
 DEFINE>{* Number of trials for rigid body minimisation? *} 
 DEFINE>{===>} ntrials=5; 
 DEFINE>{* initial seed for random number generator *} 
 DEFINE>{* change to get different initial velocities *} 
 DEFINE>{===>} iniseed=917; 
 DEFINE>{* temperature for rigid body high temperature TAD *} 
 DEFINE>{===>} tadhigh_t=2000; 
 DEFINE>{* initial temperature for rigid body first TAD cooling step *} 
 DEFINE>{===>} tadinit1_t=2000; 
 DEFINE>{* final temperature after first cooling step *} 
 DEFINE>{===>} tadfinal1_t=500; 
 DEFINE>{* initial temperature for second TAD cooling step with flexible side-chain at the inferface *} 
 DEFINE>{===>} tadinit2_t=1000; 
 DEFINE>{* finale temperature after second cooling step *} 
 DEFINE>{===>} tadfinal2_t=50; 
 DEFINE>{* initial temperature for third TAD cooling step with fully flexible interface *} 
 DEFINE>{===>} tadinit3_t=500; 
 DEFINE>{* finale temperature after third cooling step *} 
 DEFINE>{===>} tadfinal3_t=50; 
 DEFINE>{* time step *} 
 DEFINE>{===>} timestep=0.002; 
 DEFINE>{* factor for timestep in TAD *} 
 DEFINE>{===>} tadfactor=8; 
 DEFINE>{* number of MD steps for rigid body high temperature TAD *} 
 DEFINE>{===>} initiosteps=0; 
 DEFINE>{* number of MD steps during first rigid body cooling stage *} 
 DEFINE>{===>} cool1_steps=0; 
 DEFINE>{* number of MD steps during second cooling stage with flexible side-chains at interface *} 
 DEFINE>{===>} cool2_steps=0; 
 DEFINE>{* number of MD steps during third cooling stage with fully flexible interface *} 
 DEFINE>{===>} cool3_steps=0; 
 DEFINE>{======================= Solvated rigid body docking=======================} 
 DEFINE>{* perform solvated docking ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} waterdock=false; 
 DEFINE>{* which method to use for solvating? *} 
 DEFINE>{* db: database-based (recommended), restraints: for restrained solvating to amino-acid most often forming 
 DEFINE>water mediated contacts and blank (""): for uniform waterlayer *} 
 DEFINE>{+ choice: "db" "restraints" "" +} 
 DEFINE>{===>} solvate_method="db"; 
 DEFINE>{* which propensity database to use? *} 
 DEFINE>{* statistical: based on an analysis of water-mediated contacts in the PDB, kyte-doolittle: based on the Kyte-Doolittle hydrophobicity scalte *} 
 DEFINE>{+ choice: "statistical" "kytedoolittle" +} 
 DEFINE>{===>} db_method="kytedoolittle"; 
 DEFINE>{* initial cutoff for restraints solvating method *} 
 DEFINE>{* all waters further away from a highly occuring water solvated residue will be removed in the generation 
 DEFINE>of the initial solvation shell *} 
 DEFINE>{===>} water_restraint_initial=5.0; 
 DEFINE>{* cutoff for restraints solvating method *} 
 DEFINE>{* upper distance limit for defining distance restraints between water and amino-acids often found to be 
 DEFINE>involved in water-mediated contacts *} 
 DEFINE>{===>} water_restraint_cutoff=5.0; 
 DEFINE>{* force constant for restraints solvating method *} 
 DEFINE>{===>} water_restraint_scale=25.0; 
 DEFINE>{* fraction of water to keep *} 
 DEFINE>{* this is the fraction of all interface water after the initial rigid body docking that will be kept (note 
 DEFINE>that more waters might be removed if the interaction energy is unfavorable  *} 
 DEFINE>{===>} water_tokeep=0.25; 
 DEFINE>{* this is the fraction of interface water involving DNA phosphates after the initial rigid body docking that will be kept 
 DEFINE>(note that more waters might be removed if the interaction energy is unfavorable  *} 
 DEFINE>{===>} dnap_water_tokeep=0.25; 
 DEFINE>{* random fraction to be added to the fraction of water to keep *} 
 DEFINE>{===>} water_randfrac=0.0; 
 DEFINE>{* water-protein surface-cutoff *} 
 DEFINE>{* waters further away than this cutoff distance from any component of the complex will be removed *} 
 DEFINE>{===>} water_surfcutoff=8.0; 
 DEFINE>{* do some water analysis *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} water_analysis=false; 
 DEFINE>{* allows translation of water molecules during rigid-body docking, true or false: *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} transwater=true; 
 DEFINE>{* number of different initial solvation shells to generate *} 
 DEFINE>{===>} waterensemble=1; 
 DEFINE>{==================== final explicit solvent refinement  ==================} 
 DEFINE>{* Do you want to refine your docking models in explicit solvent? *} 
 DEFINE>{+ choice: "yes" "no" +} 
 DEFINE>{===>} firstwater="yes"; 
 DEFINE>{* Which solvent do you want to use? *} 
 DEFINE>{+ choice: "water" "dmso" +} 
 DEFINE>{===>} solvent="water"; 
 DEFINE>{* number of structures for the explicit solvent refinement *} 
 DEFINE>{* refine the n best structures regarding energy            *} 
 DEFINE>{===>} waterrefine=20; 
 DEFINE>   structures_2=&waterrefine; 
 DEFINE>{* number of steps for heating phase (100, 200, 300K)?      *} 
 DEFINE>{===>} waterheatsteps=100; 
 DEFINE>{* number of steps for 300K phase?                          *} 
 DEFINE>{===>} watersteps=1250; 
 DEFINE>{* number of steps for cooling phase (300, 200, 100K)?      *} 
 DEFINE>{===>} watercoolsteps=500; 
 DEFINE>{* write additional PDB files including solvent ?           *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} keepwater=false; 
 DEFINE>{ calculate explicit desolvation energy (note this will double the cpu requirements) } 
 DEFINE>{ choice: true false } 
 DEFINE>calcdesolv=false; 
 DEFINE>{================================ Scoring =================================} 
 DEFINE>{* Settings for the scoring of the docking solutions *} 
 DEFINE>{* Define the weights for the various terms for the sorting of structures (scoring) *} 
 DEFINE>{+ table: rows=14 "Evdw" "Eelec" "Eair" "Erg" "Esani" "Exrdc" "Expcs" "Edani" "Evean" "Ecdih" "Esym" "BSA" "dEint" "Edesolv" 
 DEFINE>          cols=3 "Rigid body EM" "semi-flexible SA" "Water refinement" +} 
 DEFINE>{===>} w_vdw_0=0.01; 
 DEFINE>{===>} w_vdw_1=1.0; 
 DEFINE>{===>} w_vdw_2=1.0; 
 DEFINE>{===>} w_elec_0=1.0; 
 DEFINE>{===>} w_elec_1=1.0; 
 DEFINE>{===>} w_elec_2=0.2; 
 DEFINE>{===>} w_dist_0=0.01; 
 DEFINE>{===>} w_dist_1=0.1; 
 DEFINE>{===>} w_dist_2=0.1; 
 DEFINE>{===>} w_rg_0=0.1; 
 DEFINE>{===>} w_rg_1=1.0; 
 DEFINE>{===>} w_rg_2=1.0; 
 DEFINE>{===>} w_sani_0=0.1; 
 DEFINE>{===>} w_sani_1=0.1; 
 DEFINE>{===>} w_sani_2=0.1; 
 DEFINE>{===>} w_xrdc_0=0.1; 
 DEFINE>{===>} w_xrdc_1=0.1; 
 DEFINE>{===>} w_xrdc_2=0.1; 
 DEFINE>{===>} w_xpcs_0=0.1; 
 DEFINE>{===>} w_xpcs_1=0.1; 
 DEFINE>{===>} w_xpcs_2=0.1; 
 DEFINE>{===>} w_dani_0=0.01; 
 DEFINE>{===>} w_dani_1=0.1; 
 DEFINE>{===>} w_dani_2=0.1; 
 DEFINE>{===>} w_vean_0=0.1; 
 DEFINE>{===>} w_vean_1=0.1; 
 DEFINE>{===>} w_vean_2=0.1; 
 DEFINE>{===>} w_cdih_0=0.0; 
 DEFINE>{===>} w_cdih_1=0.0; 
 DEFINE>{===>} w_cdih_2=0.0; 
 DEFINE>{===>} w_sym_0=0.1; 
 DEFINE>{===>} w_sym_1=0.1; 
 DEFINE>{===>} w_sym_2=0.1; 
 DEFINE>{===>} w_bsa_0=-0.01; 
 DEFINE>{===>} w_bsa_1=-0.01; 
 DEFINE>{===>} w_bsa_2=0.0; 
 DEFINE>{===>} w_deint_0=0.0; 
 DEFINE>{===>} w_deint_1=0.0; 
 DEFINE>{===>} w_deint_2=0.0; 
 DEFINE>{===>} w_desolv_0=1.0; 
 DEFINE>{===>} w_desolv_1=1.0; 
 DEFINE>{===>} w_desolv_2=1.0; 
 DEFINE>{* Perform smoothed-scoring selection for rigid-body docking solutions ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} smoothing=false; 
 DEFINE>{* It is possible to skip structures in the selection of structure in it0 *} 
 DEFINE>{* Give for this the number of structures to skip: *} 
 DEFINE>{===>} skip_struc=0; 
 DEFINE>{======================= analysis and clustering ==========================} 
 DEFINE>{* Cutoff distance (proton-acceptor) to define an hydrogen bond? *} 
 DEFINE>{===>} dist_hb=2.5; 
 DEFINE>{* Cutoff distance (carbon-carbon) to define an hydrophobic contact? *} 
 DEFINE>{===>} dist_nb=3.9; 
 DEFINE>{* Clustering method (RMSD or Fraction of Common Contacts (FCC)) *} 
 DEFINE>{+ choice: "RMSD" "FCC" +} 
 DEFINE>{===>} clust_meth="FCC"; 
 DEFINE>{* RMSD cutoff for clustering? (Recommended values: RMSD 7.5, FCC 0.75) *} 
 DEFINE>{===>} clust_cutoff=0.6; 
 DEFINE>{* Minimum cluster size? *} 
 DEFINE>{===>} clust_size=4; 
 DEFINE>{* Chain-Agnostic Algorithm (used for FCC clustering in symmetrical complexes) *} 
 DEFINE>{+ choice: "true" "false" +} 
 DEFINE>{===>} fcc_ignc=false; 
 DEFINE>{======================= final clean-up ===================================} 
 DEFINE>{* Clean up the run directory after completion (only files for struct #1 are kept) ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cleanup=true; 
 DEFINE>{============================ parallel jobs ===============================} 
 DEFINE>{* How many nodes do you want to use in parallel? *} 
 DEFINE>{* leave unused fields blank, make sure that the queues are actually running *} 
 DEFINE>{+ table: rows=10 "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" 
 DEFINE> cols=3 "queue command" "cns executable" "number of jobs" +} 
 DEFINE>{===>} queue_1="/home/diracegi/grid/diracsubmit-haddock2.2"; 
 DEFINE>{===>} cns_exe_1="/home/software/software/cns_solve_1.31-UU/intel-x86_64bit-linux/bin/cns"; 
 DEFINE>{===>} cpunumber_1=10000; 
 DEFINE>{===>} queue_2=""; 
 DEFINE>{===>} cns_exe_2=""; 
 DEFINE>{===>} cpunumber_2=0; 
 DEFINE>{===>} queue_3=""; 
 DEFINE>{===>} cns_exe_3=""; 
 DEFINE>{===>} cpunumber_3=0; 
 DEFINE>{===>} queue_4=""; 
 DEFINE>{===>} cns_exe_4=""; 
 DEFINE>{===>} cpunumber_4=0; 
 DEFINE>{===>} queue_5=""; 
 DEFINE>{===>} cns_exe_5=""; 
 DEFINE>{===>} cpunumber_5=0; 
 DEFINE>{===>} queue_6=""; 
 DEFINE>{===>} cns_exe_6=""; 
 DEFINE>{===>} cpunumber_6=0; 
 DEFINE>{===>} queue_7=""; 
 DEFINE>{===>} cns_exe_7=""; 
 DEFINE>{===>} cpunumber_7=0; 
 DEFINE>{===>} queue_8=""; 
 DEFINE>{===>} cns_exe_8=""; 
 DEFINE>{===>} cpunumber_8=0; 
 DEFINE>{===>} queue_9=""; 
 DEFINE>{===>} cns_exe_9=""; 
 DEFINE>{===>} cpunumber_9=0; 
 DEFINE>{===>} queue_10=""; 
 DEFINE>{===>} cns_exe_10=""; 
 DEFINE>{===>} cpunumber_10=0; 
 DEFINE>{===========================================================================} 
 DEFINE>{        things below this line do not normally need to be changed          } 
 DEFINE>{===========================================================================} 
 DEFINE>) {- end block parameter definition -} 
 CNSsolve>!for global parameters (local variables (suffix ) => global variables): 
 CNSsolve>evaluate (&saprotocol.crossdock=&crossdock) 
 EVALUATE: symbol $_1_SAPROTOCOL.CROSSDOCK set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.randorien=&randorien) 
 EVALUATE: symbol $_1_SAPROTOCOL.RANDORIEN set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.rigidmini=&rigidmini) 
 EVALUATE: symbol $_1_SAPROTOCOL.RIGIDMINI set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.rigidtrans=&rigidtrans) 
 EVALUATE: symbol $_1_SAPROTOCOL.RIGIDTRANS set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.ntrials=&ntrials) 
 EVALUATE: symbol $_1_SAPROTOCOL.NTRIALS set to    5.00000     (real)
 CNSsolve>evaluate (&saprotocol.iniseed=&iniseed) 
 EVALUATE: symbol $_1_SAPROTOCOL.INISEED set to    917.000     (real)
 CNSsolve>evaluate (&saprotocol.tadhigh_t=&tadhigh_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.TADHIGH_T set to    2000.00     (real)
 CNSsolve>evaluate (&saprotocol.t1_init=&tadinit1_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T1_INIT set to    2000.00     (real)
 CNSsolve>evaluate (&saprotocol.t2_init=&tadinit2_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T2_INIT set to    1000.00     (real)
 CNSsolve>evaluate (&saprotocol.t3_init=&tadinit3_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T3_INIT set to    500.000     (real)
 CNSsolve>evaluate (&saprotocol.t1_final=&tadfinal1_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T1_FINAL set to    500.000     (real)
 CNSsolve>evaluate (&saprotocol.t2_final=&tadfinal2_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T2_FINAL set to    50.0000     (real)
 CNSsolve>evaluate (&saprotocol.t3_final=&tadfinal3_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T3_FINAL set to    50.0000     (real)
 CNSsolve>evaluate (&saprotocol.inter_rigid=&inter_rigid) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_RIGID set to    1.00000     (real)
 CNSsolve>evaluate (&saprotocol.inter_init_rigid=&init_rigid) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_INIT_RIGID set to   0.100000E-02 (real)
 CNSsolve>evaluate (&saprotocol.inter_fin_rigid=&fin_rigid) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_FIN_RIGID set to   0.100000E-02 (real)
 CNSsolve>evaluate (&saprotocol.inter_init_cool2=&init_cool2) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_INIT_COOL2 set to   0.100000E-02 (real)
 CNSsolve>evaluate (&saprotocol.inter_fin_cool2=&fin_cool2) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_FIN_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&saprotocol.inter_init_cool3=&init_cool3) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_INIT_COOL3 set to   0.500000E-01 (real)
 CNSsolve>evaluate (&saprotocol.inter_fin_cool3=&fin_cool3) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_FIN_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&saprotocol.tempstep=50) 
 EVALUATE: symbol $_1_SAPROTOCOL.TEMPSTEP set to    50.0000     (real)
 CNSsolve>evaluate (&saprotocol.timestep=&timestep) 
 EVALUATE: symbol $_1_SAPROTOCOL.TIMESTEP set to   0.200000E-02 (real)
 CNSsolve>evaluate (&saprotocol.tadfactor=&tadfactor) 
 EVALUATE: symbol $_1_SAPROTOCOL.TADFACTOR set to    8.00000     (real)
 CNSsolve>evaluate (&saprotocol.initiosteps=&initiosteps) 
 EVALUATE: symbol $_1_SAPROTOCOL.INITIOSTEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.cool1_steps=&cool1_steps) 
 EVALUATE: symbol $_1_SAPROTOCOL.COOL1_STEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.cool2_steps=&cool2_steps) 
 EVALUATE: symbol $_1_SAPROTOCOL.COOL2_STEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.cool3_steps=&cool3_steps) 
 EVALUATE: symbol $_1_SAPROTOCOL.COOL3_STEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.fbeta=100) 
 EVALUATE: symbol $_1_SAPROTOCOL.FBETA set to    100.000     (real)
 CNSsolve>evaluate (&saprotocol.mass=100) 
 EVALUATE: symbol $_1_SAPROTOCOL.MASS set to    100.000     (real)
 CNSsolve>evaluate (&filenames.fileroot=&fileroot) 
 EVALUATE: symbol $_1_FILENAMES.FILEROOT set to "complex" (string)
 CNSsolve>evaluate (&filenames.template=&fileroot + "_1.pdb") 
 EVALUATE: symbol $_1_FILENAMES.TEMPLATE set to "complex_1.pdb" (string)
 CNSsolve>evaluate (&iterations.ini_count    =1) 
 EVALUATE: symbol $_1_ITERATIONS.INI_COUNT set to    1.00000     (real)
 CNSsolve>evaluate (&iterations.structures   =&structures_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.STRUCTURES set to    20.0000     (real)
 CNSsolve>evaluate (&iterations.keepstruct   =&keepstruct_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.KEEPSTRUCT set to    20.0000     (real)
 CNSsolve>evaluate (&iterations.filesort     =&filesort_$iteration) 
 Assuming literal string "&FILESORT_$ITERATION"
 EVALUATE: symbol $_1_ITERATIONS.FILESORT set to "&FILESORT_$ITERATION" (string)
 CNSsolve>evaluate (&iterations.w_vdw        =&w_vdw_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_VDW set to   0.100000E-01 (real)
 CNSsolve>evaluate (&iterations.w_elec       =&w_elec_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_ELEC set to    1.00000     (real)
 CNSsolve>evaluate (&iterations.w_dist       =&w_dist_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DIST set to   0.100000E-01 (real)
 CNSsolve>evaluate (&iterations.w_rg         =&w_rg_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_RG set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_sani       =&w_sani_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_SANI set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_xrdc       =&w_xrdc_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_XRDC set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_xpcs       =&w_xpcs_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_XPCS set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_dani       =&w_dani_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DANI set to   0.100000E-01 (real)
 CNSsolve>evaluate (&iterations.w_vean       =&w_vean_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_VEAN set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_cdih       =&w_cdih_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_CDIH set to    0.00000     (real)
 CNSsolve>evaluate (&iterations.w_sym        =&w_sym_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_SYM set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_bsa        =&w_bsa_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_BSA set to  -0.100000E-01 (real)
 CNSsolve>evaluate (&iterations.w_deint      =&w_deint_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DEINT set to    0.00000     (real)
 CNSsolve>evaluate (&iterations.w_desolv     =&w_desolv_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DESOLV set to    1.00000     (real)
 CNSsolve>evaluate (&iterations.anastruc     =&anastruc_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.ANASTRUC set to    20.0000     (real)
 CNSsolve>evaluate (&iterations.rotate180    =&rotate180_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.ROTATE180 set to FALSE (logical)
 CNSsolve>!topology and parameters, sequence file, template file, interface definition: 
 CNSsolve>evaluate (&toppar.prot_top_1=&prot_top_A ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_1 set to "protein-allhdg5-4.top" (string)
 CNSsolve>evaluate (&toppar.prot_top_2=&prot_top_B ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_2 set to "protein-allhdg5-4.top" (string)
 CNSsolve>evaluate (&toppar.prot_top_3=&prot_top_C ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_3 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_top_4=&prot_top_D ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_4 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_top_5=&prot_top_E ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_5 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_top_6=&prot_top_F ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_6 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_link_1=&prot_link_A ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_1 set to "protein-allhdg5-4-noter.link" (string)
 CNSsolve>evaluate (&toppar.prot_link_2=&prot_link_B ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_2 set to "protein-allhdg5-4-noter.link" (string)
 CNSsolve>evaluate (&toppar.prot_link_3=&prot_link_C ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_3 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_link_4=&prot_link_D ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_4 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_link_5=&prot_link_E ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_5 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_link_6=&prot_link_F ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_6 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_par_1=&prot_par_A ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_1 set to "protein-allhdg5-4.param" (string)
 CNSsolve>evaluate (&toppar.prot_par_2=&prot_par_B ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_2 set to "protein-allhdg5-4.param" (string)
 CNSsolve>evaluate (&toppar.prot_par_3=&prot_par_C ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_3 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_par_4=&prot_par_D ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_4 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_par_5=&prot_par_E ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_5 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_par_6=&prot_par_F ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_6 set to "" (string)
 CNSsolve>evaluate (&toppar.par_nonbonded=&par_nonbonded) 
 EVALUATE: symbol $_1_TOPPAR.PAR_NONBONDED set to "OPLSX" (string)
 CNSsolve>evaluate (&toppar.prot_coor_1=&prot_coor_A) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_1 set to "protein1.pdb" (string)
 CNSsolve>evaluate (&toppar.prot_coor_2=&prot_coor_B) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_2 set to "protein2.pdb" (string)
 CNSsolve>evaluate (&toppar.prot_coor_3=&prot_coor_C) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_3 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_coor_4=&prot_coor_D) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_4 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_coor_5=&prot_coor_E) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_5 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_coor_6=&prot_coor_F) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_6 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_root_1=&prot_root_A) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_1 set to "protein1" (string)
 CNSsolve>evaluate (&toppar.prot_root_2=&prot_root_B) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_2 set to "protein2" (string)
 CNSsolve>evaluate (&toppar.prot_root_3=&prot_root_C) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_3 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_root_4=&prot_root_D) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_4 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_root_5=&prot_root_E) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_5 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_root_6=&prot_root_F) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_6 set to "" (string)
 CNSsolve>evaluate (&toppar.dna_1=&dna_A) 
 EVALUATE: symbol $_1_TOPPAR.DNA_1 set to FALSE (logical)
 CNSsolve>evaluate (&toppar.dna_2=&dna_B) 
 EVALUATE: symbol $_1_TOPPAR.DNA_2 set to FALSE (logical)
 CNSsolve>evaluate (&toppar.dna_3=&dna_C) 
 EVALUATE: symbol $_1_TOPPAR.DNA_3 set to FALSE (logical)
 CNSsolve>evaluate (&toppar.dna_4=&dna_D) 
 EVALUATE: symbol $_1_TOPPAR.DNA_4 set to FALSE (logical)
 CNSsolve>evaluate (&toppar.dna_5=&dna_E) 
 EVALUATE: symbol $_1_TOPPAR.DNA_5 set to FALSE (logical)
 CNSsolve>evaluate (&toppar.dna_6=&dna_F) 
 EVALUATE: symbol $_1_TOPPAR.DNA_6 set to FALSE (logical)
 CNSsolve>evaluate (&toppar.prot_segid_1=&prot_segid_A) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_1 set to "A" (string)
 CNSsolve>evaluate (&toppar.prot_segid_2=&prot_segid_B) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_2 set to "B" (string)
 CNSsolve>evaluate (&toppar.prot_segid_3=&prot_segid_C) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_3 set to "C" (string)
 CNSsolve>evaluate (&toppar.prot_segid_4=&prot_segid_D) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_4 set to "D" (string)
 CNSsolve>evaluate (&toppar.prot_segid_5=&prot_segid_E) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_5 set to "E" (string)
 CNSsolve>evaluate (&toppar.prot_segid_6=&prot_segid_F) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_6 set to "F" (string)
 CNSsolve>evaluate (&data.ncomponents=&ncomponents) 
 EVALUATE: symbol $_1_DATA.NCOMPONENTS set to    2.00000     (real)
 CNSsolve>evaluate (&toppar.nseg_1=&nseg_A) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_1 set to   -1.00000     (real)
 CNSsolve>evaluate (&toppar.nseg_2=&nseg_B) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_2 set to   -1.00000     (real)
 CNSsolve>evaluate (&toppar.nseg_3=&nseg_C) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_3 set to   -1.00000     (real)
 CNSsolve>evaluate (&toppar.nseg_4=&nseg_D) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_4 set to   -1.00000     (real)
 CNSsolve>evaluate (&toppar.nseg_5=&nseg_E) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_5 set to   -1.00000     (real)
 CNSsolve>evaluate (&toppar.nseg_6=&nseg_F) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_6 set to   -1.00000     (real)
 CNSsolve>evaluate (&toppar.start_seg_1_1=&A_start_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_2=&A_start_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_3=&A_start_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_4=&A_start_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_5=&A_start_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_6=&A_start_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_6 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_7=&A_start_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_7 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_8=&A_start_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_8 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_9=&A_start_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_9 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_10=&A_start_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_10 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_1=&A_end_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_2=&A_end_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_3=&A_end_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_4=&A_end_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_5=&A_end_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_6=&A_end_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_6 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_7=&A_end_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_7 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_8=&A_end_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_8 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_9=&A_end_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_9 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_10=&A_end_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_10 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_1=&B_start_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_2=&B_start_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_3=&B_start_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_4=&B_start_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_5=&B_start_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_6=&B_start_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_6 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_7=&B_start_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_7 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_8=&B_start_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_8 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_9=&B_start_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_9 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_10=&B_start_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_10 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_1=&B_end_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_2=&B_end_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_3=&B_end_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_4=&B_end_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_5=&B_end_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_6=&B_end_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_6 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_7=&B_end_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_7 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_8=&B_end_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_8 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_9=&B_end_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_9 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_10=&B_end_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_10 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_1=&C_start_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_2=&C_start_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_3=&C_start_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_4=&C_start_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_5=&C_start_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_5 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_6=&C_start_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_6 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_7=&C_start_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_7 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_8=&C_start_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_8 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_9=&C_start_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_9 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_10=&C_start_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_10 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_1=&C_end_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_2=&C_end_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_3=&C_end_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_4=&C_end_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_5=&C_end_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_6=&C_end_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_6 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_7=&C_end_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_7 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_8=&C_end_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_8 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_9=&C_end_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_9 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_10=&C_end_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_10 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_1=&D_start_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_2=&D_start_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_3=&D_start_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_4=&D_start_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_5=&D_start_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_5 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_6=&D_start_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_6 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_7=&D_start_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_7 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_8=&D_start_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_8 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_9=&D_start_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_9 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_10=&D_start_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_10 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_1=&D_end_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_2=&D_end_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_3=&D_end_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_4=&D_end_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_5=&D_end_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_6=&D_end_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_6 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_7=&D_end_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_7 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_8=&D_end_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_8 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_9=&D_end_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_9 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_10=&D_end_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_10 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_1=&E_start_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_2=&E_start_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_3=&E_start_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_4=&E_start_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_5=&E_start_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_5 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_6=&E_start_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_6 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_7=&E_start_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_7 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_8=&E_start_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_8 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_9=&E_start_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_9 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_10=&E_start_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_10 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_1=&E_end_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_2=&E_end_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_3=&E_end_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_4=&E_end_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_5=&E_end_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_6=&E_end_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_6 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_7=&E_end_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_7 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_8=&E_end_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_8 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_9=&E_end_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_9 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_10=&E_end_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_10 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_1=&F_start_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_2=&F_start_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_3=&F_start_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_4=&F_start_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_5=&F_start_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_5 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_6=&F_start_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_6 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_7=&F_start_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_7 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_8=&F_start_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_8 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_9=&F_start_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_9 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_10=&F_start_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_10 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_1=&F_end_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_2=&F_end_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_3=&F_end_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_4=&F_end_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_5=&F_end_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_6=&F_end_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_6 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_7=&F_end_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_7 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_8=&F_end_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_8 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_9=&F_end_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_9 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_10=&F_end_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_10 set to "" (string)
 CNSsolve>evaluate (&toppar.nfle_1=&nfle_A) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_1 set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.start_fle_1_1=&A_start_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_1_2=&A_start_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_1_3=&A_start_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_1_4=&A_start_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_1_5=&A_start_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_1_1=&A_end_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_1_2=&A_end_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_1_3=&A_end_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_1_4=&A_end_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_1_5=&A_end_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.nfle_2=&nfle_B) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_2 set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.start_fle_2_1=&B_start_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_2_2=&B_start_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_2_3=&B_start_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_2_4=&B_start_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_2_5=&B_start_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_2_1=&B_end_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_2_2=&B_end_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_2_3=&B_end_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_2_4=&B_end_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_2_5=&B_end_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.nfle_3=&nfle_C) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_3 set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.start_fle_3_1=&C_start_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_3_2=&C_start_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_3_3=&C_start_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_3_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_3_4=&C_start_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_3_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_3_5=&C_start_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_3_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_3_1=&C_end_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_3_2=&C_end_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_3_3=&C_end_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_3_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_3_4=&C_end_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_3_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_3_5=&C_end_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_3_5 set to "" (string)
 CNSsolve>evaluate (&toppar.nfle_4=&nfle_D) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_4 set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.start_fle_4_1=&D_start_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_4_2=&D_start_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_4_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_4_3=&D_start_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_4_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_4_4=&D_start_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_4_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_4_5=&D_start_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_4_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_4_1=&D_end_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_4_2=&D_end_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_4_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_4_3=&D_end_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_4_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_4_4=&D_end_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_4_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_4_5=&D_end_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_4_5 set to "" (string)
 CNSsolve>evaluate (&toppar.nfle_5=&nfle_E) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_5 set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.start_fle_5_1=&E_start_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_5_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_5_2=&E_start_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_5_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_5_3=&E_start_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_5_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_5_4=&E_start_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_5_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_5_5=&E_start_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_5_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_5_1=&E_end_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_5_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_5_2=&E_end_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_5_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_5_3=&E_end_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_5_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_5_4=&E_end_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_5_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_5_5=&E_end_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_5_5 set to "" (string)
 CNSsolve>evaluate (&toppar.nfle_6=&nfle_F) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_6 set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.start_fle_6_1=&F_start_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_6_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_6_2=&F_start_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_6_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_6_3=&F_start_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_6_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_6_4=&F_start_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_6_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_6_5=&F_start_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_6_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_6_1=&F_end_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_6_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_6_2=&F_end_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_6_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_6_3=&F_end_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_6_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_6_4=&F_end_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_6_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_6_5=&F_end_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_6_5 set to "" (string)
 CNSsolve>evaluate (&data.numncs=&numncs) 
 EVALUATE: symbol $_1_DATA.NUMNCS set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.ncs_sta1_1=&ncs_sta1_1) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta1_2=&ncs_sta1_2) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta1_3=&ncs_sta1_3) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta1_4=&ncs_sta1_4) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta1_5=&ncs_sta1_5) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end1_1=&ncs_end1_1) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end1_2=&ncs_end1_2) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end1_3=&ncs_end1_3) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end1_4=&ncs_end1_4) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end1_5=&ncs_end1_5) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg1_1=&ncs_seg1_1) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg1_2=&ncs_seg1_2) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg1_3=&ncs_seg1_3) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg1_4=&ncs_seg1_4) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg1_5=&ncs_seg1_5) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta2_1=&ncs_sta2_1) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta2_2=&ncs_sta2_2) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta2_3=&ncs_sta2_3) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta2_4=&ncs_sta2_4) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta2_5=&ncs_sta2_5) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end2_1=&ncs_end2_1) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end2_2=&ncs_end2_2) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end2_3=&ncs_end2_3) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end2_4=&ncs_end2_4) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end2_5=&ncs_end2_5) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg2_1=&ncs_seg2_1) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg2_2=&ncs_seg2_2) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg2_3=&ncs_seg2_3) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg2_4=&ncs_seg2_4) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg2_5=&ncs_seg2_5) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG2_5 set to "" (string)
 CNSsolve>evaluate (&data.numc2sym=&numc2sym) 
 EVALUATE: symbol $_1_DATA.NUMC2SYM set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.c2sym_sta1_1=&c2sym_sta1_1) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_2=&c2sym_sta1_2) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_3=&c2sym_sta1_3) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_4=&c2sym_sta1_4) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_5=&c2sym_sta1_5) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_6=&c2sym_sta1_6) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_6 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_7=&c2sym_sta1_7) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_7 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_8=&c2sym_sta1_8) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_8 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_9=&c2sym_sta1_8) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_9 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_10=&c2sym_sta1_10) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_10 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_1=&c2sym_end1_1) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_2=&c2sym_end1_2) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_3=&c2sym_end1_3) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_4=&c2sym_end1_4) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_5=&c2sym_end1_5) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_6=&c2sym_end1_6) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_6 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_7=&c2sym_end1_7) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_7 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_8=&c2sym_end1_8) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_8 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_9=&c2sym_end1_9) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_9 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_10=&c2sym_end1_10) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_10 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_1=&c2sym_seg1_1) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_2=&c2sym_seg1_2) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_3=&c2sym_seg1_3) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_4=&c2sym_seg1_4) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_5=&c2sym_seg1_5) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_6=&c2sym_seg1_6) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_6 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_7=&c2sym_seg1_7) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_7 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_8=&c2sym_seg1_8) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_8 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_9=&c2sym_seg1_9) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_9 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_10=&c2sym_seg1_10) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_10 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_1=&c2sym_sta2_1) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_2=&c2sym_sta2_2) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_3=&c2sym_sta2_3) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_4=&c2sym_sta2_4) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_5=&c2sym_sta2_5) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_6=&c2sym_sta2_6) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_6 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_7=&c2sym_sta2_7) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_7 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_8=&c2sym_sta2_8) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_8 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_9=&c2sym_sta2_9) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_9 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_10=&c2sym_sta2_10) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_10 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_1=&c2sym_end2_1) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_2=&c2sym_end2_2) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_3=&c2sym_end2_3) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_4=&c2sym_end2_4) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_5=&c2sym_end2_5) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_6=&c2sym_end2_6) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_6 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_7=&c2sym_end2_7) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_7 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_8=&c2sym_end2_8) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_8 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_9=&c2sym_end2_9) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_9 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_10=&c2sym_end2_10) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_10 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_1=&c2sym_seg2_1) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_2=&c2sym_seg2_2) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_3=&c2sym_seg2_3) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_4=&c2sym_seg2_4) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_5=&c2sym_seg2_5) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_6=&c2sym_seg2_6) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_6 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_7=&c2sym_seg2_7) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_7 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_8=&c2sym_seg2_8) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_8 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_9=&c2sym_seg2_9) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_9 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_10=&c2sym_seg2_10) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_10 set to "" (string)
 CNSsolve>evaluate (&data.numc3sym=&numc3sym) 
 EVALUATE: symbol $_1_DATA.NUMC3SYM set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.c3sym_sta1_1=&c3sym_sta1_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_STA1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_sta1_2=&c3sym_sta1_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_STA1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_sta2_1=&c3sym_sta2_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_STA2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_sta2_2=&c3sym_sta2_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_STA2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_sta3_1=&c3sym_sta3_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_STA3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_sta3_2=&c3sym_sta3_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_STA3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_end1_1=&c3sym_end1_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_END1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_end1_2=&c3sym_end1_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_END1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_end2_1=&c3sym_end2_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_END2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_end2_2=&c3sym_end2_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_END2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_end3_1=&c3sym_end3_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_END3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_end3_2=&c3sym_end3_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_END3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_seg1_1=&c3sym_seg1_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_SEG1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_seg1_2=&c3sym_seg1_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_SEG1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_seg2_1=&c3sym_seg2_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_SEG2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_seg2_2=&c3sym_seg2_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_SEG2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_seg3_1=&c3sym_seg3_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_SEG3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_seg3_2=&c3sym_seg3_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_SEG3_2 set to "" (string)
 CNSsolve>evaluate (&data.nums3sym=&nums3sym) 
 EVALUATE: symbol $_1_DATA.NUMS3SYM set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.s3sym_sta1_1=&s3sym_sta1_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta1_2=&s3sym_sta1_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta1_3=&s3sym_sta1_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta1_4=&s3sym_sta1_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta2_1=&s3sym_sta2_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta2_2=&s3sym_sta2_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta2_3=&s3sym_sta2_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta2_4=&s3sym_sta2_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta3_1=&s3sym_sta3_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta3_2=&s3sym_sta3_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta3_3=&s3sym_sta3_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA3_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta3_4=&s3sym_sta3_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA3_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end1_1=&s3sym_end1_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end1_2=&s3sym_end1_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end1_3=&s3sym_end1_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end1_4=&s3sym_end1_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end2_1=&s3sym_end2_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end2_2=&s3sym_end2_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end2_3=&s3sym_end2_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end2_4=&s3sym_end2_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end3_1=&s3sym_end3_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end3_2=&s3sym_end3_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end3_3=&s3sym_end3_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END3_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end3_4=&s3sym_end3_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END3_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg1_1=&s3sym_seg1_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg1_2=&s3sym_seg1_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg1_3=&s3sym_seg1_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg1_4=&s3sym_seg1_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg2_1=&s3sym_seg2_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg2_2=&s3sym_seg2_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg2_3=&s3sym_seg2_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg2_4=&s3sym_seg2_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg3_1=&s3sym_seg3_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg3_2=&s3sym_seg3_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg3_3=&s3sym_seg3_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG3_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg3_4=&s3sym_seg3_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG3_4 set to "" (string)
 CNSsolve>evaluate (&data.numc4sym=&numc4sym) 
 EVALUATE: symbol $_1_DATA.NUMC4SYM set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.c4sym_sta1_1=&c4sym_sta1_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_sta1_2=&c4sym_sta1_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_sta2_1=&c4sym_sta2_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_sta2_2=&c4sym_sta2_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_sta3_1=&c4sym_sta3_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_sta3_2=&c4sym_sta3_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_sta4_1=&c4sym_sta4_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_sta4_2=&c4sym_sta4_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA4_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end1_1=&c4sym_end1_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end1_2=&c4sym_end1_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end2_1=&c4sym_end2_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end2_2=&c4sym_end2_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end3_1=&c4sym_end3_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end3_2=&c4sym_end3_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end4_1=&c4sym_end4_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end4_2=&c4sym_end4_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END4_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg1_1=&c4sym_seg1_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg1_2=&c4sym_seg1_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg2_1=&c4sym_seg2_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg2_2=&c4sym_seg2_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg3_1=&c4sym_seg3_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg3_2=&c4sym_seg3_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg4_1=&c4sym_seg4_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg3_2=&c4sym_seg4_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG3_2 set to "" (string)
 CNSsolve>evaluate (&data.numc5sym=&numc5sym) 
 EVALUATE: symbol $_1_DATA.NUMC5SYM set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.c5sym_sta1_1=&c5sym_sta1_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_STA1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_sta2_1=&c5sym_sta2_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_STA2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_sta3_1=&c5sym_sta3_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_STA3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_sta4_1=&c5sym_sta4_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_STA4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_sta5_1=&c5sym_sta5_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_STA5_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_end1_1=&c5sym_end1_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_END1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_end2_1=&c5sym_end2_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_END2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_end3_1=&c5sym_end3_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_END3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_end4_1=&c5sym_end4_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_END4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_end5_1=&c5sym_end5_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_END5_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_seg1_1=&c5sym_seg1_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_SEG1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_seg2_1=&c5sym_seg2_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_SEG2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_seg3_1=&c5sym_seg3_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_SEG3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_seg4_1=&c5sym_seg4_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_SEG4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_seg5_1=&c5sym_seg5_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_SEG5_1 set to "" (string)
 CNSsolve>if ( &data.numc2sym eq 6) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&iterations.rotate180 = false) 
 CNSsolve>end if 
 CNSsolve>if ( &data.numc3sym ne 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&iterations.rotate180 = false) 
 CNSsolve>end if 
 CNSsolve>if ( &data.numc4sym ne 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&iterations.rotate180 = false) 
 CNSsolve>end if 
 CNSsolve>if ( &data.numc5sym ne 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&iterations.rotate180 = false) 
 CNSsolve>end if 
 CNSsolve>evaluate (&toppar.xplortodiana=&xplortodiana) 
 EVALUATE: symbol $_1_TOPPAR.XPLORTODIANA set to FALSE (logical)
 CNSsolve>evaluate (&toppar.delenph=&delenph) 
 EVALUATE: symbol $_1_TOPPAR.DELENPH set to TRUE (logical)
 CNSsolve>evaluate (&toppar.nhisd=&numhisd) 
 EVALUATE: symbol $_1_TOPPAR.NHISD set to    10.0000     (real)
 CNSsolve>evaluate (&toppar.nhise=&numhise) 
 EVALUATE: symbol $_1_TOPPAR.NHISE set to    10.0000     (real)
 CNSsolve>evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_1 set to    72.0000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_1 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    2.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_2 set to    122.000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_2 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    3.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_3 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    4.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_4 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    5.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_5 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    6.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_6 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    7.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_7 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    8.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_8 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    9.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_9 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    10.0000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_10 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    11.0000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 CNSsolve>end loop hisd 
 CNSsolve>evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_1 set to    162.000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_1 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    2.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_2 set to    269.000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_2 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    3.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_3 set to    296.000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_3 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    4.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_4 set to    120.000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_4 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    5.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_5 set to    284.000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_5 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    6.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_6 set to    61.0000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_6 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    7.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_7 set to    126.000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_7 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    8.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_8 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    9.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_9 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    10.0000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_10 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    11.0000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 CNSsolve>end loop hise 
 CNSsolve>!Electrostatics: 
 CNSsolve>evaluate (&Data.flags.dihed = &dihedflag) 
 EVALUATE: symbol $_1_DATA.FLAGS.DIHED set to TRUE (logical)
 CNSsolve>evaluate (&Data.flags.elec0 = &elecflag_0) 
 EVALUATE: symbol $_1_DATA.FLAGS.ELEC0 set to TRUE (logical)
 CNSsolve>evaluate (&Data.flags.elec1 = &elecflag_1) 
 EVALUATE: symbol $_1_DATA.FLAGS.ELEC1 set to TRUE (logical)
 CNSsolve>evaluate (&Data.epsilon = &epsilon) 
 EVALUATE: symbol $_1_DATA.EPSILON set to    10.0000     (real)
 CNSsolve>evaluate (&Data.dielec  = &dielec) 
 Assuming literal string "CDIE"
 EVALUATE: symbol $_1_DATA.DIELEC set to "CDIE" (string)
 CNSsolve>!Interaction matrix: 
 CNSsolve>evaluate ($nmol1=1) 
 EVALUATE: symbol $NMOL1 set to    1.00000     (real)
 CNSsolve>while ($nmol1 <= 6) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    2.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_1 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_2 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_1 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    3.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_3 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_3_1 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    4.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_4 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_4_1 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    5.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_5 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_5_1 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    6.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_6 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_6_1 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    7.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    2.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= 6) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    3.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_2 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_3 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_3_2 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    4.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_4 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_4_2 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    5.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_5 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_5_2 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    6.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_6 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_6_2 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    7.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    3.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= 6) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    4.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_3_3 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_3_4 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_4_3 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    5.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_3_5 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_5_3 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    6.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_3_6 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_6_3 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    7.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    4.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= 6) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    5.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_4_4 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_4_5 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_5_4 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    6.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_4_6 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_6_4 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    7.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    5.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= 6) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    6.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_5_5 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_5_6 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_6_5 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    7.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    6.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= 6) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    7.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_6_6 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    7.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= 6) loop mol1 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 CNSsolve>end loop mol1 
 CNSsolve>!Dihedrals, Jcouplings, Residual dipolar couplints, Hbonds, Analysis: 
 CNSsolve>evaluate (&Data.dnarest = &dnarest_on) 
 EVALUATE: symbol $_1_DATA.DNAREST set to FALSE (logical)
 CNSsolve>evaluate (&Data.flags.noe  =  true) 
 EVALUATE: symbol $_1_DATA.FLAGS.NOE set to TRUE (logical)
 CNSsolve>evaluate (&Data.flags.cdih =  &dihedrals_on) 
 EVALUATE: symbol $_1_DATA.FLAGS.CDIH set to FALSE (logical)
 CNSsolve>evaluate (&Data.cdih.on = &dihedrals_on) 
 EVALUATE: symbol $_1_DATA.CDIH.ON set to FALSE (logical)
 CNSsolve>evaluate (&Data.ssdihed = &ssdihed) 
 Assuming literal string "NONE"
 EVALUATE: symbol $_1_DATA.SSDIHED set to "NONE" (string)
 CNSsolve>evaluate (&Data.flags.coup =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.COUP set to FALSE (logical)
 CNSsolve>evaluate (&Data.flags.vean =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.VEAN set to FALSE (logical)
 CNSsolve>if (&rdc1_choice = "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.vean =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc2_choice = "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.vean =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc3_choice = "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.vean =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc4_choice = "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.vean =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc5_choice = "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.vean =  true) 
 CNSsolve>end if 
 CNSsolve>evaluate (&Data.flags.sani =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.SANI set to FALSE (logical)
 CNSsolve>if (&rdc1_choice = "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.sani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc2_choice = "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.sani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc3_choice = "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.sani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc4_choice = "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.sani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc5_choice = "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.sani =  true) 
 CNSsolve>end if 
 CNSsolve>evaluate (&Data.flags.xrdc =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.XRDC set to FALSE (logical)
 CNSsolve>if (&rdc1_choice = "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xrdc =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc2_choice = "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xrdc =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc3_choice = "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xrdc =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc4_choice = "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xrdc =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc5_choice = "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xrdc =  true) 
 CNSsolve>end if 
 CNSsolve>evaluate (&Data.flags.xpcs =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.XPCS set to FALSE (logical)
 CNSsolve>if (&pcs1_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs2_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs3_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs4_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs5_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs6_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs7_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs8_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs9_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcsA_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>evaluate (&Data.flags.dani =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.DANI set to FALSE (logical)
 CNSsolve>if (&dan1_choice = "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.dani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&dan2_choice = "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.dani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&dan3_choice = "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.dani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&dan4_choice = "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.dani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&dan5_choice = "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.dani =  true) 
 CNSsolve>end if 
 CNSsolve>evaluate (&Data.flags.plan =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.PLAN set to FALSE (logical)
 CNSsolve>evaluate (&Data.flags.ncs  =  &ncs_on) 
 EVALUATE: symbol $_1_DATA.FLAGS.NCS set to FALSE (logical)
 CNSsolve>evaluate (&Data.flags.sym  =  &sym_on) 
 EVALUATE: symbol $_1_DATA.FLAGS.SYM set to FALSE (logical)
 CNSsolve>evaluate (&data.scaling=&air_scaling) 
 EVALUATE: symbol $_1_DATA.SCALING set to FALSE (logical)
 CNSsolve>evaluate (&data.totnoe_unamb=&tot_unamb) 
 EVALUATE: symbol $_1_DATA.TOTNOE_UNAMB set to    25.0000     (real)
 CNSsolve>evaluate (&data.unamb_firstit=&unamb_firstit) 
 EVALUATE: symbol $_1_DATA.UNAMB_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.unamb_lastit=&unamb_lastit) 
 EVALUATE: symbol $_1_DATA.UNAMB_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.unamb_hot=&unamb_hot) 
 EVALUATE: symbol $_1_DATA.UNAMB_HOT set to    10.0000     (real)
 CNSsolve>evaluate (&data.unamb_cool1=&unamb_cool1) 
 EVALUATE: symbol $_1_DATA.UNAMB_COOL1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.unamb_cool2=&unamb_cool2) 
 EVALUATE: symbol $_1_DATA.UNAMB_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.unamb_cool3=&unamb_cool3) 
 EVALUATE: symbol $_1_DATA.UNAMB_COOL3 set to    50.0000     (real)
 CNSsolve>evaluate (&data.noecv=&noecv) 
 EVALUATE: symbol $_1_DATA.NOECV set to TRUE (logical)
 CNSsolve>evaluate (&data.ncvpart=&ncvpart) 
 EVALUATE: symbol $_1_DATA.NCVPART set to    2.00000     (real)
 CNSsolve>evaluate (&data.ranair=&ranair) 
 EVALUATE: symbol $_1_DATA.RANAIR set to FALSE (logical)
 CNSsolve>if (&data.ranair eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&data.noecv = false) 
 CNSsolve>end if 
 CNSsolve>evaluate (&data.cmrest=&cmrest) 
 EVALUATE: symbol $_1_DATA.CMREST set to TRUE (logical)
 CNSsolve>evaluate (&data.kcont=&kcont) 
 EVALUATE: symbol $_1_DATA.KCONT set to    1.00000     (real)
 CNSsolve>evaluate (&data.surfrest=&surfrest) 
 EVALUATE: symbol $_1_DATA.SURFREST set to TRUE (logical)
 CNSsolve>evaluate (&data.ksurf=&ksurf) 
 EVALUATE: symbol $_1_DATA.KSURF set to    1.00000     (real)
 CNSsolve>evaluate (&data.flags.rg=&rgrest) 
 EVALUATE: symbol $_1_DATA.FLAGS.RG set to FALSE (logical)
 CNSsolve>evaluate (&data.rgtarg=&rgtarg) 
 EVALUATE: symbol $_1_DATA.RGTARG set to    17.7800     (real)
 CNSsolve>evaluate (&data.krg_hot=&krg_hot) 
 EVALUATE: symbol $_1_DATA.KRG_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.krg_cool1=&krg_cool1) 
 EVALUATE: symbol $_1_DATA.KRG_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.krg_cool2=&krg_cool2) 
 EVALUATE: symbol $_1_DATA.KRG_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.krg_cool3=&krg_cool3) 
 EVALUATE: symbol $_1_DATA.KRG_COOL3 set to    100.000     (real)
 CNSsolve>evaluate (&data.rgsele=&rgsele) 
 EVALUATE: symbol $_1_DATA.RGSELE set to "all" (string)
 CNSsolve>evaluate (&data.totnoe_amb=&tot_amb) 
 EVALUATE: symbol $_1_DATA.TOTNOE_AMB set to    0.00000     (real)
 CNSsolve>evaluate (&data.amb_firstit=&amb_firstit) 
 EVALUATE: symbol $_1_DATA.AMB_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.amb_lastit=&amb_lastit) 
 EVALUATE: symbol $_1_DATA.AMB_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.amb_hot=&amb_hot) 
 EVALUATE: symbol $_1_DATA.AMB_HOT set to    10.0000     (real)
 CNSsolve>evaluate (&data.amb_cool1=&amb_cool1) 
 EVALUATE: symbol $_1_DATA.AMB_COOL1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.amb_cool2=&amb_cool2) 
 EVALUATE: symbol $_1_DATA.AMB_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.amb_cool3=&amb_cool3) 
 EVALUATE: symbol $_1_DATA.AMB_COOL3 set to    50.0000     (real)
 CNSsolve>evaluate (&data.kncs=&kncs) 
 EVALUATE: symbol $_1_DATA.KNCS set to    1.00000     (real)
 CNSsolve>evaluate (&data.ksym=&ksym) 
 EVALUATE: symbol $_1_DATA.KSYM set to    10.0000     (real)
 CNSsolve>evaluate (&data.hbond_firstit=&hbond_firstit) 
 EVALUATE: symbol $_1_DATA.HBOND_FIRSTIT set to    1.00000     (real)
 CNSsolve>evaluate (&data.hbond_lastit=&hbond_lastit) 
 EVALUATE: symbol $_1_DATA.HBOND_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.hbond_hot=&hbond_hot) 
 EVALUATE: symbol $_1_DATA.HBOND_HOT set to    10.0000     (real)
 CNSsolve>evaluate (&data.hbond_cool1=&hbond_cool1) 
 EVALUATE: symbol $_1_DATA.HBOND_COOL1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.hbond_cool2=&hbond_cool2) 
 EVALUATE: symbol $_1_DATA.HBOND_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.hbond_cool3=&hbond_cool3) 
 EVALUATE: symbol $_1_DATA.HBOND_COOL3 set to    50.0000     (real)
 CNSsolve>evaluate (&data.mrswi_hot=&mrswi_hot) 
 EVALUATE: symbol $_1_DATA.MRSWI_HOT set to   0.500000     (real)
 CNSsolve>evaluate (&data.mrswi_cool1=&mrswi_cool1) 
 EVALUATE: symbol $_1_DATA.MRSWI_COOL1 set to   0.500000     (real)
 CNSsolve>evaluate (&data.mrswi_cool2=&mrswi_cool2) 
 EVALUATE: symbol $_1_DATA.MRSWI_COOL2 set to   0.500000     (real)
 CNSsolve>evaluate (&data.mrswi_cool3=&mrswi_cool3) 
 EVALUATE: symbol $_1_DATA.MRSWI_COOL3 set to   0.500000     (real)
 CNSsolve>evaluate (&data.rswi_hot=&rswi_hot) 
 EVALUATE: symbol $_1_DATA.RSWI_HOT set to   0.500000     (real)
 CNSsolve>evaluate (&data.rswi_cool1=&rswi_cool1) 
 EVALUATE: symbol $_1_DATA.RSWI_COOL1 set to   0.500000     (real)
 CNSsolve>evaluate (&data.rswi_cool2=&rswi_cool2) 
 EVALUATE: symbol $_1_DATA.RSWI_COOL2 set to   0.500000     (real)
 CNSsolve>evaluate (&data.rswi_cool3=&rswi_cool3) 
 EVALUATE: symbol $_1_DATA.RSWI_COOL3 set to   0.500000     (real)
 CNSsolve>evaluate (&data.masy_hot=&masy_hot) 
 EVALUATE: symbol $_1_DATA.MASY_HOT set to   -1.00000     (real)
 CNSsolve>evaluate (&data.masy_cool1=&masy_cool1) 
 EVALUATE: symbol $_1_DATA.MASY_COOL1 set to   -1.00000     (real)
 CNSsolve>evaluate (&data.masy_cool2=&masy_cool2) 
 EVALUATE: symbol $_1_DATA.MASY_COOL2 set to  -0.100000     (real)
 CNSsolve>evaluate (&data.masy_cool3=&masy_cool3) 
 EVALUATE: symbol $_1_DATA.MASY_COOL3 set to  -0.100000     (real)
 CNSsolve>evaluate (&data.asy_hot=&asy_hot) 
 EVALUATE: symbol $_1_DATA.ASY_HOT set to    1.00000     (real)
 CNSsolve>evaluate (&data.asy_cool1=&asy_cool1) 
 EVALUATE: symbol $_1_DATA.ASY_COOL1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.asy_cool2=&asy_cool2) 
 EVALUATE: symbol $_1_DATA.ASY_COOL2 set to   0.100000     (real)
 CNSsolve>evaluate (&data.asy_cool3=&asy_cool3) 
 EVALUATE: symbol $_1_DATA.ASY_COOL3 set to   0.100000     (real)
 CNSsolve>evaluate (&data.dihedrals.on=&dihedrals_on) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS.ON set to FALSE (logical)
 CNSsolve>evaluate (&data.dihedrals_hot=&dihedrals_hot) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_HOT set to    5.00000     (real)
 CNSsolve>evaluate (&data.dihedrals_cool1=&dihedrals_cool1) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_COOL1 set to    5.00000     (real)
 CNSsolve>evaluate (&data.dihedrals_cool2=&dihedrals_cool2) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.dihedrals_cool3=&dihedrals_cool3) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_COOL3 set to    200.000     (real)
 CNSsolve>evaluate (&data.hbonds_on=&hbonds_on) 
 EVALUATE: symbol $_1_DATA.HBONDS_ON set to FALSE (logical)
 CNSsolve>evaluate (&data.c1_on=&c1_on) 
 EVALUATE: symbol $_1_DATA.C1_ON set to FALSE (logical)
 CNSsolve>evaluate (&data.c1_karplusa=&c1_karplusa) 
 EVALUATE: symbol $_1_DATA.C1_KARPLUSA set to    6.98000     (real)
 CNSsolve>evaluate (&data.c1_karplusb=&c1_karplusb) 
 EVALUATE: symbol $_1_DATA.C1_KARPLUSB set to   -1.38000     (real)
 CNSsolve>evaluate (&data.c1_karplusc=&c1_karplusc) 
 EVALUATE: symbol $_1_DATA.C1_KARPLUSC set to    1.72000     (real)
 CNSsolve>evaluate (&data.c1_karplusd=&c1_karplusd) 
 EVALUATE: symbol $_1_DATA.C1_KARPLUSD set to   -60.0000     (real)
 CNSsolve>evaluate (&data.c1_hot=&c1_hot) 
 EVALUATE: symbol $_1_DATA.C1_HOT set to    0.00000     (real)
 CNSsolve>evaluate (&data.c1_cool1=&c1_cool1) 
 EVALUATE: symbol $_1_DATA.C1_COOL1 set to   0.200000     (real)
 CNSsolve>evaluate (&data.c1_cool2=&c1_cool2) 
 EVALUATE: symbol $_1_DATA.C1_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c1_cool3=&c1_cool3) 
 EVALUATE: symbol $_1_DATA.C1_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c2_on=&c2_on) 
 EVALUATE: symbol $_1_DATA.C2_ON set to FALSE (logical)
 CNSsolve>evaluate (&data.c2_karplusa=&c2_karplusa) 
 EVALUATE: symbol $_1_DATA.C2_KARPLUSA set to    6.98000     (real)
 CNSsolve>evaluate (&data.c2_karplusb=&c2_karplusb) 
 EVALUATE: symbol $_1_DATA.C2_KARPLUSB set to   -1.38000     (real)
 CNSsolve>evaluate (&data.c2_karplusc=&c2_karplusc) 
 EVALUATE: symbol $_1_DATA.C2_KARPLUSC set to    1.72000     (real)
 CNSsolve>evaluate (&data.c2_karplusd=&c2_karplusd) 
 EVALUATE: symbol $_1_DATA.C2_KARPLUSD set to   -120.000     (real)
 CNSsolve>evaluate (&data.c2_hot=&c2_hot) 
 EVALUATE: symbol $_1_DATA.C2_HOT set to    0.00000     (real)
 CNSsolve>evaluate (&data.c2_cool1=&c2_cool1) 
 EVALUATE: symbol $_1_DATA.C2_COOL1 set to   0.200000     (real)
 CNSsolve>evaluate (&data.c2_cool2=&c2_cool2) 
 EVALUATE: symbol $_1_DATA.C2_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c2_cool3=&c2_cool3) 
 EVALUATE: symbol $_1_DATA.C2_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c3_on=&c3_on) 
 EVALUATE: symbol $_1_DATA.C3_ON set to FALSE (logical)
 CNSsolve>evaluate (&data.c3_karplusa=&c3_karplusa) 
 EVALUATE: symbol $_1_DATA.C3_KARPLUSA set to    6.98000     (real)
 CNSsolve>evaluate (&data.c3_karplusb=&c3_karplusb) 
 EVALUATE: symbol $_1_DATA.C3_KARPLUSB set to   -1.38000     (real)
 CNSsolve>evaluate (&data.c3_karplusc=&c3_karplusc) 
 EVALUATE: symbol $_1_DATA.C3_KARPLUSC set to    1.72000     (real)
 CNSsolve>evaluate (&data.c3_karplusd=&c3_karplusd) 
 EVALUATE: symbol $_1_DATA.C3_KARPLUSD set to   -120.000     (real)
 CNSsolve>evaluate (&data.c3_hot=&c3_hot) 
 EVALUATE: symbol $_1_DATA.C3_HOT set to    0.00000     (real)
 CNSsolve>evaluate (&data.c3_cool1=&c3_cool1) 
 EVALUATE: symbol $_1_DATA.C3_COOL1 set to   0.200000     (real)
 CNSsolve>evaluate (&data.c3_cool2=&c3_cool2) 
 EVALUATE: symbol $_1_DATA.C3_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c3_cool3=&c3_cool3) 
 EVALUATE: symbol $_1_DATA.C3_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c4_on=&c4_on) 
 EVALUATE: symbol $_1_DATA.C4_ON set to FALSE (logical)
 CNSsolve>evaluate (&data.c4_karplusa=&c4_karplusa) 
 EVALUATE: symbol $_1_DATA.C4_KARPLUSA set to    6.98000     (real)
 CNSsolve>evaluate (&data.c4_karplusb=&c4_karplusb) 
 EVALUATE: symbol $_1_DATA.C4_KARPLUSB set to   -1.38000     (real)
 CNSsolve>evaluate (&data.c4_karplusc=&c4_karplusc) 
 EVALUATE: symbol $_1_DATA.C4_KARPLUSC set to    1.72000     (real)
 CNSsolve>evaluate (&data.c4_karplusd=&c4_karplusd) 
 EVALUATE: symbol $_1_DATA.C4_KARPLUSD set to   -120.000     (real)
 CNSsolve>evaluate (&data.c4_hot=&c4_hot) 
 EVALUATE: symbol $_1_DATA.C4_HOT set to    0.00000     (real)
 CNSsolve>evaluate (&data.c4_cool1=&c4_cool1) 
 EVALUATE: symbol $_1_DATA.C4_COOL1 set to   0.200000     (real)
 CNSsolve>evaluate (&data.c4_cool2=&c4_cool2) 
 EVALUATE: symbol $_1_DATA.C4_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c4_cool3=&c4_cool3) 
 EVALUATE: symbol $_1_DATA.C4_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c5_on=&c5_on) 
 EVALUATE: symbol $_1_DATA.C5_ON set to FALSE (logical)
 CNSsolve>evaluate (&data.c5_karplusa=&c5_karplusa) 
 EVALUATE: symbol $_1_DATA.C5_KARPLUSA set to    6.98000     (real)
 CNSsolve>evaluate (&data.c5_karplusb=&c5_karplusb) 
 EVALUATE: symbol $_1_DATA.C5_KARPLUSB set to   -1.38000     (real)
 CNSsolve>evaluate (&data.c5_karplusc=&c5_karplusc) 
 EVALUATE: symbol $_1_DATA.C5_KARPLUSC set to    1.72000     (real)
 CNSsolve>evaluate (&data.c5_karplusd=&c5_karplusd) 
 EVALUATE: symbol $_1_DATA.C5_KARPLUSD set to   -120.000     (real)
 CNSsolve>evaluate (&data.c5_hot=&c5_hot) 
 EVALUATE: symbol $_1_DATA.C5_HOT set to    0.00000     (real)
 CNSsolve>evaluate (&data.c5_cool1=&c5_cool1) 
 EVALUATE: symbol $_1_DATA.C5_COOL1 set to   0.200000     (real)
 CNSsolve>evaluate (&data.c5_cool2=&c5_cool2) 
 EVALUATE: symbol $_1_DATA.C5_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c5_cool3=&c5_cool3) 
 EVALUATE: symbol $_1_DATA.C5_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc1_choice=&rdc1_choice) 
 EVALUATE: symbol $_1_DATA.RDC1_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.rdc1_firstIt=&rdc1_firstIt) 
 EVALUATE: symbol $_1_DATA.RDC1_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.rdc1_lastIt=&rdc1_lastIt) 
 EVALUATE: symbol $_1_DATA.RDC1_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.rdc1_hot=&rdc1_hot) 
 EVALUATE: symbol $_1_DATA.RDC1_HOT set to   0.100000     (real)
 CNSsolve>evaluate (&data.rdc1_cool1=&rdc1_cool1) 
 EVALUATE: symbol $_1_DATA.RDC1_COOL1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc1_cool2=&rdc1_cool2) 
 EVALUATE: symbol $_1_DATA.RDC1_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc1_cool3=&rdc1_cool3) 
 EVALUATE: symbol $_1_DATA.RDC1_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc1_r=&rdc1_r) 
 EVALUATE: symbol $_1_DATA.RDC1_R set to   0.400000     (real)
 CNSsolve>evaluate (&data.rdc1_d=&rdc1_d) 
 EVALUATE: symbol $_1_DATA.RDC1_D set to    8.00000     (real)
 CNSsolve>evaluate (&data.rdc2_choice=&rdc2_choice) 
 EVALUATE: symbol $_1_DATA.RDC2_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.rdc2_firstIt=&rdc2_firstIt) 
 EVALUATE: symbol $_1_DATA.RDC2_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.rdc2_lastIt=&rdc2_lastIt) 
 EVALUATE: symbol $_1_DATA.RDC2_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.rdc2_hot=&rdc2_hot) 
 EVALUATE: symbol $_1_DATA.RDC2_HOT set to   0.100000     (real)
 CNSsolve>evaluate (&data.rdc2_cool1=&rdc2_cool1) 
 EVALUATE: symbol $_1_DATA.RDC2_COOL1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc2_cool2=&rdc2_cool2) 
 EVALUATE: symbol $_1_DATA.RDC2_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc2_cool3=&rdc2_cool3) 
 EVALUATE: symbol $_1_DATA.RDC2_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc2_r=&rdc2_r) 
 EVALUATE: symbol $_1_DATA.RDC2_R set to   0.400000     (real)
 CNSsolve>evaluate (&data.rdc2_d=&rdc2_d) 
 EVALUATE: symbol $_1_DATA.RDC2_D set to    8.00000     (real)
 CNSsolve>evaluate (&data.rdc3_choice=&rdc3_choice) 
 EVALUATE: symbol $_1_DATA.RDC3_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.rdc3_firstIt=&rdc3_firstIt) 
 EVALUATE: symbol $_1_DATA.RDC3_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.rdc3_lastIt=&rdc3_lastIt) 
 EVALUATE: symbol $_1_DATA.RDC3_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.rdc3_hot=&rdc3_hot) 
 EVALUATE: symbol $_1_DATA.RDC3_HOT set to   0.100000     (real)
 CNSsolve>evaluate (&data.rdc3_cool1=&rdc3_cool1) 
 EVALUATE: symbol $_1_DATA.RDC3_COOL1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc3_cool2=&rdc3_cool2) 
 EVALUATE: symbol $_1_DATA.RDC3_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc3_cool3=&rdc3_cool3) 
 EVALUATE: symbol $_1_DATA.RDC3_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc3_r=&rdc3_r) 
 EVALUATE: symbol $_1_DATA.RDC3_R set to   0.400000     (real)
 CNSsolve>evaluate (&data.rdc3_d=&rdc3_d) 
 EVALUATE: symbol $_1_DATA.RDC3_D set to    8.00000     (real)
 CNSsolve>evaluate (&data.rdc4_choice=&rdc4_choice) 
 EVALUATE: symbol $_1_DATA.RDC4_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.rdc4_firstIt=&rdc4_firstIt) 
 EVALUATE: symbol $_1_DATA.RDC4_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.rdc4_lastIt=&rdc4_lastIt) 
 EVALUATE: symbol $_1_DATA.RDC4_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.rdc4_hot=&rdc4_hot) 
 EVALUATE: symbol $_1_DATA.RDC4_HOT set to   0.100000     (real)
 CNSsolve>evaluate (&data.rdc4_cool1=&rdc4_cool1) 
 EVALUATE: symbol $_1_DATA.RDC4_COOL1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc4_cool2=&rdc4_cool2) 
 EVALUATE: symbol $_1_DATA.RDC4_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc4_cool3=&rdc4_cool3) 
 EVALUATE: symbol $_1_DATA.RDC4_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc4_r=&rdc4_r) 
 EVALUATE: symbol $_1_DATA.RDC4_R set to   0.400000     (real)
 CNSsolve>evaluate (&data.rdc4_d=&rdc4_d) 
 EVALUATE: symbol $_1_DATA.RDC4_D set to    8.00000     (real)
 CNSsolve>evaluate (&data.rdc5_choice=&rdc5_choice) 
 EVALUATE: symbol $_1_DATA.RDC5_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.rdc5_firstIt=&rdc5_firstIt) 
 EVALUATE: symbol $_1_DATA.RDC5_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.rdc5_lastIt=&rdc5_lastIt) 
 EVALUATE: symbol $_1_DATA.RDC5_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.rdc5_hot=&rdc5_hot) 
 EVALUATE: symbol $_1_DATA.RDC5_HOT set to   0.100000     (real)
 CNSsolve>evaluate (&data.rdc5_cool1=&rdc5_cool1) 
 EVALUATE: symbol $_1_DATA.RDC5_COOL1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc5_cool2=&rdc5_cool2) 
 EVALUATE: symbol $_1_DATA.RDC5_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc5_cool3=&rdc5_cool3) 
 EVALUATE: symbol $_1_DATA.RDC5_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc5_r=&rdc5_r) 
 EVALUATE: symbol $_1_DATA.RDC5_R set to   0.400000     (real)
 CNSsolve>evaluate (&data.rdc5_d=&rdc5_d) 
 EVALUATE: symbol $_1_DATA.RDC5_D set to    8.00000     (real)
 CNSsolve>evaluate (&data.pcs1_choice=&pcs1_choice) 
 EVALUATE: symbol $_1_DATA.PCS1_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs1_firstIt=&pcs1_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS1_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs1_lastIt=&pcs1_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS1_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs1_hot=&pcs1_hot) 
 EVALUATE: symbol $_1_DATA.PCS1_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs1_cool1=&pcs1_cool1) 
 EVALUATE: symbol $_1_DATA.PCS1_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs1_cool2=&pcs1_cool2) 
 EVALUATE: symbol $_1_DATA.PCS1_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs1_cool3=&pcs1_cool3) 
 EVALUATE: symbol $_1_DATA.PCS1_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs1_r=&pcs1_r) 
 EVALUATE: symbol $_1_DATA.PCS1_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs1_d=&pcs1_d) 
 EVALUATE: symbol $_1_DATA.PCS1_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs2_choice=&pcs2_choice) 
 EVALUATE: symbol $_1_DATA.PCS2_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs2_firstIt=&pcs2_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS2_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs2_lastIt=&pcs2_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS2_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs2_hot=&pcs2_hot) 
 EVALUATE: symbol $_1_DATA.PCS2_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs2_cool1=&pcs2_cool1) 
 EVALUATE: symbol $_1_DATA.PCS2_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs2_cool2=&pcs2_cool2) 
 EVALUATE: symbol $_1_DATA.PCS2_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs2_cool3=&pcs2_cool3) 
 EVALUATE: symbol $_1_DATA.PCS2_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs2_r=&pcs2_r) 
 EVALUATE: symbol $_1_DATA.PCS2_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs2_d=&pcs2_d) 
 EVALUATE: symbol $_1_DATA.PCS2_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs3_choice=&pcs3_choice) 
 EVALUATE: symbol $_1_DATA.PCS3_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs3_firstIt=&pcs3_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS3_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs3_lastIt=&pcs3_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS3_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs3_hot=&pcs3_hot) 
 EVALUATE: symbol $_1_DATA.PCS3_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs3_cool1=&pcs3_cool1) 
 EVALUATE: symbol $_1_DATA.PCS3_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs3_cool2=&pcs3_cool2) 
 EVALUATE: symbol $_1_DATA.PCS3_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs3_cool3=&pcs3_cool3) 
 EVALUATE: symbol $_1_DATA.PCS3_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs3_r=&pcs3_r) 
 EVALUATE: symbol $_1_DATA.PCS3_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs3_d=&pcs3_d) 
 EVALUATE: symbol $_1_DATA.PCS3_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs4_choice=&pcs4_choice) 
 EVALUATE: symbol $_1_DATA.PCS4_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs4_firstIt=&pcs4_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS4_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs4_lastIt=&pcs4_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS4_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs4_hot=&pcs4_hot) 
 EVALUATE: symbol $_1_DATA.PCS4_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs4_cool1=&pcs4_cool1) 
 EVALUATE: symbol $_1_DATA.PCS4_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs4_cool2=&pcs4_cool2) 
 EVALUATE: symbol $_1_DATA.PCS4_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs4_cool3=&pcs4_cool3) 
 EVALUATE: symbol $_1_DATA.PCS4_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs4_r=&pcs4_r) 
 EVALUATE: symbol $_1_DATA.PCS4_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs4_d=&pcs4_d) 
 EVALUATE: symbol $_1_DATA.PCS4_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs5_choice=&pcs5_choice) 
 EVALUATE: symbol $_1_DATA.PCS5_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs5_firstIt=&pcs5_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS5_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs5_lastIt=&pcs5_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS5_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs5_hot=&pcs5_hot) 
 EVALUATE: symbol $_1_DATA.PCS5_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs5_cool1=&pcs5_cool1) 
 EVALUATE: symbol $_1_DATA.PCS5_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs5_cool2=&pcs5_cool2) 
 EVALUATE: symbol $_1_DATA.PCS5_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs5_cool3=&pcs5_cool3) 
 EVALUATE: symbol $_1_DATA.PCS5_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs5_r=&pcs5_r) 
 EVALUATE: symbol $_1_DATA.PCS5_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs5_d=&pcs5_d) 
 EVALUATE: symbol $_1_DATA.PCS5_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs6_choice=&pcs6_choice) 
 EVALUATE: symbol $_1_DATA.PCS6_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs6_firstIt=&pcs6_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS6_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs6_lastIt=&pcs6_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS6_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs6_hot=&pcs6_hot) 
 EVALUATE: symbol $_1_DATA.PCS6_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs6_cool1=&pcs6_cool1) 
 EVALUATE: symbol $_1_DATA.PCS6_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs6_cool2=&pcs6_cool2) 
 EVALUATE: symbol $_1_DATA.PCS6_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs6_cool3=&pcs6_cool3) 
 EVALUATE: symbol $_1_DATA.PCS6_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs6_r=&pcs6_r) 
 EVALUATE: symbol $_1_DATA.PCS6_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs6_d=&pcs6_d) 
 EVALUATE: symbol $_1_DATA.PCS6_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs7_choice=&pcs7_choice) 
 EVALUATE: symbol $_1_DATA.PCS7_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs7_firstIt=&pcs7_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS7_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs7_lastIt=&pcs7_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS7_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs7_hot=&pcs7_hot) 
 EVALUATE: symbol $_1_DATA.PCS7_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs7_cool1=&pcs7_cool1) 
 EVALUATE: symbol $_1_DATA.PCS7_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs7_cool2=&pcs7_cool2) 
 EVALUATE: symbol $_1_DATA.PCS7_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs7_cool3=&pcs7_cool3) 
 EVALUATE: symbol $_1_DATA.PCS7_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs7_r=&pcs7_r) 
 EVALUATE: symbol $_1_DATA.PCS7_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs7_d=&pcs7_d) 
 EVALUATE: symbol $_1_DATA.PCS7_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs8_choice=&pcs8_choice) 
 EVALUATE: symbol $_1_DATA.PCS8_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs8_firstIt=&pcs8_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS8_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs8_lastIt=&pcs8_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS8_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs8_hot=&pcs8_hot) 
 EVALUATE: symbol $_1_DATA.PCS8_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs8_cool1=&pcs8_cool1) 
 EVALUATE: symbol $_1_DATA.PCS8_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs8_cool2=&pcs8_cool2) 
 EVALUATE: symbol $_1_DATA.PCS8_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs8_cool3=&pcs8_cool3) 
 EVALUATE: symbol $_1_DATA.PCS8_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs8_r=&pcs8_r) 
 EVALUATE: symbol $_1_DATA.PCS8_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs8_d=&pcs8_d) 
 EVALUATE: symbol $_1_DATA.PCS8_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs9_choice=&pcs9_choice) 
 EVALUATE: symbol $_1_DATA.PCS9_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs9_firstIt=&pcs9_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS9_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs9_lastIt=&pcs9_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS9_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs9_hot=&pcs9_hot) 
 EVALUATE: symbol $_1_DATA.PCS9_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs9_cool1=&pcs9_cool1) 
 EVALUATE: symbol $_1_DATA.PCS9_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs9_cool2=&pcs9_cool2) 
 EVALUATE: symbol $_1_DATA.PCS9_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs9_cool3=&pcs9_cool3) 
 EVALUATE: symbol $_1_DATA.PCS9_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs9_r=&pcs9_r) 
 EVALUATE: symbol $_1_DATA.PCS9_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs9_d=&pcs9_d) 
 EVALUATE: symbol $_1_DATA.PCS9_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcsA_choice=&pcsA_choice) 
 EVALUATE: symbol $_1_DATA.PCSA_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcsA_firstIt=&pcsA_firstIt) 
 EVALUATE: symbol $_1_DATA.PCSA_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcsA_lastIt=&pcsA_lastIt) 
 EVALUATE: symbol $_1_DATA.PCSA_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcsA_hot=&pcsA_hot) 
 EVALUATE: symbol $_1_DATA.PCSA_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcsA_cool1=&pcsA_cool1) 
 EVALUATE: symbol $_1_DATA.PCSA_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcsA_cool2=&pcsA_cool2) 
 EVALUATE: symbol $_1_DATA.PCSA_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcsA_cool3=&pcsA_cool3) 
 EVALUATE: symbol $_1_DATA.PCSA_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcsA_r=&pcsA_r) 
 EVALUATE: symbol $_1_DATA.PCSA_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcsA_d=&pcsA_d) 
 EVALUATE: symbol $_1_DATA.PCSA_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.dan1_choice=&dan1_choice) 
 EVALUATE: symbol $_1_DATA.DAN1_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.dan1_firstIt=&dan1_firstIt) 
 EVALUATE: symbol $_1_DATA.DAN1_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.dan1_lastIt=&dan1_lastIt) 
 EVALUATE: symbol $_1_DATA.DAN1_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.dan1_hot=&dan1_hot) 
 EVALUATE: symbol $_1_DATA.DAN1_HOT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan1_cool1=&dan1_cool1) 
 EVALUATE: symbol $_1_DATA.DAN1_COOL1 set to    5.00000     (real)
 CNSsolve>evaluate (&data.dan1_cool2=&dan1_cool2) 
 EVALUATE: symbol $_1_DATA.DAN1_COOL2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan1_cool3=&dan1_cool3) 
 EVALUATE: symbol $_1_DATA.DAN1_COOL3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan1_tc=&dan1_tc) 
 EVALUATE: symbol $_1_DATA.DAN1_TC set to    9.77100     (real)
 CNSsolve>evaluate (&data.dan1_anis=&dan1_anis) 
 EVALUATE: symbol $_1_DATA.DAN1_ANIS set to    1.55700     (real)
 CNSsolve>evaluate (&data.dan1_r=&dan1_r) 
 EVALUATE: symbol $_1_DATA.DAN1_R set to   0.455000     (real)
 CNSsolve>evaluate (&data.dan1_wh=&dan1_wh) 
 EVALUATE: symbol $_1_DATA.DAN1_WH set to    599.910     (real)
 CNSsolve>evaluate (&data.dan1_wn=&dan1_wn) 
 EVALUATE: symbol $_1_DATA.DAN1_WN set to    60.8200     (real)
 CNSsolve>evaluate (&data.dan2_choice=&dan2_choice) 
 EVALUATE: symbol $_1_DATA.DAN2_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.dan2_firstIt=&dan2_firstIt) 
 EVALUATE: symbol $_1_DATA.DAN2_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.dan2_lastIt=&dan2_lastIt) 
 EVALUATE: symbol $_1_DATA.DAN2_LASTIT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan2_hot=&dan2_hot) 
 EVALUATE: symbol $_1_DATA.DAN2_HOT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan2_cool1=&dan2_cool1) 
 EVALUATE: symbol $_1_DATA.DAN2_COOL1 set to    5.00000     (real)
 CNSsolve>evaluate (&data.dan2_cool2=&dan2_cool2) 
 EVALUATE: symbol $_1_DATA.DAN2_COOL2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan2_cool3=&dan2_cool3) 
 EVALUATE: symbol $_1_DATA.DAN2_COOL3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan2_tc=&dan2_tc) 
 EVALUATE: symbol $_1_DATA.DAN2_TC set to    9.84000     (real)
 CNSsolve>evaluate (&data.dan2_anis=&dan2_anis) 
 EVALUATE: symbol $_1_DATA.DAN2_ANIS set to   -1.35000     (real)
 CNSsolve>evaluate (&data.dan2_r=&dan2_r) 
 EVALUATE: symbol $_1_DATA.DAN2_R set to   0.308000     (real)
 CNSsolve>evaluate (&data.dan2_wh=&dan2_wh) 
 EVALUATE: symbol $_1_DATA.DAN2_WH set to    599.910     (real)
 CNSsolve>evaluate (&data.dan2_wn=&dan2_wn) 
 EVALUATE: symbol $_1_DATA.DAN2_WN set to    60.8200     (real)
 CNSsolve>evaluate (&data.dan3_choice=&dan3_choice) 
 EVALUATE: symbol $_1_DATA.DAN3_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.dan3_firstIt=&dan3_firstIt) 
 EVALUATE: symbol $_1_DATA.DAN3_FIRSTIT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan3_lastIt=&dan3_lastIt) 
 EVALUATE: symbol $_1_DATA.DAN3_LASTIT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan3_hot=&dan3_hot) 
 EVALUATE: symbol $_1_DATA.DAN3_HOT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan3_cool1=&dan3_cool1) 
 EVALUATE: symbol $_1_DATA.DAN3_COOL1 set to    5.00000     (real)
 CNSsolve>evaluate (&data.dan3_cool2=&dan3_cool2) 
 EVALUATE: symbol $_1_DATA.DAN3_COOL2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan3_cool3=&dan3_cool3) 
 EVALUATE: symbol $_1_DATA.DAN3_COOL3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan3_tc=&dan3_tc) 
 EVALUATE: symbol $_1_DATA.DAN3_TC set to    9.84000     (real)
 CNSsolve>evaluate (&data.dan3_anis=&dan3_anis) 
 EVALUATE: symbol $_1_DATA.DAN3_ANIS set to   -1.35000     (real)
 CNSsolve>evaluate (&data.dan3_r=&dan3_r) 
 EVALUATE: symbol $_1_DATA.DAN3_R set to   0.308000     (real)
 CNSsolve>evaluate (&data.dan3_wh=&dan3_wh) 
 EVALUATE: symbol $_1_DATA.DAN3_WH set to    599.910     (real)
 CNSsolve>evaluate (&data.dan3_wn=&dan3_wn) 
 EVALUATE: symbol $_1_DATA.DAN3_WN set to    60.8200     (real)
 CNSsolve>evaluate (&data.dan4_choice=&dan4_choice) 
 EVALUATE: symbol $_1_DATA.DAN4_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.dan4_firstIt=&dan4_firstIt) 
 EVALUATE: symbol $_1_DATA.DAN4_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.dan4_lastIt=&dan4_lastIt) 
 EVALUATE: symbol $_1_DATA.DAN4_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.dan4_hot=&dan4_hot) 
 EVALUATE: symbol $_1_DATA.DAN4_HOT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan4_cool1=&dan4_cool1) 
 EVALUATE: symbol $_1_DATA.DAN4_COOL1 set to    5.00000     (real)
 CNSsolve>evaluate (&data.dan4_cool2=&dan4_cool2) 
 EVALUATE: symbol $_1_DATA.DAN4_COOL2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan4_cool3=&dan4_cool3) 
 EVALUATE: symbol $_1_DATA.DAN4_COOL3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan4_tc=&dan4_tc) 
 EVALUATE: symbol $_1_DATA.DAN4_TC set to    9.84000     (real)
 CNSsolve>evaluate (&data.dan4_anis=&dan4_anis) 
 EVALUATE: symbol $_1_DATA.DAN4_ANIS set to   -1.35000     (real)
 CNSsolve>evaluate (&data.dan4_r=&dan4_r) 
 EVALUATE: symbol $_1_DATA.DAN4_R set to   0.308000     (real)
 CNSsolve>evaluate (&data.dan4_wh=&dan4_wh) 
 EVALUATE: symbol $_1_DATA.DAN4_WH set to    599.910     (real)
 CNSsolve>evaluate (&data.dan4_wn=&dan4_wn) 
 EVALUATE: symbol $_1_DATA.DAN4_WN set to    60.8200     (real)
 CNSsolve>evaluate (&data.dan5_choice=&dan5_choice) 
 EVALUATE: symbol $_1_DATA.DAN5_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.dan5_firstIt=&dan5_firstIt) 
 EVALUATE: symbol $_1_DATA.DAN5_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.dan5_lastIt=&dan5_lastIt) 
 EVALUATE: symbol $_1_DATA.DAN5_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.dan5_hot=&dan5_hot) 
 EVALUATE: symbol $_1_DATA.DAN5_HOT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan5_cool1=&dan5_cool1) 
 EVALUATE: symbol $_1_DATA.DAN5_COOL1 set to    5.00000     (real)
 CNSsolve>evaluate (&data.dan5_cool2=&dan5_cool2) 
 EVALUATE: symbol $_1_DATA.DAN5_COOL2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan5_cool3=&dan5_cool3) 
 EVALUATE: symbol $_1_DATA.DAN5_COOL3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan5_tc=&dan5_tc) 
 EVALUATE: symbol $_1_DATA.DAN5_TC set to    9.84000     (real)
 CNSsolve>evaluate (&data.dan5_anis=&dan5_anis) 
 EVALUATE: symbol $_1_DATA.DAN5_ANIS set to   -1.35000     (real)
 CNSsolve>evaluate (&data.dan5_r=&dan5_r) 
 EVALUATE: symbol $_1_DATA.DAN5_R set to   0.308000     (real)
 CNSsolve>evaluate (&data.dan5_wh=&dan5_wh) 
 EVALUATE: symbol $_1_DATA.DAN5_WH set to    599.910     (real)
 CNSsolve>evaluate (&data.dan5_wn=&dan5_wn) 
 EVALUATE: symbol $_1_DATA.DAN5_WN set to    60.8200     (real)
 CNSsolve>!VEAN statement: 
 CNSsolve>evaluate (&data.ini_bor_hot_1=&ini_bor_hot_1) 
 EVALUATE: symbol $_1_DATA.INI_BOR_HOT_1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool1_1=&ini_bor_cool1_1) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL1_1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool2_1=&ini_bor_cool2_1) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL2_1 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool3_1=&ini_bor_cool3_1) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL3_1 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_hot_1=&ini_cen_hot_1) 
 EVALUATE: symbol $_1_DATA.INI_CEN_HOT_1 set to   0.250000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool1_1=&ini_cen_cool1_1) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL1_1 set to    2.50000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool2_1=&ini_cen_cool2_1) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL2_1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool3_1=&ini_cen_cool3_1) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL3_1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_hot_1=&fin_bor_hot_1) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_HOT_1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool1_1=&fin_bor_cool1_1) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL1_1 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool2_1=&fin_bor_cool2_1) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL2_1 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool3_1=&fin_bor_cool3_1) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL3_1 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_hot_1=&fin_cen_hot_1) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_HOT_1 set to    2.50000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool1_1=&fin_cen_cool1_1) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL1_1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool2_1=&fin_cen_cool2_1) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL2_1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool3_1=&fin_cen_cool3_1) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL3_1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_hot_2=&ini_bor_hot_2) 
 EVALUATE: symbol $_1_DATA.INI_BOR_HOT_2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool1_2=&ini_bor_cool1_2) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL1_2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool2_2=&ini_bor_cool2_2) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL2_2 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool3_2=&ini_bor_cool3_2) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL3_2 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_hot_2=&ini_cen_hot_2) 
 EVALUATE: symbol $_1_DATA.INI_CEN_HOT_2 set to   0.250000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool1_2=&ini_cen_cool1_2) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL1_2 set to    2.50000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool2_2=&ini_cen_cool2_2) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL2_2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool3_2=&ini_cen_cool3_2) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL3_2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_hot_2=&fin_bor_hot_2) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_HOT_2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool1_2=&fin_bor_cool1_2) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL1_2 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool2_2=&fin_bor_cool2_2) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL2_2 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool3_2=&fin_bor_cool3_2) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL3_2 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_hot_2=&fin_cen_hot_2) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_HOT_2 set to    2.50000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool1_2=&fin_cen_cool1_2) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL1_2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool2_2=&fin_cen_cool2_2) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL2_2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool3_2=&fin_cen_cool3_2) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL3_2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_hot_3=&ini_bor_hot_3) 
 EVALUATE: symbol $_1_DATA.INI_BOR_HOT_3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool1_3=&ini_bor_cool1_3) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL1_3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool2_3=&ini_bor_cool2_3) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL2_3 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool3_3=&ini_bor_cool3_3) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL3_3 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_hot_3=&ini_cen_hot_3) 
 EVALUATE: symbol $_1_DATA.INI_CEN_HOT_3 set to   0.250000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool1_3=&ini_cen_cool1_3) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL1_3 set to    2.50000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool2_3=&ini_cen_cool2_3) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL2_3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool3_3=&ini_cen_cool3_3) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL3_3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_hot_3=&fin_bor_hot_3) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_HOT_3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool1_3=&fin_bor_cool1_3) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL1_3 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool2_3=&fin_bor_cool2_3) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL2_3 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool3_3=&fin_bor_cool3_3) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL3_3 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_hot_3=&fin_cen_hot_3) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_HOT_3 set to    2.50000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool1_3=&fin_cen_cool1_3) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL1_3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool2_3=&fin_cen_cool2_3) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL2_3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool3_3=&fin_cen_cool3_3) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL3_3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_hot_4=&ini_bor_hot_4) 
 EVALUATE: symbol $_1_DATA.INI_BOR_HOT_4 set to    1.00000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool1_4=&ini_bor_cool1_4) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL1_4 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool2_4=&ini_bor_cool2_4) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL2_4 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool3_4=&ini_bor_cool3_4) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL3_4 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_hot_4=&ini_cen_hot_4) 
 EVALUATE: symbol $_1_DATA.INI_CEN_HOT_4 set to   0.250000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool1_4=&ini_cen_cool1_4) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL1_4 set to    2.50000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool2_4=&ini_cen_cool2_4) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL2_4 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool3_4=&ini_cen_cool3_4) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL3_4 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_hot_4=&fin_bor_hot_4) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_HOT_4 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool1_4=&fin_bor_cool1_4) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL1_4 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool2_4=&fin_bor_cool2_4) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL2_4 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool3_4=&fin_bor_cool3_4) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL3_4 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_hot_4=&fin_cen_hot_4) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_HOT_4 set to    2.50000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool1_4=&fin_cen_cool1_4) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL1_4 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool2_4=&fin_cen_cool2_4) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL2_4 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool3_4=&fin_cen_cool3_4) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL3_4 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_hot_5=&ini_bor_hot_5) 
 EVALUATE: symbol $_1_DATA.INI_BOR_HOT_5 set to    1.00000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool1_5=&ini_bor_cool1_5) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL1_5 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool2_5=&ini_bor_cool2_5) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL2_5 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool3_5=&ini_bor_cool3_5) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL3_5 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_hot_5=&ini_cen_hot_5) 
 EVALUATE: symbol $_1_DATA.INI_CEN_HOT_5 set to   0.250000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool1_5=&ini_cen_cool1_5) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL1_5 set to    2.50000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool2_5=&ini_cen_cool2_5) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL2_5 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool3_5=&ini_cen_cool3_5) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL3_5 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_hot_5=&fin_bor_hot_5) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_HOT_5 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool1_5=&fin_bor_cool1_5) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL1_5 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool2_5=&fin_bor_cool2_5) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL2_5 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool3_5=&fin_bor_cool3_5) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL3_5 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_hot_5=&fin_cen_hot_5) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_HOT_5 set to    2.50000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool1_5=&fin_cen_cool1_5) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL1_5 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool2_5=&fin_cen_cool2_5) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL2_5 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool3_5=&fin_cen_cool3_5) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL3_5 set to    10.0000     (real)
 CNSsolve>!intermolecular contacts analysis 
 CNSsolve>evaluate (&data.hb_dist=&dist_hb) 
 EVALUATE: symbol $_1_DATA.HB_DIST set to    2.50000     (real)
 CNSsolve>evaluate (&data.nb_dist=&dist_nb) 
 EVALUATE: symbol $_1_DATA.NB_DIST set to    3.90000     (real)
 CNSsolve>!water refinement 
 CNSsolve>evaluate (&refine.firstwater=&firstwater) 
 EVALUATE: symbol $_1_REFINE.FIRSTWATER set to "yes" (string)
 CNSsolve>evaluate (&refine.keepwater=&keepwater) 
 EVALUATE: symbol $_1_REFINE.KEEPWATER set to FALSE (logical)
 CNSsolve>evaluate (&refine.waterrefine=min(&structures_1,&waterrefine)) 
 EVALUATE: symbol $_1_REFINE.WATERREFINE set to    20.0000     (real)
 CNSsolve>evaluate (&refine.solvent=&solvent) 
 EVALUATE: symbol $_1_REFINE.SOLVENT set to "water" (string)
 CNSsolve>evaluate (&refine.pmrefine_on=&pmrefine_on) 
 Assuming literal string "&PMREFINE_ON"
 EVALUATE: symbol $_1_REFINE.PMREFINE_ON set to "&PMREFINE_ON" (string)
 CNSsolve>evaluate (&refine.calcdesolv=&calcdesolv) 
 EVALUATE: symbol $_1_REFINE.CALCDESOLV set to FALSE (logical)
 CNSsolve>evaluate (&refine.heatsteps=&waterheatsteps) 
 EVALUATE: symbol $_1_REFINE.HEATSTEPS set to    100.000     (real)
 CNSsolve>evaluate (&refine.steps=&watersteps) 
 EVALUATE: symbol $_1_REFINE.STEPS set to    1250.00     (real)
 CNSsolve>evaluate (&refine.coolsteps=&watercoolsteps) 
 EVALUATE: symbol $_1_REFINE.COOLSTEPS set to    500.000     (real)
 CNSsolve>!for the non-bonded parameters (the section was taken out of 
 CNSsolve>!parallhdg5.0.pro and parallhdg5.1.pro, so be careful!): 
 CNSsolve>if (&toppar.par_nonbonded eq "PROLSQ") then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.repel_radius = 1.0) 
 CNSsolve>    evaluate (&toppar.repel_rcons = 20) 
 CNSsolve>    evaluate (&toppar.repel_rexpo  = 4) 
 CNSsolve>    evaluate (&toppar.repel_irexp  = 1) 
 CNSsolve>elseif (&toppar.par_nonbonded eq "PARMALLH6") then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.repel_radius = 0.8) 
 CNSsolve>    evaluate (&toppar.repel_rcons = 5.0) 
 CNSsolve>    evaluate (&toppar.repel_rexpo  = 2) 
 CNSsolve>    evaluate (&toppar.repel_irexp  = 2) 
 CNSsolve>elseif (&toppar.par_nonbonded eq "OPLSX") then 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.repel_radius = 0.0) 
 EVALUATE: symbol $_1_TOPPAR.REPEL_RADIUS set to    0.00000     (real)
 CNSsolve>else        {...now the standard PARALLHDG parameters} 
 CNSsolve>    evaluate (&toppar.repel_radius = 0.78) 
 CNSsolve>    evaluate (&toppar.repel_rcons = 5.0) 
 CNSsolve>    evaluate (&toppar.repel_rexpo  = 2) 
 CNSsolve>    evaluate (&toppar.repel_irexp  = 2) 
 CNSsolve>end if 
 CNSsolve>! Water in rigid body docking 
 CNSsolve>evaluate (&data.waterdock=&waterdock) 
 EVALUATE: symbol $_1_DATA.WATERDOCK set to FALSE (logical)
 CNSsolve>evaluate (&data.db_method=&db_method) 
 EVALUATE: symbol $_1_DATA.DB_METHOD set to "kytedoolittle" (string)
 CNSsolve>evaluate (&data.water_tokeep=&water_tokeep) 
 EVALUATE: symbol $_1_DATA.WATER_TOKEEP set to   0.250000     (real)
 CNSsolve>evaluate (&data.dnap_water_tokeep=&dnap_water_tokeep) 
 EVALUATE: symbol $_1_DATA.DNAP_WATER_TOKEEP set to   0.250000     (real)
 CNSsolve>evaluate (&data.water_randfrac=&water_randfrac) 
 EVALUATE: symbol $_1_DATA.WATER_RANDFRAC set to    0.00000     (real)
 CNSsolve>evaluate (&data.solvate_method=&solvate_method) 
 EVALUATE: symbol $_1_DATA.SOLVATE_METHOD set to "db" (string)
 CNSsolve>evaluate (&data.water_surfcutoff=&water_surfcutoff) 
 EVALUATE: symbol $_1_DATA.WATER_SURFCUTOFF set to    8.00000     (real)
 CNSsolve>evaluate (&data.water_analysis=&water_analysis) 
 EVALUATE: symbol $_1_DATA.WATER_ANALYSIS set to FALSE (logical)
 CNSsolve>evaluate (&data.transwater=&transwater) 
 EVALUATE: symbol $_1_DATA.TRANSWATER set to TRUE (logical)
 CNSsolve>evaluate (&data.water_restraint_initial=&water_restraint_initial) 
 EVALUATE: symbol $_1_DATA.WATER_RESTRAINT_INITIAL set to    5.00000     (real)
 CNSsolve>evaluate (&data.water_restraint_cutoff=&water_restraint_cutoff) 
 EVALUATE: symbol $_1_DATA.WATER_RESTRAINT_CUTOFF set to    5.00000     (real)
 CNSsolve>evaluate (&data.water_restraint_scale=&water_restraint_scale) 
 EVALUATE: symbol $_1_DATA.WATER_RESTRAINT_SCALE set to    25.0000     (real)
 CNSsolve>evaluate (&data.waterensemble=&waterensemble) 
 EVALUATE: symbol $_1_DATA.WATERENSEMBLE set to    1.00000     (real)
 CNSsolve>if (&data.waterdock eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&iterations.rotate180   = false) 
 CNSsolve>  evaluate (&SaProtocol.initiosteps = 0) 
 CNSsolve>  evaluate (&SaProtocol.cool1_steps = 0) 
 CNSsolve>  evaluate (&refine.keepwater = true) 
 CNSsolve>  display SOLVATED DOCKING TURNED ON: initiosteps and cool1_steps set to 0, rotate180 set to false 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>parameter 
 PARRDR>   if ( &BLANK%prot_parameter_infile = false ) then 
 NEXTCD: condition evaluated as true
 PARRDR>     @@&prot_parameter_infile 
 ASSFIL: file protein-allhdg5-4.param opened.
 PARRDR>remarks file toppar/protein-allhdg5-4.param 
 PARRDR>remark 
 PARRDR>remark   for file protein-allhdg-ucl.top  version UCL  date 14-MAR-00 
 PARRDR>remark   for file protein-allhdg-dih-ucl.top  version UCL  date 07-JUL-01 
 PARRDR>remark   Geometric energy function parameters for distance geometry and 
 PARRDR>remark   simulated annealing. 
 PARRDR>remark   Original author: Michael Nilges, EMBL Heidelberg 
 PARRDR>remark   Modifications: Mark A. Williams, UCL London 
 PARRDR>remark   Several modifications for HADDOCK: Alexandre Bonvin, Utrecht Uni 
 PARRDR>remark   Last modification 27-02-2014 
 PARRDR> 
 PARRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 PARRDR>set message=off echo=off end 
 PARRDR> 
 PARRDR>   end if 
 PARRDR>   if ( &BLANK%ion_parameter_infile = false ) then 
 NEXTCD: condition evaluated as true
 PARRDR>     @@&ion_parameter_infile 
 ASSFIL: file ion.param opened.
 PARRDR>remarks file toppar/ion.param 
 PARRDR>remarks nonbonded parameters for common ions 
 PARRDR>remarks new parameters derived from literature for single atom species 
 PARRDR>remarks PDA 02/09/99 
 PARRDR> 
 PARRDR>set echo=off end 
 PARRDR>   end if 
 PARRDR>   if ( &BLANK%nucl_parameter_infile = false ) then 
 NEXTCD: condition evaluated as true
 PARRDR>     @@&nucl_parameter_infile 
 ASSFIL: file dna-rna-allatom-hj-opls-1.3.param opened.
 PARRDR>remarks file toppar/dna-rna-allatom.top 
 PARRDR>remarks  all-hydrogen dna/rna parameters using the OPLS force field 
 PARRDR> 
 PARRDR>!RNA PARAMETER FILE 'FRAMEWORK' FROM PARALLHDG.DNA AND ATOM NAMES 
 PARRDR>! AND HEAVY ATOM PARAMETERS FROM DNA-RNA.PARAM 
 PARRDR>!INCLUDES ALL NONEXCHANGEABLE HYDROGEN TERMS FOR BOND, ANGLE, AND 
 PARRDR>!IMPROPERS WITH ENERGY CONSTANT VARIABLES: $kchbond, $kchangle, AND $kchimpr. 
 PARRDR>!BOND, ANGLE, AND IMPROPERS WERE ESTIMATED FROM VALUES FROM THE STANDARD 
 PARRDR>!NUCLEOTIDES OF INSIGHTII 95.0 (BIOSYM/MOLECULAR SIMULATIONS). 
 PARRDR>!CREATED 2/24/96 -- JASON P. RIFE AND PETER B. MOORE 
 PARRDR>!ADDED OPLSX SECTION 6/2/07 -- HENRY JONKER 
 PARRDR>! DNA-RNA-ALLATOM.PARAM 
 PARRDR> 
 PARRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 PARRDR>set message=off echo=off end 
 PARRDR> 
 PARRDR>   end if 
 PARRDR>   if ( &BLANK%solv_parameter_infile = false ) then 
 NEXTCD: condition evaluated as true
 PARRDR>     @@&solv_parameter_infile 
 ASSFIL: file water-allhdg5-4.param opened.
 PARRDR>remarks file toppar/water-allhdg5-4.param 
 PARRDR>remarks 
 PARRDR>remarks   PARAM19.SOL (solvent parameters) 
 PARRDR>remarks   =========== 
 PARRDR>remarks   available: TIPS3P and DMSO model 
 PARRDR> 
 PARRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 PARRDR>set message=off echo=off end 
 PARRDR>   end if 
 PARRDR>   if ( &BLANK%ligands_parameter_infile = false ) then 
 NEXTCD: condition evaluated as true
 PARRDR>     @@&ligands_parameter_infile 
 ASSFIL: file fragment_probes.param opened.
 PARRDR>Remarks Parameters for Fragment-based Ligand Binding Site Mapping 
 PARRDR>Remarks created by acpype (Rev: 7268) on Mon Apr 13 10:01:53 2015 
 PARRDR> 
 PARRDR>set echo=false end 
 PARRDR>   end if 
 PARRDR>   if ( &BLANK%cofac_parameter_infile = false ) then 
 NEXTCD: condition evaluated as true
 PARRDR>     @@&cofac_parameter_infile 
 ASSFIL: file ligand.param opened.
 PARRDR>! Put in this file your ligand parameters if needed 
 PARRDR>! 
 PARRDR>! 
 PARRDR>!       This file was generated by PRODRG version 070118.0614 
 PARRDR>!       PRODRG written/copyrighted by Daan van Aalten 
 PARRDR>!       and Alexander Schuettelkopf 
 PARRDR>! 
 PARRDR>!       Questions/comments to dava@davapc1.bioch.dundee.ac.uk 
 PARRDR>! 
 PARRDR>!       When using this software in a publication, cite: 
 PARRDR>!       A. W. Schuettelkopf and D. M. F. van Aalten (2004). 
 PARRDR>!       PRODRG - a tool for high-throughput crystallography 
 PARRDR>!       of protein-ligand complexes. 
 PARRDR>!       Acta Crystallogr. D60, 1355--1363. 
 PARRDR>! 
 PARRDR>! 
 PARRDR>!  *** NOTE *** IF YOU USE MORE THAN ONE PRODRG-GENERATED TOPOLOGY IN CNS, 
 PARRDR>!               PLEASE CAREFULLY READ THE FAQ AS THIS MAY CAUSE PROBLEMS 
 PARRDR>! 
 PARRDR>! 
 PARRDR>set echo=off message=on end 
 EVALUATE: symbol $PD_X set to    1.00000     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    12000.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    17900.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    17900.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    12520.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    10976.7     (real)
 EVALUATE: symbol $PD_V set to    17900.0     (real)
 EVALUATE: symbol $PD_V set to    17900.0     (real)
 EVALUATE: symbol $PD_V set to    17900.0     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    544.000     (real)
 EVALUATE: symbol $PD_V set to    640.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    640.000     (real)
 EVALUATE: symbol $PD_V set to    640.000     (real)
 EVALUATE: symbol $PD_V set to    640.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    400.000     (real)
 EVALUATE: symbol $PD_V set to    400.000     (real)
 EVALUATE: symbol $PD_V set to    400.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to    8.10000     (real)
 EVALUATE: symbol $PD_V set to    8.10000     (real)
 EVALUATE: symbol $PD_V set to    640.000     (real)
 EVALUATE: symbol $PD_V set to    640.000     (real)
 EVALUATE: symbol $PD_V set to    4.90000     (real)
 EVALUATE: symbol $PD_V set to   0.900000     (real)
 PARRDR>   end if 
 PARRDR>   if ( &BLANK%heme_parameter_infile = false ) then 
 NEXTCD: condition evaluated as true
 PARRDR>     @@&heme_parameter_infile 
 ASSFIL: file hemes-allhdg.param opened.
 PARRDR>remark  file parallhdg.hemes 
 PARRDR> 
 PARRDR>set message off echo off end 
 PARRDR>   end if 
 PARRDR>end 
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond CD_  C_  
 %PARRDR-info: duplication of bond CM_  CT_ 
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle C3R  OH   HO  
 %PARRDR-info: duplication of angle C3__ C3__ HC__
 %PARRDR-info: duplication of angle CD_  CM_  CT_ 
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of angle CM_  CT_  CT_ 
 %PARRDR-info: duplication of angle CPA  NPH1 FEH 
 %PARRDR-info: duplication of angle CPA  NPH2 FEH 
 %PARRDR-info: duplication of angle CT_  CT_  C_  
 %PARRDR-info: duplication of angle CT_  CT_  HC_ 
 %PARRDR-info: duplication of angle CT_  CT_  HP_ 
 %PARRDR-info: duplication of angle CT_  CT_  N3_ 
 %PARRDR-info: duplication of angle H1__ C3__ OH__
 %PARRDR-info: duplication of angle HP_  CT_  N3_ 
 %PARRDR-info: duplication of angle HR   C3R  O3R 
 %PARRDR-info: duplication of angle HR   C3R  OH  
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 CNSsolve> 
 CNSsolve>eval($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>while ($nchain1 < $data.ncomponents) loop cloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>  evaluate($coor_infile_$nchain1= "RUN:begin/" + $Toppar.prot_root_$nchain1 + ".pdb") 
 EVALUATE: symbol $COOR_INFILE_1 set to "RUN:begin/protein1.pdb" (string)
 CNSsolve>  evaluate($psf_infile_$nchain1= "RUN:begin/" + $Toppar.prot_root_$nchain1 + ".psf") 
 EVALUATE: symbol $PSF_INFILE_1 set to "RUN:begin/protein1.psf" (string)
 CNSsolve>  structure 
 STRUcture>    @@$psf_infile_$nchain1 
 ASSFIL: file protein1.psf opened.
 STRUcture>data_cns_mtf 
 REMARKS FILENAME="protein1.psf"
 REMARKS peptide link removed (applied DPEP): from      38   to      43
 REMARKS coordinates built for more than 100 hundred atoms
 REMARKS DATE:29-Dec-2019  00:14:40       created by user: enmr
 REMARKS VERSION:1.3U
 Status of internal molecular topology database:
 -> NATOM=       2865(MAXA=     1000000)  NBOND=       2925(MAXB=     1000000)
 -> NTHETA=      4200(MAXT=     2000000)  NGRP=         294(MAXGRP=   1000000)
 -> NPHI=        7057(MAXP=     2000000)  NIMPHI=      1463(MAXIMP=   1000000)
 -> NNB=          180(MAXNB=    1000000) 
 STRUcture> 
 STRUcture>  end 
 CNSsolve>end loop cloop1 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop cloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>  evaluate($coor_infile_$nchain1= "RUN:begin/" + $Toppar.prot_root_$nchain1 + ".pdb") 
 EVALUATE: symbol $COOR_INFILE_2 set to "RUN:begin/protein2.pdb" (string)
 CNSsolve>  evaluate($psf_infile_$nchain1= "RUN:begin/" + $Toppar.prot_root_$nchain1 + ".psf") 
 EVALUATE: symbol $PSF_INFILE_2 set to "RUN:begin/protein2.psf" (string)
 CNSsolve>  structure 
 STRUcture>    @@$psf_infile_$nchain1 
 ASSFIL: file protein2.psf opened.
 STRUcture>data_cns_mtf 
 REMARKS FILENAME="protein2.psf"
 REMARKS coordinates built for atom:      4SP  1    HAE
 REMARKS coordinates built for atom:      4SP  1    HAD
 REMARKS coordinates built for atom:      4SP  1    HAB
 REMARKS coordinates built for atom:      4SP  1    HAC
 REMARKS coordinates built for atom:      4SP  1    HAA
 REMARKS DATE:29-Dec-2019  00:14:41       created by user: enmr
 REMARKS VERSION:1.3U
 Status of internal molecular topology database:
 -> NATOM=       2898(MAXA=     1000000)  NBOND=       2961(MAXB=     1000000)
 -> NTHETA=      4254(MAXT=     2000000)  NGRP=         295(MAXGRP=   1000000)
 -> NPHI=        7070(MAXP=     2000000)  NIMPHI=      1491(MAXIMP=   1000000)
 -> NNB=          180(MAXNB=    1000000) 
 STRUcture> 
 STRUcture>  end 
 CNSsolve>end loop cloop1 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop cloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>  eval($nchain1 = $nchain1 + 1) 
 CNSsolve>  evaluate($coor_infile_$nchain1= "RUN:begin/" + $Toppar.prot_root_$nchain1 + ".pdb") 
 CNSsolve>  evaluate($psf_infile_$nchain1= "RUN:begin/" + $Toppar.prot_root_$nchain1 + ".psf") 
 CNSsolve>  structure 
 CNSsolve>    @@$psf_infile_$nchain1 
 CNSsolve>  end 
 CNSsolve>end loop cloop1 
 CNSsolve> 
 CNSsolve>evaluate ($nfa = 0) 
 EVALUATE: symbol $NFA set to    0.00000     (real)
 CNSsolve>evaluate ($nstruc = 1) 
 EVALUATE: symbol $NSTRUC set to    1.00000     (real)
 CNSsolve>for $fileA in ( @@RUN:begin/file_A.list ) loop Acoor 
 ASSFIL: file file_A.list opened.
 FOR-clause="RUN:begin/protein1_1.pdb" 
 FOR LOOP: symbol FILEA set to "RUN:begin/protein1_1.pdb" (string)
 FOR-clause= ) loop Acoor 
 CNSsolve> evaluate ($filename = $fileA) 
 EVALUATE: symbol $FILENAME set to "RUN:begin/protein1_1.pdb" (string)
 CNSsolve> evaluate ($nfa = $nfa + 1) 
 EVALUATE: symbol $NFA set to    1.00000     (real)
 CNSsolve> coor @@$filename 
 ASSFIL: file protein1_1.pdb opened.
 COOR>REMARK FILENAME="protein1_1.pdb" 
 COOR>REMARK peptide link removed (applied DPEP): from      38   to      43 
 COOR>REMARK coordinates built for more than 100 hundred atoms 
 COOR>REMARK DATE:29-Dec-2019  00:14:40       created by user: enmr 
 COOR>REMARK VERSION:1.3U 
 COOR>ATOM      1  N   SER     1      17.157   8.861  35.845  1.00 15.00      A 
 COOR>ATOM      2  HN  SER     1      17.213   7.905  35.637  0.00 15.00      A 
 %READC-WRN: still     33 missing coordinates (in selected subset)
 CNSsolve> 
 CNSsolve> if ($data.ncomponents>1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nfb = 0) 
 EVALUATE: symbol $NFB set to    0.00000     (real)
 CNSsolve>  for $fileB in ( @@RUN:begin/file_B.list ) loop Bcoor 
 ASSFIL: file file_B.list opened.
 FOR-clause="RUN:begin/protein2_1.pdb" 
 FOR LOOP: symbol FILEB set to "RUN:begin/protein2_1.pdb" (string)
 FOR-clause= ) loop Bcoor 
 CNSsolve>    evaluate ($filename = $fileB) 
 EVALUATE: symbol $FILENAME set to "RUN:begin/protein2_1.pdb" (string)
 CNSsolve>    evaluate ($combine_structures = true) 
 EVALUATE: symbol $COMBINE_STRUCTURES set to TRUE (logical)
 CNSsolve>    evaluate ($nfb = $nfb + 1) 
 EVALUATE: symbol $NFB set to    1.00000     (real)
 CNSsolve>    if ($saprotocol.crossdock eq false) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      if ($nfb # $nfa) then 
 NEXTCD: condition evaluated as false
 CNSsolve>        evaluate ($combine_structures = false) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>    if ($combine_structures eq true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    coor @@$filename 
 ASSFIL: file protein2_1.pdb opened.
 COOR>REMARK FILENAME="protein2_1.pdb" 
 COOR>REMARK coordinates built for atom:      4SP  1    HAE 
 COOR>REMARK coordinates built for atom:      4SP  1    HAD 
 COOR>REMARK coordinates built for atom:      4SP  1    HAB 
 COOR>REMARK coordinates built for atom:      4SP  1    HAC 
 COOR>REMARK coordinates built for atom:      4SP  1    HAA 
 COOR>REMARK DATE:29-Dec-2019  00:14:41       created by user: enmr 
 COOR>REMARK VERSION:1.3U 
 COOR>ATOM      1  C12 4SP     1       7.557  24.629  20.442  1.00 15.00      B 
 COOR>ATOM      2  C13 4SP     1       6.545  24.085  19.436  1.00 15.00      B 
 CNSsolve>    if ($data.ncomponents>2) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($nfc = 0) 
 CNSsolve>      for $fileC in ( @@RUN:begin/file_C.list ) loop Ccoor 
 CNSsolve>        evaluate ($filename = $fileC) 
 CNSsolve>        evaluate ($combine_structures = true) 
 CNSsolve>        evaluate ($nfc = $nfc + 1) 
 CNSsolve>        if ($saprotocol.crossdock eq false) then 
 CNSsolve>          if ($nfc # $nfa) then 
 CNSsolve>            evaluate ($combine_structures = false) 
 CNSsolve>          end if 
 CNSsolve>        end if 
 CNSsolve>        if ($combine_structures eq true) then 
 CNSsolve>        coor @@$filename 
 CNSsolve>        if ($data.ncomponents>3) then 
 CNSsolve>          evaluate ($nfd = 0) 
 CNSsolve>          for $fileD in ( @@RUN:begin/file_D.list ) loop Dcoor 
 CNSsolve>            evaluate ($filename = $fileD) 
 CNSsolve>            evaluate ($combine_structures = true) 
 CNSsolve>            evaluate ($nfd = $nfd + 1) 
 CNSsolve>            if ($saprotocol.crossdock eq false) then 
 CNSsolve>              if ($nfd # $nfa) then 
 CNSsolve>                evaluate ($combine_structures = false) 
 CNSsolve>              end if 
 CNSsolve>            end if 
 CNSsolve>            if ($combine_structures eq true) then 
 CNSsolve>            coor @@$filename 
 CNSsolve>            if ($data.ncomponents>4) then 
 CNSsolve>              evaluate ($nfe = 0) 
 CNSsolve>              for $fileE in ( @@RUN:begin/file_E.list ) loop Ecoor 
 CNSsolve>                evaluate ($filename = $fileE) 
 CNSsolve>                evaluate ($combine_structures = true) 
 CNSsolve>                evaluate ($nfe = $nfe + 1) 
 CNSsolve>                if ($saprotocol.crossdock eq false) then 
 CNSsolve>                  if ($nfe # $nfa) then 
 CNSsolve>                    evaluate ($combine_structures = false) 
 CNSsolve>                  end if 
 CNSsolve>                end if 
 CNSsolve>                if ($combine_structures eq true) then 
 CNSsolve>                coor @@$filename 
 CNSsolve>                if ($data.ncomponents>5) then 
 CNSsolve>                  evaluate ($nff = 0) 
 CNSsolve>                  for $fileF in ( @@RUN:begin/file_F.list ) loop Fcoor 
 CNSsolve>                    evaluate ($filename = $fileF) 
 CNSsolve>                    evaluate ($combine_structures = true) 
 CNSsolve>                    evaluate ($nff = $nff + 1) 
 CNSsolve>                    if ($saprotocol.crossdock eq false) then 
 CNSsolve>                      if ($nff # $nfa) then 
 CNSsolve>                        evaluate ($combine_structures = false) 
 CNSsolve>                      end if 
 CNSsolve>                    end if 
 CNSsolve>                    if ($combine_structures eq true) then 
 CNSsolve>                    coor @@$filename 
 CNSsolve>		    if ($saprotocol.randorien eq true) then 
 CNSsolve>                      @RUN:protocols/separate.cns(Data=$Data; Toppar=$Toppar) 
 ASSFIL: file separate.cns opened.
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve>!		    else 
 CNSsolve>!                      do (store9=0) (all) 
 CNSsolve>!                      do (store9=1) (attr q=0.0) 
 CNSsolve>!                      @@RUN:protocols/rebuild-unknown.cns 
 CNSsolve>		    end if 
 CNSsolve>                    evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>		    do (q=1) (all) 
 CNSsolve>		    do (b=10) (all) 
 CNSsolve>                    write coor output=$coorfile_$nstruc end 
 CNSsolve>                    evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>                    if ($nstruc > 4000) then 
 CNSsolve>                      display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>                      display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>                      display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>                      display          NOW STOPPING 
 CNSsolve>                      stop 
 CNSsolve>                    end if 
 CNSsolve>                  end if 
 CNSsolve>                  end loop Fcoor 
 CNSsolve>		else 
 CNSsolve>		  if ($saprotocol.randorien eq true) then 
 CNSsolve>		    @RUN:protocols/separate.cns(Data=$Data; Toppar=$Toppar) 
 ASSFIL: file separate.cns opened.
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve>!		  else 
 CNSsolve>!                    do (store9=0) (all) 
 CNSsolve>!                    do (store9=1) (attr q=0.0) 
 CNSsolve>!                    @@RUN:protocols/rebuild-unknown.cns 
 CNSsolve>                  end if 
 CNSsolve>                  evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>		  do (q=1) (all) 
 CNSsolve>		  do (b=10) (all) 
 CNSsolve>                  write coor output=$coorfile_$nstruc end 
 CNSsolve>                  evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>                  if ($nstruc > 4000) then 
 CNSsolve>                    display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>                    display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>                    display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>                    display          NOW STOPPING 
 CNSsolve>                    stop 
 CNSsolve>                  end if 
 CNSsolve>                end if 
 CNSsolve>              end if 
 CNSsolve>              end loop Ecoor 
 CNSsolve>	    else 
 CNSsolve>	      if ($saprotocol.randorien eq true) then 
 CNSsolve>	        @RUN:protocols/separate.cns(Data=$Data; Toppar=$Toppar) 
 ASSFIL: file separate.cns opened.
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve>!              else 
 CNSsolve>!                do (store9=0) (all) 
 CNSsolve>!                do (store9=1) (attr q=0.0) 
 CNSsolve>!                @@RUN:protocols/rebuild-unknown.cns 
 CNSsolve>	      end if 
 CNSsolve>              evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>	      do (q=1) (all) 
 CNSsolve>	      do (b=10) (all) 
 CNSsolve>              write coor output=$coorfile_$nstruc end 
 CNSsolve>              evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>                if ($nstruc > 4000) then 
 CNSsolve>                display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>                display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>                display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>                display          NOW STOPPING 
 CNSsolve>                stop 
 CNSsolve>              end if 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve>          end loop Dcoor 
 CNSsolve>	else 
 CNSsolve>	  if ($saprotocol.randorien eq true) then 
 CNSsolve>	    @RUN:protocols/separate.cns(Data=$Data; Toppar=$Toppar) 
 ASSFIL: file separate.cns opened.
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve>!	  else 
 CNSsolve>!            do (store9=0) (all) 
 CNSsolve>!            do (store9=1) (attr q=0.0) 
 CNSsolve>!            @@RUN:protocols/rebuild-unknown.cns 
 CNSsolve>	  end if 
 CNSsolve>          evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>	  do (q=1) (all) 
 CNSsolve>	  do (b=10) (all) 
 CNSsolve>          write coor output=$coorfile_$nstruc end 
 CNSsolve>          evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>          if ($nstruc > 4000) then 
 CNSsolve>            display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>            display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>            display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>            display          NOW STOPPING 
 CNSsolve>            stop 
 CNSsolve>          end if 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve>      end loop Ccoor 
 CNSsolve>    else 
 CNSsolve>      if ($saprotocol.randorien eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>        @RUN:protocols/separate.cns(Data=$Data; Toppar=$Toppar) 
 ASSFIL: file separate.cns opened.
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve>!      else 
 CNSsolve>!        do (store9=0) (all) 
 CNSsolve>!        do (store9=1) (attr q=0.0) 
 CNSsolve>!        @RUN:protocols/rebuild-unknown.cns 
 CNSsolve>      end if 
 CNSsolve>      evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 EVALUATE: symbol $COORFILE_1 set to "RUN:begin/complex_1.pdb" (string)
 CNSsolve>      do (q=1) (all) 
 SELRPN:   2898 atoms have been selected out of   2898
 CNSsolve>      do (b=10) (all) 
 SELRPN:   2898 atoms have been selected out of   2898
 CNSsolve>      write coor output=$coorfile_$nstruc end 
 ASSFIL: file complex_1.pdb opened.
 CNSsolve>      evaluate ($nstruc = $nstruc + 1) 
 EVALUATE: symbol $NSTRUC set to    2.00000     (real)
 CNSsolve>      if ($nstruc > 4000) then 
 NEXTCD: condition evaluated as false
 CNSsolve>        display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>        display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>        display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>        display          NOW STOPPING 
 CNSsolve>        stop 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  end loop Bcoor 
 CNSsolve>  for $fileB in ( @@RUN:begin/file_B.list ) loop Bcoor 
 ASSFIL: file file_B.list opened.
 FOR-clause="RUN:begin/protein2_1.pdb" 
 FOR-clause ) loop Bcoor 
 CNSsolve>    evaluate ($filename = $fileB) 
 CNSsolve>    evaluate ($combine_structures = true) 
 CNSsolve>    evaluate ($nfb = $nfb + 1) 
 CNSsolve>    if ($saprotocol.crossdock eq false) then 
 CNSsolve>      if ($nfb # $nfa) then 
 CNSsolve>        evaluate ($combine_structures = false) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>    if ($combine_structures eq true) then 
 CNSsolve>    coor @@$filename 
 CNSsolve>    if ($data.ncomponents>2) then 
 CNSsolve>      evaluate ($nfc = 0) 
 CNSsolve>      for $fileC in ( @@RUN:begin/file_C.list ) loop Ccoor 
 CNSsolve>        evaluate ($filename = $fileC) 
 CNSsolve>        evaluate ($combine_structures = true) 
 CNSsolve>        evaluate ($nfc = $nfc + 1) 
 CNSsolve>        if ($saprotocol.crossdock eq false) then 
 CNSsolve>          if ($nfc # $nfa) then 
 CNSsolve>            evaluate ($combine_structures = false) 
 CNSsolve>          end if 
 CNSsolve>        end if 
 CNSsolve>        if ($combine_structures eq true) then 
 CNSsolve>        coor @@$filename 
 CNSsolve>        if ($data.ncomponents>3) then 
 CNSsolve>          evaluate ($nfd = 0) 
 CNSsolve>          for $fileD in ( @@RUN:begin/file_D.list ) loop Dcoor 
 CNSsolve>            evaluate ($filename = $fileD) 
 CNSsolve>            evaluate ($combine_structures = true) 
 CNSsolve>            evaluate ($nfd = $nfd + 1) 
 CNSsolve>            if ($saprotocol.crossdock eq false) then 
 CNSsolve>              if ($nfd # $nfa) then 
 CNSsolve>                evaluate ($combine_structures = false) 
 CNSsolve>              end if 
 CNSsolve>            end if 
 CNSsolve>            if ($combine_structures eq true) then 
 CNSsolve>            coor @@$filename 
 CNSsolve>            if ($data.ncomponents>4) then 
 CNSsolve>              evaluate ($nfe = 0) 
 CNSsolve>              for $fileE in ( @@RUN:begin/file_E.list ) loop Ecoor 
 CNSsolve>                evaluate ($filename = $fileE) 
 CNSsolve>                evaluate ($combine_structures = true) 
 CNSsolve>                evaluate ($nfe = $nfe + 1) 
 CNSsolve>                if ($saprotocol.crossdock eq false) then 
 CNSsolve>                  if ($nfe # $nfa) then 
 CNSsolve>                    evaluate ($combine_structures = false) 
 CNSsolve>                  end if 
 CNSsolve>                end if 
 CNSsolve>                if ($combine_structures eq true) then 
 CNSsolve>                coor @@$filename 
 CNSsolve>                if ($data.ncomponents>5) then 
 CNSsolve>                  evaluate ($nff = 0) 
 CNSsolve>                  for $fileF in ( @@RUN:begin/file_F.list ) loop Fcoor 
 CNSsolve>                    evaluate ($filename = $fileF) 
 CNSsolve>                    evaluate ($combine_structures = true) 
 CNSsolve>                    evaluate ($nff = $nff + 1) 
 CNSsolve>                    if ($saprotocol.crossdock eq false) then 
 CNSsolve>                      if ($nff # $nfa) then 
 CNSsolve>                        evaluate ($combine_structures = false) 
 CNSsolve>                      end if 
 CNSsolve>                    end if 
 CNSsolve>                    if ($combine_structures eq true) then 
 CNSsolve>                    coor @@$filename 
 CNSsolve>		    if ($saprotocol.randorien eq true) then 
 CNSsolve>                       
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve>(Data=$Data; Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!		    else 
 CNSsolve>!                      do (store9=0) (all) 
 CNSsolve>!                      do (store9=1) (attr q=0.0) 
 CNSsolve>!                      @@RUN:protocols/rebuild-unknown.cns 
 CNSsolve>		    end if 
 CNSsolve>                    evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>		    do (q=1) (all) 
 CNSsolve>		    do (b=10) (all) 
 CNSsolve>                    write coor output=$coorfile_$nstruc end 
 CNSsolve>                    evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>                    if ($nstruc > 4000) then 
 CNSsolve>                      display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>                      display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>                      display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>                      display          NOW STOPPING 
 CNSsolve>                      stop 
 CNSsolve>                    end if 
 CNSsolve>                  end if 
 CNSsolve>                  end loop Fcoor 
 CNSsolve>		else 
 CNSsolve>		  if ($saprotocol.randorien eq true) then 
 CNSsolve>		     
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve>(Data=$Data; Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!		  else 
 CNSsolve>!                    do (store9=0) (all) 
 CNSsolve>!                    do (store9=1) (attr q=0.0) 
 CNSsolve>!                    @@RUN:protocols/rebuild-unknown.cns 
 CNSsolve>                  end if 
 CNSsolve>                  evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>		  do (q=1) (all) 
 CNSsolve>		  do (b=10) (all) 
 CNSsolve>                  write coor output=$coorfile_$nstruc end 
 CNSsolve>                  evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>                  if ($nstruc > 4000) then 
 CNSsolve>                    display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>                    display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>                    display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>                    display          NOW STOPPING 
 CNSsolve>                    stop 
 CNSsolve>                  end if 
 CNSsolve>                end if 
 CNSsolve>              end if 
 CNSsolve>              end loop Ecoor 
 CNSsolve>	    else 
 CNSsolve>	      if ($saprotocol.randorien eq true) then 
 CNSsolve>	         
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve>(Data=$Data; Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!              else 
 CNSsolve>!                do (store9=0) (all) 
 CNSsolve>!                do (store9=1) (attr q=0.0) 
 CNSsolve>!                @@RUN:protocols/rebuild-unknown.cns 
 CNSsolve>	      end if 
 CNSsolve>              evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>	      do (q=1) (all) 
 CNSsolve>	      do (b=10) (all) 
 CNSsolve>              write coor output=$coorfile_$nstruc end 
 CNSsolve>              evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>                if ($nstruc > 4000) then 
 CNSsolve>                display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>                display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>                display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>                display          NOW STOPPING 
 CNSsolve>                stop 
 CNSsolve>              end if 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve>          end loop Dcoor 
 CNSsolve>	else 
 CNSsolve>	  if ($saprotocol.randorien eq true) then 
 CNSsolve>	     
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve>(Data=$Data; Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!	  else 
 CNSsolve>!            do (store9=0) (all) 
 CNSsolve>!            do (store9=1) (attr q=0.0) 
 CNSsolve>!            @@RUN:protocols/rebuild-unknown.cns 
 CNSsolve>	  end if 
 CNSsolve>          evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>	  do (q=1) (all) 
 CNSsolve>	  do (b=10) (all) 
 CNSsolve>          write coor output=$coorfile_$nstruc end 
 CNSsolve>          evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>          if ($nstruc > 4000) then 
 CNSsolve>            display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>            display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>            display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>            display          NOW STOPPING 
 CNSsolve>            stop 
 CNSsolve>          end if 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve>      end loop Ccoor 
 CNSsolve>    else 
 CNSsolve>      if ($saprotocol.randorien eq true) then 
 CNSsolve>         
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve>(Data=$Data; Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!      else 
 CNSsolve>!        do (store9=0) (all) 
 CNSsolve>!        do (store9=1) (attr q=0.0) 
 CNSsolve>!        @RUN:protocols/rebuild-unknown.cns 
 CNSsolve>      end if 
 CNSsolve>      evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>      do (q=1) (all) 
 CNSsolve>      do (b=10) (all) 
 CNSsolve>      write coor output=$coorfile_$nstruc end 
 CNSsolve>      evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>      if ($nstruc > 4000) then 
 CNSsolve>        display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>        display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>        display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>        display          NOW STOPPING 
 CNSsolve>        stop 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  end loop Bcoor 
 CNSsolve> else 
 CNSsolve>  if ($saprotocol.randorien eq true) then 
 CNSsolve>    @RUN:protocols/separate.cns(Data=$Data; Toppar=$Toppar) 
 ASSFIL: file separate.cns opened.
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve>!  else 
 CNSsolve>!    do (store9=0) (all) 
 CNSsolve>!    do (store9=1) (attr q=0.0) 
 CNSsolve>!    @@RUN:protocols/rebuild-unknown.cns 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>  do (q=1) (all) 
 CNSsolve>  do (b=10) (all) 
 CNSsolve>  write coor output=$coorfile_$nstruc end 
 CNSsolve>  evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>  if ($nstruc > 4000) then 
 CNSsolve>    display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>    display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>    display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>    display          NOW STOPPING 
 CNSsolve>    stop 
 CNSsolve>  end if 
 CNSsolve> end if 
 CNSsolve>end loop Acoor 
 CNSsolve>for $fileA in ( @@RUN:begin/file_A.list ) loop Acoor 
 ASSFIL: file file_A.list opened.
 FOR-clause="RUN:begin/protein1_1.pdb" 
 FOR-clause ) loop Acoor 
 CNSsolve> evaluate ($filename = $fileA) 
 CNSsolve> evaluate ($nfa = $nfa + 1) 
 CNSsolve> coor @@$filename 
 CNSsolve> 
 CNSsolve> if ($data.ncomponents>1) then 
 CNSsolve>  evaluate ($nfb = 0) 
 CNSsolve>  for $fileB in ( @@RUN:begin/file_B.list ) loop Bcoor 
 CNSsolve>    evaluate ($filename = $fileB) 
 CNSsolve>    evaluate ($combine_structures = true) 
 CNSsolve>    evaluate ($nfb = $nfb + 1) 
 CNSsolve>    if ($saprotocol.crossdock eq false) then 
 CNSsolve>      if ($nfb # $nfa) then 
 CNSsolve>        evaluate ($combine_structures = false) 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>    if ($combine_structures eq true) then 
 CNSsolve>    coor @@$filename 
 CNSsolve>    if ($data.ncomponents>2) then 
 CNSsolve>      evaluate ($nfc = 0) 
 CNSsolve>      for $fileC in ( @@RUN:begin/file_C.list ) loop Ccoor 
 CNSsolve>        evaluate ($filename = $fileC) 
 CNSsolve>        evaluate ($combine_structures = true) 
 CNSsolve>        evaluate ($nfc = $nfc + 1) 
 CNSsolve>        if ($saprotocol.crossdock eq false) then 
 CNSsolve>          if ($nfc # $nfa) then 
 CNSsolve>            evaluate ($combine_structures = false) 
 CNSsolve>          end if 
 CNSsolve>        end if 
 CNSsolve>        if ($combine_structures eq true) then 
 CNSsolve>        coor @@$filename 
 CNSsolve>        if ($data.ncomponents>3) then 
 CNSsolve>          evaluate ($nfd = 0) 
 CNSsolve>          for $fileD in ( @@RUN:begin/file_D.list ) loop Dcoor 
 CNSsolve>            evaluate ($filename = $fileD) 
 CNSsolve>            evaluate ($combine_structures = true) 
 CNSsolve>            evaluate ($nfd = $nfd + 1) 
 CNSsolve>            if ($saprotocol.crossdock eq false) then 
 CNSsolve>              if ($nfd # $nfa) then 
 CNSsolve>                evaluate ($combine_structures = false) 
 CNSsolve>              end if 
 CNSsolve>            end if 
 CNSsolve>            if ($combine_structures eq true) then 
 CNSsolve>            coor @@$filename 
 CNSsolve>            if ($data.ncomponents>4) then 
 CNSsolve>              evaluate ($nfe = 0) 
 CNSsolve>              for $fileE in ( @@RUN:begin/file_E.list ) loop Ecoor 
 CNSsolve>                evaluate ($filename = $fileE) 
 CNSsolve>                evaluate ($combine_structures = true) 
 CNSsolve>                evaluate ($nfe = $nfe + 1) 
 CNSsolve>                if ($saprotocol.crossdock eq false) then 
 CNSsolve>                  if ($nfe # $nfa) then 
 CNSsolve>                    evaluate ($combine_structures = false) 
 CNSsolve>                  end if 
 CNSsolve>                end if 
 CNSsolve>                if ($combine_structures eq true) then 
 CNSsolve>                coor @@$filename 
 CNSsolve>                if ($data.ncomponents>5) then 
 CNSsolve>                  evaluate ($nff = 0) 
 CNSsolve>                  for $fileF in ( @@RUN:begin/file_F.list ) loop Fcoor 
 CNSsolve>                    evaluate ($filename = $fileF) 
 CNSsolve>                    evaluate ($combine_structures = true) 
 CNSsolve>                    evaluate ($nff = $nff + 1) 
 CNSsolve>                    if ($saprotocol.crossdock eq false) then 
 CNSsolve>                      if ($nff # $nfa) then 
 CNSsolve>                        evaluate ($combine_structures = false) 
 CNSsolve>                      end if 
 CNSsolve>                    end if 
 CNSsolve>                    if ($combine_structures eq true) then 
 CNSsolve>                    coor @@$filename 
 CNSsolve>		    if ($saprotocol.randorien eq true) then 
 CNSsolve>                       
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve>(Data=$Data; Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!		    else 
 CNSsolve>!                      do (store9=0) (all) 
 CNSsolve>!                      do (store9=1) (attr q=0.0) 
 CNSsolve>!                      @@RUN:protocols/rebuild-unknown.cns 
 CNSsolve>		    end if 
 CNSsolve>                    evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>		    do (q=1) (all) 
 CNSsolve>		    do (b=10) (all) 
 CNSsolve>                    write coor output=$coorfile_$nstruc end 
 CNSsolve>                    evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>                    if ($nstruc > 4000) then 
 CNSsolve>                      display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>                      display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>                      display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>                      display          NOW STOPPING 
 CNSsolve>                      stop 
 CNSsolve>                    end if 
 CNSsolve>                  end if 
 CNSsolve>                  end loop Fcoor 
 CNSsolve>		else 
 CNSsolve>		  if ($saprotocol.randorien eq true) then 
 CNSsolve>		     
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve>(Data=$Data; Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!		  else 
 CNSsolve>!                    do (store9=0) (all) 
 CNSsolve>!                    do (store9=1) (attr q=0.0) 
 CNSsolve>!                    @@RUN:protocols/rebuild-unknown.cns 
 CNSsolve>                  end if 
 CNSsolve>                  evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>		  do (q=1) (all) 
 CNSsolve>		  do (b=10) (all) 
 CNSsolve>                  write coor output=$coorfile_$nstruc end 
 CNSsolve>                  evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>                  if ($nstruc > 4000) then 
 CNSsolve>                    display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>                    display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>                    display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>                    display          NOW STOPPING 
 CNSsolve>                    stop 
 CNSsolve>                  end if 
 CNSsolve>                end if 
 CNSsolve>              end if 
 CNSsolve>              end loop Ecoor 
 CNSsolve>	    else 
 CNSsolve>	      if ($saprotocol.randorien eq true) then 
 CNSsolve>	         
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve>(Data=$Data; Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!              else 
 CNSsolve>!                do (store9=0) (all) 
 CNSsolve>!                do (store9=1) (attr q=0.0) 
 CNSsolve>!                @@RUN:protocols/rebuild-unknown.cns 
 CNSsolve>	      end if 
 CNSsolve>              evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>	      do (q=1) (all) 
 CNSsolve>	      do (b=10) (all) 
 CNSsolve>              write coor output=$coorfile_$nstruc end 
 CNSsolve>              evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>                if ($nstruc > 4000) then 
 CNSsolve>                display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>                display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>                display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>                display          NOW STOPPING 
 CNSsolve>                stop 
 CNSsolve>              end if 
 CNSsolve>            end if 
 CNSsolve>          end if 
 CNSsolve>          end loop Dcoor 
 CNSsolve>	else 
 CNSsolve>	  if ($saprotocol.randorien eq true) then 
 CNSsolve>	     
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve>(Data=$Data; Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!	  else 
 CNSsolve>!            do (store9=0) (all) 
 CNSsolve>!            do (store9=1) (attr q=0.0) 
 CNSsolve>!            @@RUN:protocols/rebuild-unknown.cns 
 CNSsolve>	  end if 
 CNSsolve>          evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>	  do (q=1) (all) 
 CNSsolve>	  do (b=10) (all) 
 CNSsolve>          write coor output=$coorfile_$nstruc end 
 CNSsolve>          evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>          if ($nstruc > 4000) then 
 CNSsolve>            display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>            display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>            display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>            display          NOW STOPPING 
 CNSsolve>            stop 
 CNSsolve>          end if 
 CNSsolve>        end if 
 CNSsolve>      end if 
 CNSsolve>      end loop Ccoor 
 CNSsolve>    else 
 CNSsolve>      if ($saprotocol.randorien eq true) then 
 CNSsolve>         
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve>(Data=$Data; Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!      else 
 CNSsolve>!        do (store9=0) (all) 
 CNSsolve>!        do (store9=1) (attr q=0.0) 
 CNSsolve>!        @RUN:protocols/rebuild-unknown.cns 
 CNSsolve>      end if 
 CNSsolve>      evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>      do (q=1) (all) 
 CNSsolve>      do (b=10) (all) 
 CNSsolve>      write coor output=$coorfile_$nstruc end 
 CNSsolve>      evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>      if ($nstruc > 4000) then 
 CNSsolve>        display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>        display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>        display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>        display          NOW STOPPING 
 CNSsolve>        stop 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  end loop Bcoor 
 CNSsolve> else 
 CNSsolve>  if ($saprotocol.randorien eq true) then 
 CNSsolve>     
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 CNSsolve>(Data=$Data; Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!  else 
 CNSsolve>!    do (store9=0) (all) 
 CNSsolve>!    do (store9=1) (attr q=0.0) 
 CNSsolve>!    @@RUN:protocols/rebuild-unknown.cns 
 CNSsolve>  end if 
 CNSsolve>  evaluate ($coorfile_$nstruc = "RUN:begin/" + $Filenames.fileroot + "_" + encode($nstruc) + ".pdb") 
 CNSsolve>  do (q=1) (all) 
 CNSsolve>  do (b=10) (all) 
 CNSsolve>  write coor output=$coorfile_$nstruc end 
 CNSsolve>  evaluate ($nstruc = $nstruc + 1) 
 CNSsolve>  if ($nstruc > 4000) then 
 CNSsolve>    display WARNING: THE NUMBER OF INITIAL STRUCTURES FOR DOCKING IS SET TO $maxstruc 
 CNSsolve>    display          TO AVOID FILLING UP TOO MUCH DISK SPACE 
 CNSsolve>    display          TO INCREASE IT EDIT THE generate_complex.inp SCRIPT 
 CNSsolve>    display          NOW STOPPING 
 CNSsolve>    stop 
 CNSsolve>  end if 
 CNSsolve> end if 
 CNSsolve>end loop Acoor 
 CNSsolve> 
 CNSsolve>evaluate ($structurefile = "RUN:begin/" + $Filenames.fileroot + ".psf") 
 EVALUATE: symbol $STRUCTUREFILE set to "RUN:begin/complex.psf" (string)
 CNSsolve>write structure output=$structurefile end 
 ASSFIL: file complex.psf opened.
 CNSsolve> 
 CNSsolve>stop 
 HEAP: maximum use      =     9854272 current use      =       96000 bytes
 HEAP: maximum overhead =        1040 current overhead =         752 bytes
          ============================================================
           Maximum dynamic memory allocation:     9854272 bytes
           Maximum dynamic memory overhead:          1040 bytes
           Program started at: 00:14:55 on 29-Dec-2019
           Program stopped at: 00:14:56 on 29-Dec-2019
           CPU time used:       0.4979 seconds
          ============================================================
