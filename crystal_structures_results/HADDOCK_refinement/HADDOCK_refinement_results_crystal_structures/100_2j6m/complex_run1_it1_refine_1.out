          ============================================================
          |                                                          |
          |            Crystallography & NMR System (CNS)            |
          |                         CNSsolve                         |
          |                                                          |
          ============================================================
           Version: 1.3 at patch level U
           Status: Special UU release with Rg and paramagnetic
                   restraints (A. Bonvin, UU 2011)
          ============================================================
           Written by: A.T.Brunger, P.D.Adams, G.M.Clore, W.L.DeLano,
                       P.Gros, R.W.Grosse-Kunstleve,J.-S.Jiang,J.M.Krahn,
                       J.Kuszewski, M.Nilges, N.S.Pannu, R.J.Read,
                       L.M.Rice, G.F.Schroeder, T.Simonson, G.L.Warren.
           Copyright (c) 1997-2010 Yale University
          ============================================================
           Running on machine: wn-pep-013.farm.nikhef.nl (x86_64/Linux,64-bit)
           Program started by: enmr049
           Program started at: 21:29:50 on 28-Dec-2019
          ============================================================

 FFT3C: Using FFTPACK4.1

 CNSsolve>! refine.inp 
 CNSsolve>!    The core docking script of HADDOCK performing rigid-body docking 
 CNSsolve>!    and semi-flexible refinement in torsion angle space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>@RUN:protocols/initialize.cns(iteration=$iteration;) 
 ASSFIL: file initialize.cns opened.
 CNSsolve>! initialize.cns 
 CNSsolve>!    Iteration initialization 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module (iteration;) 
 &_2_ITERATION set to $_1_ITERATION 
 CNSsolve>evaluate (&iteration = "") 
 EVALUATE: symbol $_1_ITERATION set to "" (string)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>@NEWIT:iteration.cns(iteration=$iteration;) 
 ASSFIL: file iteration.cns opened.
 CNSsolve>module ( iteration ) 
 &_2_ITERATION set to $_1_ITERATION 
 CNSsolve>evaluate (&iteration=1) 
 EVALUATE: symbol $_1_ITERATION set to    1.00000     (real)
 CNSsolve> 
 CNSsolve>@RUN:run.cns( 
 ASSFIL: file run.cns opened.
 CNSsolve>! run.cns-milou 
 CNSsolve>!    The file containing all parameters for HADDOCK 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>module( 
 MODULE-DECLARATION>iteration; 
 MODULE-DECLARATION>filenames; 
 MODULE-DECLARATION>data; 
 MODULE-DECLARATION>iterations; 
 MODULE-DECLARATION>saprotocol; 
 MODULE-DECLARATION>refine; 
 MODULE-DECLARATION>toppar; 
 MODULE-DECLARATION>analysis; 
 MODULE-DECLARATION>) 
 MODULE-INVOCATION>iteration =$iteration; 
 &_2_ITERATION set to $_1_ITERATION 
 MODULE-INVOCATION>filenames =$filenames; 
 &_2_FILENAMES set to $_1_FILENAMES 
 MODULE-INVOCATION>Data      =$Data; 
 &_2_DATA set to $_1_DATA 
 MODULE-INVOCATION>iterations=$iterations; 
 &_2_ITERATIONS set to $_1_ITERATIONS 
 MODULE-INVOCATION>saprotocol=$saprotocol; 
 &_2_SAPROTOCOL set to $_1_SAPROTOCOL 
 MODULE-INVOCATION>refine    =$refine; 
 &_2_REFINE set to $_1_REFINE 
 MODULE-INVOCATION>toppar    =$toppar; 
 &_2_TOPPAR set to $_1_TOPPAR 
 MODULE-INVOCATION>analysis  =$analysis;) 
 &_2_ANALYSIS set to $_1_ANALYSIS 
 CNSsolve>{+ File: run.cns +} 
 CNSsolve>{+ Description: this file contains all necessary information to run HADDOCK. +} 
 CNSsolve>{+ Authors: Alexandre Bonvin<br> 
 CNSsolve>Version: 2.2, Aug 22, 2012 <br><br> 
 CNSsolve>Initially adapted from ARIA of Nilges and Linge +} 
 CNSsolve>! Please cite the following references when using this protocol: 
 CNSsolve>{+ reference: Cyril Dominguez, Rolf Boelens and Alexandre M.J.J. Bonvin (2003).  HADDOCK: a protein-protein docking approach 
 CNSsolve>based on biochemical and/or biophysical information. <i>J. Am. Chem. Soc.</i> <b>125</b>, 1731-1737. 
 CNSsolve><p> 
 CNSsolve><b>When using <i>residual dipolar couplings</i> in HADDOCK cite in addition:</b><p> 
 CNSsolve><LI>A.D.J. van Dijk, D. Fushman and A.M.J.J. Bonvin (2005). Various strategies of using residual dipolar 
 CNSsolve>couplings in NMR-driven protein docking: Application to Lys48-linked di-ubiquitin and validation against 
 CNSsolve>15N-relaxation data. <EM>Proteins: Struc. Funct. & Bioinformatics</EM>, <STRONG>60</STRONG>, 367-381.</li> 
 CNSsolve><p> 
 CNSsolve><b>When using <i>diffusion anisotropy data</i> in HADDOCK cite in addition:</b><p> 
 CNSsolve><li>A.D.J. van Dijk, R. Kaptein, R. Boelens and A.M.J.J. Bonvin (2006). Combining NMR relaxation with 
 CNSsolve>chemical shift perturbation data to drive protein-protein docking. <EM>J. Biomol. NMR</EM>, 
 CNSsolve><STRONG>34</STRONG>, 237-244.</li> 
 CNSsolve><p> 
 CNSsolve><b>When using <i>solvated docking</i> in HADDOCK cite in addition:</b><p> 
 CNSsolve><li>A.D.J. van Dijk and A.M.J.J. Bonvin (2006). Solvated docking: introducing water into the modelling 
 CNSsolve>of biomolecular complexes. <EM>Bioinformatics</EM>,  <STRONG>22</STRONG> 2340-2347. 
 CNSsolve><p> 
 CNSsolve><b>When performing <i>flexible protein-DNA docking</i> using HADDOCK cite in addition:</b><p> 
 CNSsolve><li>M. van Dijk, A.D.J. van Dijk, V. Hsu, R. Boelens and  A.M.J.J. Bonvin (2006). 
 CNSsolve>Information-driven Protein-DNA Docking using HADDOCK: it is a matter of flexibility. 
 CNSsolve><EM>Nucl. Acids Res.</EM>, <STRONG>34</STRONG> 3317-3325.</li> 
 CNSsolve>+} 
 CNSsolve>{- Guidelines for using this file: 
 CNSsolve>   - all strings must be quoted by double-quotes 
 CNSsolve>   - logical variables (true/false) are not quoted 
 CNSsolve>   - do not remove any evaluate statements from the file 
 CNSsolve>   - pathnames should not exceed 80 characters -} 
 CNSsolve>{- begin block parameter definition -} define( 
 DEFINE>{======== number of molecules for docking ==================} 
 DEFINE>{* number of components *} 
 DEFINE>{===>} ncomponents=2; 
 DEFINE>{======================= filenames =========================} 
 DEFINE>{*  the name of your current project *} 
 DEFINE>{*  this will be used as name for the generated structures *} 
 DEFINE>{===>} fileroot="complex"; 
 DEFINE>{* RUN directory *} 
 DEFINE>{*  the absolute path of your current run, e.g. /home/haddock/server/run1*} 
 DEFINE>{===>} run_dir="/home/enmr/services-enmr/HADDOCK2.2/server/run/userrun000113/run1"; 
 DEFINE>{* PDB file of molecule (protein) A *} 
 DEFINE>{===>} prot_coor_A="protein1.pdb"; 
 DEFINE>{* PSF file of molecule (protein) A *} 
 DEFINE>{===>} prot_psf_A="protein1.psf"; 
 DEFINE>{* segid of molecule (protein) A *} 
 DEFINE>{===>} prot_segid_A="A"; 
 DEFINE>{* fileroot of molecule (protein) A *} 
 DEFINE>{===>} prot_root_A="protein1"; 
 DEFINE>{* Is molecule A DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_A=false; 
 DEFINE>{* PDB file of molecule (protein) B *} 
 DEFINE>{===>} prot_coor_B="protein2.pdb"; 
 DEFINE>{* PSF file of molecule (protein) B *} 
 DEFINE>{===>} prot_psf_B="protein2.psf"; 
 DEFINE>{* segid of molecule (protein) B *} 
 DEFINE>{===>} prot_segid_B="B"; 
 DEFINE>{* fileroot of molecule (protein) B *} 
 DEFINE>{===>} prot_root_B="protein2"; 
 DEFINE>{* Is molecule B DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_B=false; 
 DEFINE>{* PDB file of molecule (protein) C *} 
 DEFINE>{===>} prot_coor_C=""; 
 DEFINE>{* PSF file of molecule (protein) C *} 
 DEFINE>{===>} prot_psf_C=""; 
 DEFINE>{* segid of molecule (protein) C *} 
 DEFINE>{===>} prot_segid_C="C"; 
 DEFINE>{* fileroot of molecule (protein) C *} 
 DEFINE>{===>} prot_root_C=""; 
 DEFINE>{* Is molecule C DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_C=false; 
 DEFINE>{* PDB file of molecule (protein) D *} 
 DEFINE>{===>} prot_coor_D=""; 
 DEFINE>{* PSF file of molecule (protein) D *} 
 DEFINE>{===>} prot_psf_D=""; 
 DEFINE>{* segid of molecule (protein) D *} 
 DEFINE>{===>} prot_segid_D="D"; 
 DEFINE>{* fileroot of molecule (protein) D *} 
 DEFINE>{===>} prot_root_D=""; 
 DEFINE>{* Is molecule D DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_D=false; 
 DEFINE>{* PDB file of molecule (protein) E *} 
 DEFINE>{===>} prot_coor_E=""; 
 DEFINE>{* PSF file of molecule (protein) E *} 
 DEFINE>{===>} prot_psf_E=""; 
 DEFINE>{* segid of molecule (protein) E *} 
 DEFINE>{===>} prot_segid_E="E"; 
 DEFINE>{* fileroot of molecule (protein) E *} 
 DEFINE>{===>} prot_root_E=""; 
 DEFINE>{* Is molecule E DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_E=false; 
 DEFINE>{* PDB file of molecule (protein) F *} 
 DEFINE>{===>} prot_coor_F=""; 
 DEFINE>{* PSF file of molecule (protein) F *} 
 DEFINE>{===>} prot_psf_F=""; 
 DEFINE>{* segid of molecule (protein) F *} 
 DEFINE>{===>} prot_segid_F="F"; 
 DEFINE>{* fileroot of molecule (protein) F *} 
 DEFINE>{===>} prot_root_F=""; 
 DEFINE>{* Is molecule F DNA? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dna_F=false; 
 DEFINE>{ Atomname nomenclature } 
 DEFINE>{ set true if you have IUPAC (e.g. LEU HB2 and HB3 and not HB2 and HB1) data (e.g. from XEASY) } 
 DEFINE>{ choice: true false } 
 DEFINE>xplortodiana=false; 
 DEFINE>{* Remove non-polar hydrogens? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} delenph=true; 
 DEFINE>{* HADDOCK directory *} 
 DEFINE>{*  the absolute path of the HADDOCK program files *} 
 DEFINE>{===>} haddock_dir="/home/enmr/software/haddock2.2-grid"; 
 DEFINE>{* Logfile directory *} 
 DEFINE>{* specify a directory for the large CNS log files *} 
 DEFINE>{===>} temptrash_dir="/home/enmr/services-enmr/HADDOCK2.2/server/run/userrun000113/run1"; 
 DEFINE>{==================== histidine patches =====================} 
 DEFINE>{* Patch to change doubly protonated HIS to singly protonated histidine (HD1) *} 
 DEFINE>{* just give the residue number of the histidines for the HISD patch, set them to zero if you don't want them *} 
 DEFINE>numhisd=10; 
 DEFINE>{+ table: rows=6 "molecule (Protein) A" "molecule (Protein) B"  "molecule (Protein) C"  "molecule (Protein) D"  "molecule (Protein) E"  "molecule (Protein) F" cols=10 "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" +} 
 DEFINE>{===>} A_hisd_resid_1=109; 
 DEFINE>{===>} A_hisd_resid_2=0; 
 DEFINE>{===>} A_hisd_resid_3=0; 
 DEFINE>{===>} A_hisd_resid_4=0; 
 DEFINE>{===>} A_hisd_resid_5=0; 
 DEFINE>{===>} A_hisd_resid_6=0; 
 DEFINE>{===>} A_hisd_resid_7=0; 
 DEFINE>{===>} A_hisd_resid_8=0; 
 DEFINE>{===>} A_hisd_resid_9=0; 
 DEFINE>{===>} A_hisd_resid_10=0; 
 DEFINE>{===>} B_hisd_resid_1=0; 
 DEFINE>{===>} B_hisd_resid_2=0; 
 DEFINE>{===>} B_hisd_resid_3=0; 
 DEFINE>{===>} B_hisd_resid_4=0; 
 DEFINE>{===>} B_hisd_resid_5=0; 
 DEFINE>{===>} B_hisd_resid_6=0; 
 DEFINE>{===>} B_hisd_resid_7=0; 
 DEFINE>{===>} B_hisd_resid_8=0; 
 DEFINE>{===>} B_hisd_resid_9=0; 
 DEFINE>{===>} B_hisd_resid_10=0; 
 DEFINE>{===>} C_hisd_resid_1=0; 
 DEFINE>{===>} C_hisd_resid_2=0; 
 DEFINE>{===>} C_hisd_resid_3=0; 
 DEFINE>{===>} C_hisd_resid_4=0; 
 DEFINE>{===>} C_hisd_resid_5=0; 
 DEFINE>{===>} C_hisd_resid_6=0; 
 DEFINE>{===>} C_hisd_resid_7=0; 
 DEFINE>{===>} C_hisd_resid_8=0; 
 DEFINE>{===>} C_hisd_resid_9=0; 
 DEFINE>{===>} C_hisd_resid_10=0; 
 DEFINE>{===>} D_hisd_resid_1=0; 
 DEFINE>{===>} D_hisd_resid_2=0; 
 DEFINE>{===>} D_hisd_resid_3=0; 
 DEFINE>{===>} D_hisd_resid_4=0; 
 DEFINE>{===>} D_hisd_resid_5=0; 
 DEFINE>{===>} D_hisd_resid_6=0; 
 DEFINE>{===>} D_hisd_resid_7=0; 
 DEFINE>{===>} D_hisd_resid_8=0; 
 DEFINE>{===>} D_hisd_resid_9=0; 
 DEFINE>{===>} D_hisd_resid_10=0; 
 DEFINE>{===>} E_hisd_resid_1=0; 
 DEFINE>{===>} E_hisd_resid_2=0; 
 DEFINE>{===>} E_hisd_resid_3=0; 
 DEFINE>{===>} E_hisd_resid_4=0; 
 DEFINE>{===>} E_hisd_resid_5=0; 
 DEFINE>{===>} E_hisd_resid_6=0; 
 DEFINE>{===>} E_hisd_resid_7=0; 
 DEFINE>{===>} E_hisd_resid_8=0; 
 DEFINE>{===>} E_hisd_resid_9=0; 
 DEFINE>{===>} E_hisd_resid_10=0; 
 DEFINE>{===>} F_hisd_resid_1=0; 
 DEFINE>{===>} F_hisd_resid_2=0; 
 DEFINE>{===>} F_hisd_resid_3=0; 
 DEFINE>{===>} F_hisd_resid_4=0; 
 DEFINE>{===>} F_hisd_resid_5=0; 
 DEFINE>{===>} F_hisd_resid_6=0; 
 DEFINE>{===>} F_hisd_resid_7=0; 
 DEFINE>{===>} F_hisd_resid_8=0; 
 DEFINE>{===>} F_hisd_resid_9=0; 
 DEFINE>{===>} F_hisd_resid_10=0; 
 DEFINE>{* Patch to change doubly protonated HIS to singly protonated histidine (HE2) *} 
 DEFINE>{* just give the residue number of the histidines for the HISE patch, set them to zero if you don't want them *} 
 DEFINE>numhise=10; 
 DEFINE>{+ table: rows=6 "molecule (Protein) A" "molecule (Protein) B"  "molecule (Protein) C"  "molecule (Protein) D"  "molecule (Protein) E"  "molecule (Protein) F" cols=10 "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" +} 
 DEFINE>{===>} A_hise_resid_1=192; 
 DEFINE>{===>} A_hise_resid_2=197; 
 DEFINE>{===>} A_hise_resid_3=139; 
 DEFINE>{===>} A_hise_resid_4=77; 
 DEFINE>{===>} A_hise_resid_5=174; 
 DEFINE>{===>} A_hise_resid_6=154; 
 DEFINE>{===>} A_hise_resid_7=0; 
 DEFINE>{===>} A_hise_resid_8=0; 
 DEFINE>{===>} A_hise_resid_9=0; 
 DEFINE>{===>} A_hise_resid_10=0; 
 DEFINE>{===>} B_hise_resid_1=0; 
 DEFINE>{===>} B_hise_resid_2=0; 
 DEFINE>{===>} B_hise_resid_3=0; 
 DEFINE>{===>} B_hise_resid_4=0; 
 DEFINE>{===>} B_hise_resid_5=0; 
 DEFINE>{===>} B_hise_resid_6=0; 
 DEFINE>{===>} B_hise_resid_7=0; 
 DEFINE>{===>} B_hise_resid_8=0; 
 DEFINE>{===>} B_hise_resid_9=0; 
 DEFINE>{===>} B_hise_resid_10=0; 
 DEFINE>{===>} C_hise_resid_1=0; 
 DEFINE>{===>} C_hise_resid_2=0; 
 DEFINE>{===>} C_hise_resid_3=0; 
 DEFINE>{===>} C_hise_resid_4=0; 
 DEFINE>{===>} C_hise_resid_5=0; 
 DEFINE>{===>} C_hise_resid_6=0; 
 DEFINE>{===>} C_hise_resid_7=0; 
 DEFINE>{===>} C_hise_resid_8=0; 
 DEFINE>{===>} C_hise_resid_9=0; 
 DEFINE>{===>} C_hise_resid_10=0; 
 DEFINE>{===>} D_hise_resid_1=0; 
 DEFINE>{===>} D_hise_resid_2=0; 
 DEFINE>{===>} D_hise_resid_3=0; 
 DEFINE>{===>} D_hise_resid_4=0; 
 DEFINE>{===>} D_hise_resid_5=0; 
 DEFINE>{===>} D_hise_resid_6=0; 
 DEFINE>{===>} D_hise_resid_7=0; 
 DEFINE>{===>} D_hise_resid_8=0; 
 DEFINE>{===>} D_hise_resid_9=0; 
 DEFINE>{===>} D_hise_resid_10=0; 
 DEFINE>{===>} E_hise_resid_1=0; 
 DEFINE>{===>} E_hise_resid_2=0; 
 DEFINE>{===>} E_hise_resid_3=0; 
 DEFINE>{===>} E_hise_resid_4=0; 
 DEFINE>{===>} E_hise_resid_5=0; 
 DEFINE>{===>} E_hise_resid_6=0; 
 DEFINE>{===>} E_hise_resid_7=0; 
 DEFINE>{===>} E_hise_resid_8=0; 
 DEFINE>{===>} E_hise_resid_9=0; 
 DEFINE>{===>} E_hise_resid_10=0; 
 DEFINE>{===>} F_hise_resid_1=0; 
 DEFINE>{===>} F_hise_resid_2=0; 
 DEFINE>{===>} F_hise_resid_3=0; 
 DEFINE>{===>} F_hise_resid_4=0; 
 DEFINE>{===>} F_hise_resid_5=0; 
 DEFINE>{===>} F_hise_resid_6=0; 
 DEFINE>{===>} F_hise_resid_7=0; 
 DEFINE>{===>} F_hise_resid_8=0; 
 DEFINE>{===>} F_hise_resid_9=0; 
 DEFINE>{===>} F_hise_resid_10=0; 
 DEFINE>{========= Definition of semi-flexible interface ============} 
 DEFINE>{* Define the interface of each molecule.*} 
 DEFINE>{* Side-chains and backbone of these residues will be allowed to move during semi-flexible refinement*} 
 DEFINE>{* number of semi-flexible segments for molecule (protein) A (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_A=-1; 
 DEFINE>{* Residues of molecule (protein) A at interface *} 
 DEFINE>{+ table: rows=10 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" "segment 6" "segment 7" "segment 8" "segment 9" "segment 10" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} A_start_seg_1=""; 
 DEFINE>{===>} A_end_seg_1=""; 
 DEFINE>{===>} A_start_seg_2=""; 
 DEFINE>{===>} A_end_seg_2=""; 
 DEFINE>{===>} A_start_seg_3=""; 
 DEFINE>{===>} A_end_seg_3=""; 
 DEFINE>{===>} A_start_seg_4=""; 
 DEFINE>{===>} A_end_seg_4=""; 
 DEFINE>{===>} A_start_seg_5=""; 
 DEFINE>{===>} A_end_seg_5=""; 
 DEFINE>{===>} A_start_seg_6=""; 
 DEFINE>{===>} A_end_seg_6=""; 
 DEFINE>{===>} A_start_seg_7=""; 
 DEFINE>{===>} A_end_seg_7=""; 
 DEFINE>{===>} A_start_seg_8=""; 
 DEFINE>{===>} A_end_seg_8=""; 
 DEFINE>{===>} A_start_seg_9=""; 
 DEFINE>{===>} A_end_seg_9=""; 
 DEFINE>{===>} A_start_seg_10=""; 
 DEFINE>{===>} A_end_seg_10=""; 
 DEFINE>{* number of semi-flexible segments for molecule (protein) B (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_B=-1; 
 DEFINE>{* Residues of molecule (protein) B at interface *} 
 DEFINE>{+ table: rows=10 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" "segment 6" "segment 7" "segment 8" "segment 9" "segment 10" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} B_start_seg_1=""; 
 DEFINE>{===>} B_end_seg_1=""; 
 DEFINE>{===>} B_start_seg_2=""; 
 DEFINE>{===>} B_end_seg_2=""; 
 DEFINE>{===>} B_start_seg_3=""; 
 DEFINE>{===>} B_end_seg_3=""; 
 DEFINE>{===>} B_start_seg_4=""; 
 DEFINE>{===>} B_end_seg_4=""; 
 DEFINE>{===>} B_start_seg_5=""; 
 DEFINE>{===>} B_end_seg_5=""; 
 DEFINE>{===>} B_start_seg_6=""; 
 DEFINE>{===>} B_end_seg_6=""; 
 DEFINE>{===>} B_start_seg_7=""; 
 DEFINE>{===>} B_end_seg_7=""; 
 DEFINE>{===>} B_start_seg_8=""; 
 DEFINE>{===>} B_end_seg_8=""; 
 DEFINE>{===>} B_start_seg_9=""; 
 DEFINE>{===>} B_end_seg_9=""; 
 DEFINE>{===>} B_start_seg_10=""; 
 DEFINE>{===>} B_end_seg_10=""; 
 DEFINE>{* number of semi-flexible segments for molecule (protein) C (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_C=-1; 
 DEFINE>{* Residues of molecule (protein) C at interface *} 
 DEFINE>{+ table: rows=10 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" "segment 6" "segment 7" "segment 8" "segment 9" "segment 10" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} C_start_seg_1=""; 
 DEFINE>{===>} C_end_seg_1=""; 
 DEFINE>{===>} C_start_seg_2=""; 
 DEFINE>{===>} C_end_seg_2=""; 
 DEFINE>{===>} C_start_seg_3=""; 
 DEFINE>{===>} C_end_seg_3=""; 
 DEFINE>{===>} C_start_seg_4=""; 
 DEFINE>{===>} C_end_seg_4=""; 
 DEFINE>{===>} C_start_seg_5=""; 
 DEFINE>{===>} C_end_seg_5=""; 
 DEFINE>{===>} C_start_seg_6=""; 
 DEFINE>{===>} C_end_seg_6=""; 
 DEFINE>{===>} C_start_seg_7=""; 
 DEFINE>{===>} C_end_seg_7=""; 
 DEFINE>{===>} C_start_seg_8=""; 
 DEFINE>{===>} C_end_seg_8=""; 
 DEFINE>{===>} C_start_seg_9=""; 
 DEFINE>{===>} C_end_seg_9=""; 
 DEFINE>{===>} C_start_seg_10=""; 
 DEFINE>{===>} C_end_seg_10=""; 
 DEFINE>{* number of semi-flexible segments for molecule (protein) D (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_D=-1; 
 DEFINE>{* Residues of molecule (protein) D at interface *} 
 DEFINE>{+ table: rows=10 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" "segment 6" "segment 7" "segment 8" "segment 9" "segment 10" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} D_start_seg_1=""; 
 DEFINE>{===>} D_end_seg_1=""; 
 DEFINE>{===>} D_start_seg_2=""; 
 DEFINE>{===>} D_end_seg_2=""; 
 DEFINE>{===>} D_start_seg_3=""; 
 DEFINE>{===>} D_end_seg_3=""; 
 DEFINE>{===>} D_start_seg_4=""; 
 DEFINE>{===>} D_end_seg_4=""; 
 DEFINE>{===>} D_start_seg_5=""; 
 DEFINE>{===>} D_end_seg_5=""; 
 DEFINE>{===>} D_start_seg_6=""; 
 DEFINE>{===>} D_end_seg_6=""; 
 DEFINE>{===>} D_start_seg_7=""; 
 DEFINE>{===>} D_end_seg_7=""; 
 DEFINE>{===>} D_start_seg_8=""; 
 DEFINE>{===>} D_end_seg_8=""; 
 DEFINE>{===>} D_start_seg_9=""; 
 DEFINE>{===>} D_end_seg_9=""; 
 DEFINE>{===>} D_start_seg_10=""; 
 DEFINE>{===>} D_end_seg_10=""; 
 DEFINE>{* number of semi-flexible segments for molecule (protein) E (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_E=-1; 
 DEFINE>{* Residues of molecule (protein) E at interface *} 
 DEFINE>{+ table: rows=10 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" "segment 6" "segment 7" "segment 8" "segment 9" "segment 10" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} E_start_seg_1=""; 
 DEFINE>{===>} E_end_seg_1=""; 
 DEFINE>{===>} E_start_seg_2=""; 
 DEFINE>{===>} E_end_seg_2=""; 
 DEFINE>{===>} E_start_seg_3=""; 
 DEFINE>{===>} E_end_seg_3=""; 
 DEFINE>{===>} E_start_seg_4=""; 
 DEFINE>{===>} E_end_seg_4=""; 
 DEFINE>{===>} E_start_seg_5=""; 
 DEFINE>{===>} E_end_seg_5=""; 
 DEFINE>{===>} E_start_seg_6=""; 
 DEFINE>{===>} E_end_seg_6=""; 
 DEFINE>{===>} E_start_seg_7=""; 
 DEFINE>{===>} E_end_seg_7=""; 
 DEFINE>{===>} E_start_seg_8=""; 
 DEFINE>{===>} E_end_seg_8=""; 
 DEFINE>{===>} E_start_seg_9=""; 
 DEFINE>{===>} E_end_seg_9=""; 
 DEFINE>{===>} E_start_seg_10=""; 
 DEFINE>{===>} E_end_seg_10=""; 
 DEFINE>{* number of semi-flexible segments for molecule (protein) F (-1 for automated mode) *} 
 DEFINE>{* Note that current max is 10 (edit the run.cns to add more segments *} 
 DEFINE>{===>} nseg_F=-1; 
 DEFINE>{* Residues of molecule (protein) F at interface *} 
 DEFINE>{+ table: rows=10 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" "segment 6" "segment 7" "segment 8" "segment 9" "segment 10" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} F_start_seg_1=""; 
 DEFINE>{===>} F_end_seg_1=""; 
 DEFINE>{===>} F_start_seg_2=""; 
 DEFINE>{===>} F_end_seg_2=""; 
 DEFINE>{===>} F_start_seg_3=""; 
 DEFINE>{===>} F_end_seg_3=""; 
 DEFINE>{===>} F_start_seg_4=""; 
 DEFINE>{===>} F_end_seg_4=""; 
 DEFINE>{===>} F_start_seg_5=""; 
 DEFINE>{===>} F_end_seg_5=""; 
 DEFINE>{===>} F_start_seg_6=""; 
 DEFINE>{===>} F_end_seg_6=""; 
 DEFINE>{===>} F_start_seg_7=""; 
 DEFINE>{===>} F_end_seg_7=""; 
 DEFINE>{===>} F_start_seg_8=""; 
 DEFINE>{===>} F_end_seg_8=""; 
 DEFINE>{===>} F_start_seg_9=""; 
 DEFINE>{===>} F_end_seg_9=""; 
 DEFINE>{===>} F_start_seg_10=""; 
 DEFINE>{===>} F_end_seg_10=""; 
 DEFINE> 
 DEFINE>{=========== Definition of fully flexible segments ==========} 
 DEFINE>{* Define the fully flexible segment of each molecule.*} 
 DEFINE>{* These segments will be allowed to move at all stages of it1 *} 
 DEFINE>{* Fully flexible segments for molecule (protein) A            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_A=0; 
 DEFINE>{* Residues of molecule (protein) A at interface *} 
 DEFINE>{+ table: rows=5 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} A_start_fle_1=""; 
 DEFINE>{===>} A_end_fle_1=""; 
 DEFINE>{===>} A_start_fle_2=""; 
 DEFINE>{===>} A_end_fle_2=""; 
 DEFINE>{===>} A_start_fle_3=""; 
 DEFINE>{===>} A_end_fle_3=""; 
 DEFINE>{===>} A_start_fle_4=""; 
 DEFINE>{===>} A_end_fle_4=""; 
 DEFINE>{===>} A_start_fle_5=""; 
 DEFINE>{===>} A_end_fle_5=""; 
 DEFINE>{* Fully flexible segments for molecule (protein) B            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_B=0; 
 DEFINE>{* Residues of molecule (protein) B at interface *} 
 DEFINE>{+ table: rows=5 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} B_start_fle_1=""; 
 DEFINE>{===>} B_end_fle_1=""; 
 DEFINE>{===>} B_start_fle_2=""; 
 DEFINE>{===>} B_end_fle_2=""; 
 DEFINE>{===>} B_start_fle_3=""; 
 DEFINE>{===>} B_end_fle_3=""; 
 DEFINE>{===>} B_start_fle_4=""; 
 DEFINE>{===>} B_end_fle_4=""; 
 DEFINE>{===>} B_start_fle_5=""; 
 DEFINE>{===>} B_end_fle_5=""; 
 DEFINE>{* Fully flexible segments for molecule (protein) C            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_C=0; 
 DEFINE>{* Residues of molecule (protein) C at interface *} 
 DEFINE>{+ table: rows=5 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} C_start_fle_1=""; 
 DEFINE>{===>} C_end_fle_1=""; 
 DEFINE>{===>} C_start_fle_2=""; 
 DEFINE>{===>} C_end_fle_2=""; 
 DEFINE>{===>} C_start_fle_3=""; 
 DEFINE>{===>} C_end_fle_3=""; 
 DEFINE>{===>} C_start_fle_4=""; 
 DEFINE>{===>} C_end_fle_4=""; 
 DEFINE>{===>} C_start_fle_5=""; 
 DEFINE>{===>} C_end_fle_5=""; 
 DEFINE>{* Fully flexible segments for molecule (protein) D            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_D=0; 
 DEFINE>{* Residues of molecule (protein) D at interface *} 
 DEFINE>{+ table: rows=5 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} D_start_fle_1=""; 
 DEFINE>{===>} D_end_fle_1=""; 
 DEFINE>{===>} D_start_fle_2=""; 
 DEFINE>{===>} D_end_fle_2=""; 
 DEFINE>{===>} D_start_fle_3=""; 
 DEFINE>{===>} D_end_fle_3=""; 
 DEFINE>{===>} D_start_fle_4=""; 
 DEFINE>{===>} D_end_fle_4=""; 
 DEFINE>{===>} D_start_fle_5=""; 
 DEFINE>{===>} D_end_fle_5=""; 
 DEFINE>{* Fully flexible segments for molecule (protein) E            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_E=0; 
 DEFINE>{* Residues of molecule (protein) E at interface *} 
 DEFINE>{+ table: rows=5 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} E_start_fle_1=""; 
 DEFINE>{===>} E_end_fle_1=""; 
 DEFINE>{===>} E_start_fle_2=""; 
 DEFINE>{===>} E_end_fle_2=""; 
 DEFINE>{===>} E_start_fle_3=""; 
 DEFINE>{===>} E_end_fle_3=""; 
 DEFINE>{===>} E_start_fle_4=""; 
 DEFINE>{===>} E_end_fle_4=""; 
 DEFINE>{===>} E_start_fle_5=""; 
 DEFINE>{===>} E_end_fle_5=""; 
 DEFINE>{* Fully flexible segments for molecule (protein) F            *} 
 DEFINE>{* Note that current max is 5 (edit the run.cns to add more segments     *} 
 DEFINE>{===>} nfle_F=0; 
 DEFINE>{* Residues of molecule (protein) F at interface *} 
 DEFINE>{+ table: rows=5 "segment 1" "segment 2" "segment 3" "segment 4" "segment 5" cols=2 "Start residue" "End residue" +} 
 DEFINE>{===>} F_start_fle_1=""; 
 DEFINE>{===>} F_end_fle_1=""; 
 DEFINE>{===>} F_start_fle_2=""; 
 DEFINE>{===>} F_end_fle_2=""; 
 DEFINE>{===>} F_start_fle_3=""; 
 DEFINE>{===>} F_end_fle_3=""; 
 DEFINE>{===>} F_start_fle_4=""; 
 DEFINE>{===>} F_end_fle_4=""; 
 DEFINE>{===>} F_start_fle_5=""; 
 DEFINE>{===>} F_end_fle_5=""; 
 DEFINE> 
 DEFINE>{====================== NCS restraints  =====================} 
 DEFINE>{* Do you want to use NCS restraints? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} ncs_on=false; 
 DEFINE>{* Force constant for NCS restraints *} 
 DEFINE>{===>} kncs=1.0; 
 DEFINE>{* Number of NCS pairs *} 
 DEFINE>{===>} numncs=0; 
 DEFINE>{* Define the segments pairs for NCS restraints *} 
 DEFINE>{+ table: rows=5 "pair 1" "pair 2" "pair 3" "pair 4" "pair 5" cols=6 "Start res seg1" "End res seg1" "Segid seg1" "Start res seg2" "End res seg2" "Segid seg2" +} 
 DEFINE>{===>} ncs_sta1_1=""; 
 DEFINE>{===>} ncs_end1_1=""; 
 DEFINE>{===>} ncs_seg1_1=""; 
 DEFINE>{===>} ncs_sta2_1=""; 
 DEFINE>{===>} ncs_end2_1=""; 
 DEFINE>{===>} ncs_seg2_1=""; 
 DEFINE>{===>} ncs_sta1_2=""; 
 DEFINE>{===>} ncs_end1_2=""; 
 DEFINE>{===>} ncs_seg1_2=""; 
 DEFINE>{===>} ncs_sta2_2=""; 
 DEFINE>{===>} ncs_end2_2=""; 
 DEFINE>{===>} ncs_seg2_2=""; 
 DEFINE>{===>} ncs_sta1_3=""; 
 DEFINE>{===>} ncs_end1_3=""; 
 DEFINE>{===>} ncs_seg1_3=""; 
 DEFINE>{===>} ncs_sta2_3=""; 
 DEFINE>{===>} ncs_end2_3=""; 
 DEFINE>{===>} ncs_seg2_3=""; 
 DEFINE>{===>} ncs_sta1_4=""; 
 DEFINE>{===>} ncs_end1_4=""; 
 DEFINE>{===>} ncs_seg1_4=""; 
 DEFINE>{===>} ncs_sta2_4=""; 
 DEFINE>{===>} ncs_end2_4=""; 
 DEFINE>{===>} ncs_seg2_4=""; 
 DEFINE>{===>} ncs_sta1_5=""; 
 DEFINE>{===>} ncs_end1_5=""; 
 DEFINE>{===>} ncs_seg1_5=""; 
 DEFINE>{===>} ncs_sta2_5=""; 
 DEFINE>{===>} ncs_end2_5=""; 
 DEFINE>{===>} ncs_seg2_5=""; 
 DEFINE>{==================== Symmetry restraints  ==================} 
 DEFINE>{* Do you want to use symmetry restraints ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} sym_on=false; 
 DEFINE>{* Force constant for symmetry restraints ? *} 
 DEFINE>{===>} ksym=10.0; 
 DEFINE>{* Number of C2 symmetry pairs *} 
 DEFINE>{===>} numc2sym=0; 
 DEFINE>{* Define the segment pairs for C2 symmetry restraints *} 
 DEFINE>{+ table: rows=10 "pair 1" "pair 2" "pair 3" "pair 4" "pair 5" "pair 6" "pair 7" "pair 8" "pair 9" "pair 10" cols=6 "Start res seg1" "End res seg1" "Segid seg1" "Start res seg2" "End res seg2" "Segid seg2" +} 
 DEFINE>{===>} c2sym_sta1_1=""; 
 DEFINE>{===>} c2sym_end1_1=""; 
 DEFINE>{===>} c2sym_seg1_1=""; 
 DEFINE>  {===>} c2sym_sta2_1=""; 
 DEFINE>{===>} c2sym_end2_1=""; 
 DEFINE>{===>} c2sym_seg2_1=""; 
 DEFINE>  {===>} c2sym_sta1_2=""; 
 DEFINE>{===>} c2sym_end1_2=""; 
 DEFINE>{===>} c2sym_seg1_2=""; 
 DEFINE>  {===>} c2sym_sta2_2=""; 
 DEFINE>{===>} c2sym_end2_2=""; 
 DEFINE>{===>} c2sym_seg2_2=""; 
 DEFINE>  {===>} c2sym_sta1_3=""; 
 DEFINE>{===>} c2sym_end1_3=""; 
 DEFINE>{===>} c2sym_seg1_3=""; 
 DEFINE>  {===>} c2sym_sta2_3=""; 
 DEFINE>{===>} c2sym_end2_3=""; 
 DEFINE>{===>} c2sym_seg2_3=""; 
 DEFINE>  {===>} c2sym_sta1_4=""; 
 DEFINE>{===>} c2sym_end1_4=""; 
 DEFINE>{===>} c2sym_seg1_4=""; 
 DEFINE>  {===>} c2sym_sta2_4=""; 
 DEFINE>{===>} c2sym_end2_4=""; 
 DEFINE>{===>} c2sym_seg2_4=""; 
 DEFINE>  {===>} c2sym_sta1_5=""; 
 DEFINE>{===>} c2sym_end1_5=""; 
 DEFINE>{===>} c2sym_seg1_5=""; 
 DEFINE>  {===>} c2sym_sta2_5=""; 
 DEFINE>{===>} c2sym_end2_5=""; 
 DEFINE>{===>} c2sym_seg2_5=""; 
 DEFINE>  {===>} c2sym_sta1_6=""; 
 DEFINE>{===>} c2sym_end1_6=""; 
 DEFINE>{===>} c2sym_seg1_6=""; 
 DEFINE>  {===>} c2sym_sta2_6=""; 
 DEFINE>{===>} c2sym_end2_6=""; 
 DEFINE>{===>} c2sym_seg2_6=""; 
 DEFINE>  {===>} c2sym_sta1_7=""; 
 DEFINE>{===>} c2sym_end1_7=""; 
 DEFINE>{===>} c2sym_seg1_7=""; 
 DEFINE>  {===>} c2sym_sta2_7=""; 
 DEFINE>{===>} c2sym_end2_7=""; 
 DEFINE>{===>} c2sym_seg2_7=""; 
 DEFINE>  {===>} c2sym_sta1_8=""; 
 DEFINE>{===>} c2sym_end1_8=""; 
 DEFINE>{===>} c2sym_seg1_8=""; 
 DEFINE>  {===>} c2sym_sta2_8=""; 
 DEFINE>{===>} c2sym_end2_8=""; 
 DEFINE>{===>} c2sym_seg2_8=""; 
 DEFINE>  {===>} c2sym_sta1_9=""; 
 DEFINE>{===>} c2sym_end1_9=""; 
 DEFINE>{===>} c2sym_seg1_9=""; 
 DEFINE>  {===>} c2sym_sta2_9=""; 
 DEFINE>{===>} c2sym_end2_9=""; 
 DEFINE>{===>} c2sym_seg2_9=""; 
 DEFINE>  {===>} c2sym_sta1_10=""; 
 DEFINE>{===>} c2sym_end1_10=""; 
 DEFINE>{===>} c2sym_seg1_10=""; 
 DEFINE>  {===>} c2sym_sta2_10=""; 
 DEFINE>{===>} c2sym_end2_10=""; 
 DEFINE>{===>} c2sym_seg2_10=""; 
 DEFINE> 
 DEFINE>{* Number of C3 symmetry triples *} 
 DEFINE>{===>} numc3sym=0; 
 DEFINE>{* Define the segment triples for C3 symmetry restraints *} 
 DEFINE>{+ table: rows=2 "triple 1" "triple 2" cols=9 "Start res seg1" "End res seg1" "Segid seg1" "Start res seg2" "End res seg2" "Segid seg2" "Start res seg3" "End res seg3" "Segid seg3" +} 
 DEFINE>{===>} c3sym_sta1_1=""; 
 DEFINE>{===>} c3sym_end1_1=""; 
 DEFINE>{===>} c3sym_seg1_1=""; 
 DEFINE>  {===>} c3sym_sta2_1=""; 
 DEFINE>{===>} c3sym_end2_1=""; 
 DEFINE>{===>} c3sym_seg2_1=""; 
 DEFINE>  {===>} c3sym_sta3_1=""; 
 DEFINE>{===>} c3sym_end3_1=""; 
 DEFINE>{===>} c3sym_seg3_1=""; 
 DEFINE>  {===>} c3sym_sta1_2=""; 
 DEFINE>{===>} c3sym_end1_2=""; 
 DEFINE>{===>} c3sym_seg1_2=""; 
 DEFINE>  {===>} c3sym_sta2_2=""; 
 DEFINE>{===>} c3sym_end2_2=""; 
 DEFINE>{===>} c3sym_seg2_2=""; 
 DEFINE>  {===>} c3sym_sta3_2=""; 
 DEFINE>{===>} c3sym_end3_2=""; 
 DEFINE>{===>} c3sym_seg3_2=""; 
 DEFINE> 
 DEFINE>{* Number of S3 symmetry triples *} 
 DEFINE>{===>} nums3sym=0; 
 DEFINE>{* Define the segment triples for S3 symmetry restraints *} 
 DEFINE>{+ table: rows=4 "triple 1" "triple 2" "triple 3" "triple 4" cols=9 "Start res seg1" "End res seg1" "Segid seg1" "Start res seg2" "End res seg2" "Segid seg2" "Start res seg3" "End res seg3" "Segid seg3" +} 
 DEFINE>{===>} s3sym_sta1_1=""; 
 DEFINE>{===>} s3sym_end1_1=""; 
 DEFINE>{===>} s3sym_seg1_1=""; 
 DEFINE>  {===>} s3sym_sta2_1=""; 
 DEFINE>{===>} s3sym_end2_1=""; 
 DEFINE>{===>} s3sym_seg2_1=""; 
 DEFINE>  {===>} s3sym_sta3_1=""; 
 DEFINE>{===>} s3sym_end3_1=""; 
 DEFINE>{===>} s3sym_seg3_1=""; 
 DEFINE>  {===>} s3sym_sta1_2=""; 
 DEFINE>{===>} s3sym_end1_2=""; 
 DEFINE>{===>} s3sym_seg1_2=""; 
 DEFINE>  {===>} s3sym_sta2_2=""; 
 DEFINE>{===>} s3sym_end2_2=""; 
 DEFINE>{===>} s3sym_seg2_2=""; 
 DEFINE>  {===>} s3sym_sta3_2=""; 
 DEFINE>{===>} s3sym_end3_2=""; 
 DEFINE>{===>} s3sym_seg3_2=""; 
 DEFINE>  {===>} s3sym_sta1_3=""; 
 DEFINE>{===>} s3sym_end1_3=""; 
 DEFINE>{===>} s3sym_seg1_3=""; 
 DEFINE>  {===>} s3sym_sta2_3=""; 
 DEFINE>{===>} s3sym_end2_3=""; 
 DEFINE>{===>} s3sym_seg2_3=""; 
 DEFINE>  {===>} s3sym_sta3_3=""; 
 DEFINE>{===>} s3sym_end3_3=""; 
 DEFINE>{===>} s3sym_seg3_3=""; 
 DEFINE>  {===>} s3sym_sta1_4=""; 
 DEFINE>{===>} s3sym_end1_4=""; 
 DEFINE>{===>} s3sym_seg1_4=""; 
 DEFINE>  {===>} s3sym_sta2_4=""; 
 DEFINE>{===>} s3sym_end2_4=""; 
 DEFINE>{===>} s3sym_seg2_4=""; 
 DEFINE>  {===>} s3sym_sta3_4=""; 
 DEFINE>{===>} s3sym_end3_4=""; 
 DEFINE>{===>} s3sym_seg3_4=""; 
 DEFINE> 
 DEFINE>{* Number of C4 symmetry quadruples *} 
 DEFINE>{===>} numc4sym=0; 
 DEFINE>{* Define the segment quadruples for C4 symmetry restraints *} 
 DEFINE>{+ table: rows=2 "quadruple 1" "quadruple 2" cols=12 "Start res seg1" "End res seg1" "Segid seg1" "Start res seg2" "End res seg2" "Segid seg2" "Start res seg3" "End res seg3" "Segid seg3" "Start res seg4" "End res seg4" "Segid seg4" +} 
 DEFINE>{===>} c4sym_sta1_1=""; 
 DEFINE>{===>} c4sym_end1_1=""; 
 DEFINE>{===>} c4sym_seg1_1=""; 
 DEFINE>  {===>} c4sym_sta2_1=""; 
 DEFINE>{===>} c4sym_end2_1=""; 
 DEFINE>{===>} c4sym_seg2_1=""; 
 DEFINE>  {===>} c4sym_sta3_1=""; 
 DEFINE>{===>} c4sym_end3_1=""; 
 DEFINE>{===>} c4sym_seg3_1=""; 
 DEFINE>  {===>} c4sym_sta4_1=""; 
 DEFINE>{===>} c4sym_end4_1=""; 
 DEFINE>{===>} c4sym_seg4_1=""; 
 DEFINE>  {===>} c4sym_sta1_2=""; 
 DEFINE>{===>} c4sym_end1_2=""; 
 DEFINE>{===>} c4sym_seg1_2=""; 
 DEFINE>  {===>} c4sym_sta2_2=""; 
 DEFINE>{===>} c4sym_end2_2=""; 
 DEFINE>{===>} c4sym_seg2_2=""; 
 DEFINE>  {===>} c4sym_sta3_2=""; 
 DEFINE>{===>} c4sym_end3_2=""; 
 DEFINE>{===>} c4sym_seg3_2=""; 
 DEFINE>  {===>} c4sym_sta4_2=""; 
 DEFINE>{===>} c4sym_end4_2=""; 
 DEFINE>{===>} c4sym_seg4_2=""; 
 DEFINE> 
 DEFINE>{* Number of C5 symmetry *} 
 DEFINE>{===>} numc5sym=0; 
 DEFINE>{* Define the segments for C5 symmetry restraints *} 
 DEFINE>{+ table: rows=5 "Segment1" "Segment2" "Segment3" "Segment4" "Segment5" cols=3 "Start residue" "End residue" "Segid" +} 
 DEFINE>{===>} c5sym_sta1_1=""; 
 DEFINE>{===>} c5sym_end1_1=""; 
 DEFINE>{===>} c5sym_seg1_1=""; 
 DEFINE>  {===>} c5sym_sta2_1=""; 
 DEFINE>{===>} c5sym_end2_1=""; 
 DEFINE>{===>} c5sym_seg2_1=""; 
 DEFINE>  {===>} c5sym_sta3_1=""; 
 DEFINE>{===>} c5sym_end3_1=""; 
 DEFINE>{===>} c5sym_seg3_1=""; 
 DEFINE>  {===>} c5sym_sta4_1=""; 
 DEFINE>{===>} c5sym_end4_1=""; 
 DEFINE>{===>} c5sym_seg4_1=""; 
 DEFINE>  {===>} c5sym_sta5_1=""; 
 DEFINE>{===>} c5sym_end5_1=""; 
 DEFINE>{===>} c5sym_seg5_1=""; 
 DEFINE> 
 DEFINE>{=========================== Distance restraints  ========================} 
 DEFINE>{* Turn on/off and energy constants for distance restraints *} 
 DEFINE>{+ table: rows=3 "distances" "AIR (ambig)" "hbonds" cols=6 "firstIteration" "lastIteration" "hot" "cool1" "cool2" "cool3"+} 
 DEFINE>{===>} unamb_firstit=0; 
 DEFINE>{===>} unamb_lastit=2; 
 DEFINE>{===>} unamb_hot=10; 
 DEFINE>{===>} unamb_cool1=10; 
 DEFINE>{===>} unamb_cool2=50; 
 DEFINE>{===>} unamb_cool3=50; 
 DEFINE>{===>} amb_firstit=0; 
 DEFINE>{===>} amb_lastit=2; 
 DEFINE>{===>} amb_hot=10; 
 DEFINE>{===>} amb_cool1=10; 
 DEFINE>{===>} amb_cool2=50; 
 DEFINE>{===>} amb_cool3=50; 
 DEFINE>{===>} hbond_firstit=1; 
 DEFINE>{===>} hbond_lastit=2; 
 DEFINE>{===>} hbond_hot=10; 
 DEFINE>{===>} hbond_cool1=10; 
 DEFINE>{===>} hbond_cool2=50; 
 DEFINE>{===>} hbond_cool3=50; 
 DEFINE>{* Do you want to randomly exclude a fraction of the ambiguous restraints (AIRs)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} noecv=true; 
 DEFINE>{* Number of partitions for random exclusion (%excluded=100/number of partitions)? *} 
 DEFINE>{===>} ncvpart=2.0; 
 DEFINE>{* Do you want to use hydrogen bond restraints? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} hbonds_on=false; 
 DEFINE>{* Do you want to define randomly ambiguous interaction restraints from accessible residues? *} 
 DEFINE>{* Only residues in the defined flexible segments will be considered *} 
 DEFINE>{* Note that this option is exclusive with any other distance restraints and only for it0    *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} ranair=false; 
 DEFINE>{* Do you want to define center of mass restraints to enforce contact between the molecules? *} 
 DEFINE>{* Note that these are only active during it0 and it1 *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cmrest=true; 
 DEFINE>{* Force constant for center of mass restraints *} 
 DEFINE>{===>} kcont=1.0; 
 DEFINE>{* Do you want to define surface contact restraints to enforce contact between the molecules? *} 
 DEFINE>{* Note that these are only active during it0 and it1 *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} surfrest=true; 
 DEFINE>{* Force constant for surface contact restraints *} 
 DEFINE>{===>} ksurf=1.0; 
 DEFINE>{* Do you want to define a radius of gyration restraint (e.g. from SAXS)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rgrest=false; 
 DEFINE>{* Radius of gyration *} 
 DEFINE>{===>} rgtarg=17.78; 
 DEFINE>{* Force constant for radius of gyration restraint *} 
 DEFINE>{===>} krg_hot=100; 
 DEFINE>{===>} krg_cool1=100; 
 DEFINE>{===>} krg_cool2=100; 
 DEFINE>{===>} krg_cool3=100; 
 DEFINE>{* Atom selections for the radius of gyration restraint *} 
 DEFINE>{===>} rgsele="all"; 
 DEFINE>{ Use automated distance restraints weighting } 
 DEFINE>{ choice: true false } 
 DEFINE>air_scaling=false; 
 DEFINE>{ Define the number of distance restraints for automated weighting } 
 DEFINE>tot_unamb=25; 
 DEFINE>{ Define the number of AIR restraints for automated weighting } 
 DEFINE>tot_amb=0; 
 DEFINE>{ potential shape } 
 DEFINE>mrswi_hot=0.5; 
 DEFINE>mrswi_cool1=0.5; 
 DEFINE>mrswi_cool2=0.5; 
 DEFINE>mrswi_cool3=0.5; 
 DEFINE>rswi_hot=0.5; 
 DEFINE>rswi_cool1=0.5; 
 DEFINE>rswi_cool2=0.5; 
 DEFINE>rswi_cool3=0.5; 
 DEFINE>masy_hot=-1.0; 
 DEFINE>masy_cool1=-1.0; 
 DEFINE>masy_cool2=-0.1; 
 DEFINE>masy_cool3=-0.1; 
 DEFINE>asy_hot=1.0; 
 DEFINE>asy_cool1=1.0; 
 DEFINE>asy_cool2=0.1; 
 DEFINE>asy_cool3=0.1; 
 DEFINE>{======================DNA-RNA restraints ============================} 
 DEFINE>{* Use DNA/RNA restraints (dna-rna_restraints.def in data/sequence)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dnarest_on=false; 
 DEFINE>{=========================== dihedrals restraints ====================} 
 DEFINE>{* energy constants *} 
 DEFINE>{+ table: rows=1 "dihedrals" cols=5 "use?" "hot" "cool1" "cool2" "cool3" +} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} dihedrals_on=false; 
 DEFINE>{===>} dihedrals_hot=5; 
 DEFINE>{===>} dihedrals_cool1=5; 
 DEFINE>{===>} dihedrals_cool2=50; 
 DEFINE>{===>} dihedrals_cool3=200; 
 DEFINE>{* Automatically define backbone dihedral angle restraints from structure? *} 
 DEFINE>{+ choice: none all alpha alphabeta +} 
 DEFINE>{===>} ssdihed=none; 
 DEFINE>{=========================== Karplus coupling restraints ====================} 
 DEFINE>{* Karplus coefficients: edit manually the run.cns file to specify them if needed   *} 
 DEFINE>{* The jcoupling restraint files should be present in the data/jcouplings directory *} 
 DEFINE>{* and named c1.tbl, c2.tbl, ... *} 
 DEFINE> c1_on=false; 
 DEFINE> c1_karplusa=6.98; 
 DEFINE> c1_karplusb=-1.38; 
 DEFINE> c1_karplusc=1.72; 
 DEFINE> c1_karplusd=-60.0; 
 DEFINE> c1_hot=0.0; 
 DEFINE> c1_cool1=0.2; 
 DEFINE> c1_cool2=1.0; 
 DEFINE> c1_cool3=1.0; 
 DEFINE> c2_on=false; 
 DEFINE> c2_karplusa=6.98; 
 DEFINE> c2_karplusb=-1.38; 
 DEFINE> c2_karplusc=1.72; 
 DEFINE> c2_karplusd=-120.0; 
 DEFINE> c2_hot=0.0; 
 DEFINE> c2_cool1=0.2; 
 DEFINE> c2_cool2=1.0; 
 DEFINE> c2_cool3=1.0; 
 DEFINE> c3_on=false; 
 DEFINE> c3_karplusa=6.98; 
 DEFINE> c3_karplusb=-1.38; 
 DEFINE> c3_karplusc=1.72; 
 DEFINE> c3_karplusd=-120.0; 
 DEFINE> c3_hot=0.0; 
 DEFINE> c3_cool1=0.2; 
 DEFINE> c3_cool2=1.0; 
 DEFINE> c3_cool3=1.0; 
 DEFINE> c4_on=false; 
 DEFINE> c4_karplusa=6.98; 
 DEFINE> c4_karplusb=-1.38; 
 DEFINE> c4_karplusc=1.72; 
 DEFINE> c4_karplusd=-120.0; 
 DEFINE> c4_hot=0.0; 
 DEFINE> c4_cool1=0.2; 
 DEFINE> c4_cool2=1.0; 
 DEFINE> c4_cool3=1.0; 
 DEFINE> c5_on=false; 
 DEFINE> c5_karplusa=6.98; 
 DEFINE> c5_karplusb=-1.38; 
 DEFINE> c5_karplusc=1.72; 
 DEFINE> c5_karplusd=-120.0; 
 DEFINE> c5_hot=0.0; 
 DEFINE> c5_cool1=0.2; 
 DEFINE> c5_cool2=1.0; 
 DEFINE> c5_cool3=1.0; 
 DEFINE>{=========================== residual dipolar couplings ======================} 
 DEFINE>{* Parameters *} 
 DEFINE>{+ table: rows=5 "class1" "class2" "class3" "class4" "class5" 
 DEFINE>          cols=25 "type" "firstIt" "lastIt" "Ksani<br>(hot)" "Ksani<br>(cool1)" "Ksani<br>(cool2)" "Ksani<br>(cool3)" "R" "D" 
 DEFINE> "Kvean<br>(ini_bor_hot)" "Kvean<br>(fin_bor_hot)" 
 DEFINE> "Kvean<br>(ini_bor_cool1)" "Kvean<br>(fin_bor_cool1)" 
 DEFINE> "Kvean<br>(ini_bor_cool2)" "Kvean<br>(fin_bor_cool2)" 
 DEFINE> "Kvean<br>(ini_bor_cool3)" "Kvean<br>(fin_bor_cool3)" 
 DEFINE> "Kvean<br>(ini_cen_hot)" "Kvean<br>(fin_cen_hot)" 
 DEFINE> "Kvean<br>(ini_cen_cool1)" "Kvean<br>(fin_cen_cool1)" 
 DEFINE> "Kvean<br>(ini_cen_cool2)" "Kvean<br>(fin_cen_cool2)" 
 DEFINE> "Kvean<br>(ini_cen_cool3)" "Kvean<br>(fin_cen_cool3)"+} 
 DEFINE>{+ choice: "NO" "SANI" "XRDC" "VANGLE" +} 
 DEFINE>{===>} rdc1_choice="NO"; 
 DEFINE>{===>} rdc1_firstIt=0; 
 DEFINE>{===>} rdc1_lastIt=2; 
 DEFINE>{===>} rdc1_hot=0.1; 
 DEFINE>{===>} rdc1_cool1=1.0; 
 DEFINE>{===>} rdc1_cool2=1.0; 
 DEFINE>{===>} rdc1_cool3=1.0; 
 DEFINE>{===>} rdc1_r=0.4; 
 DEFINE>{===>} rdc1_d=8.0; 
 DEFINE>{===>} ini_bor_hot_1=1.0; 
 DEFINE>{===>} fin_bor_hot_1=10.0; 
 DEFINE>{===>} ini_bor_cool1_1=10.0; 
 DEFINE>{===>} fin_bor_cool1_1=40.0; 
 DEFINE>{===>} ini_bor_cool2_1=40.0; 
 DEFINE>{===>} fin_bor_cool2_1=40.0; 
 DEFINE>{===>} ini_bor_cool3_1=40.0; 
 DEFINE>{===>} fin_bor_cool3_1=40.0; 
 DEFINE>{===>} ini_cen_hot_1=0.25; 
 DEFINE>{===>} fin_cen_hot_1=2.5; 
 DEFINE>{===>} ini_cen_cool1_1=2.5; 
 DEFINE>{===>} fin_cen_cool1_1=10.0; 
 DEFINE>{===>} ini_cen_cool2_1=10.0; 
 DEFINE>{===>} fin_cen_cool2_1=10.0; 
 DEFINE>{===>} ini_cen_cool3_1=10.0; 
 DEFINE>{===>} fin_cen_cool3_1=10.0; 
 DEFINE>{+ choice: "NO" "SANI" "XRDC" "VANGLE" +} 
 DEFINE>{===>} rdc2_choice="NO"; 
 DEFINE>{===>} rdc2_firstIt=0; 
 DEFINE>{===>} rdc2_lastIt=2; 
 DEFINE>{===>} rdc2_hot=0.1; 
 DEFINE>{===>} rdc2_cool1=1.0; 
 DEFINE>{===>} rdc2_cool2=1.0; 
 DEFINE>{===>} rdc2_cool3=1.0; 
 DEFINE>{===>} rdc2_r=0.4; 
 DEFINE>{===>} rdc2_d=8.0; 
 DEFINE>{===>} ini_bor_hot_2=1.0; 
 DEFINE>{===>} fin_bor_hot_2=10.0; 
 DEFINE>{===>} ini_bor_cool1_2=10.0; 
 DEFINE>{===>} fin_bor_cool1_2=40.0; 
 DEFINE>{===>} ini_bor_cool2_2=40.0; 
 DEFINE>{===>} fin_bor_cool2_2=40.0; 
 DEFINE>{===>} ini_bor_cool3_2=40.0; 
 DEFINE>{===>} fin_bor_cool3_2=40.0; 
 DEFINE>{===>} ini_cen_hot_2=0.25; 
 DEFINE>{===>} fin_cen_hot_2=2.5; 
 DEFINE>{===>} ini_cen_cool1_2=2.5; 
 DEFINE>{===>} fin_cen_cool1_2=10.0; 
 DEFINE>{===>} ini_cen_cool2_2=10.0; 
 DEFINE>{===>} fin_cen_cool2_2=10.0; 
 DEFINE>{===>} ini_cen_cool3_2=10.0; 
 DEFINE>{===>} fin_cen_cool3_2=10.0; 
 DEFINE>{+ choice: "NO" "SANI" "XRDC" "VANGLE" +} 
 DEFINE>{===>} rdc3_choice="NO"; 
 DEFINE>{===>} rdc3_firstIt=0; 
 DEFINE>{===>} rdc3_lastIt=2; 
 DEFINE>{===>} rdc3_hot=0.1; 
 DEFINE>{===>} rdc3_cool1=1.0; 
 DEFINE>{===>} rdc3_cool2=1.0; 
 DEFINE>{===>} rdc3_cool3=1.0; 
 DEFINE>{===>} rdc3_r=0.4; 
 DEFINE>{===>} rdc3_d=8.0; 
 DEFINE>{===>} ini_bor_hot_3=1.0; 
 DEFINE>{===>} fin_bor_hot_3=10.0; 
 DEFINE>{===>} ini_bor_cool1_3=10.0; 
 DEFINE>{===>} fin_bor_cool1_3=40.0; 
 DEFINE>{===>} ini_bor_cool2_3=40.0; 
 DEFINE>{===>} fin_bor_cool2_3=40.0; 
 DEFINE>{===>} ini_bor_cool3_3=40.0; 
 DEFINE>{===>} fin_bor_cool3_3=40.0; 
 DEFINE>{===>} ini_cen_hot_3=0.25; 
 DEFINE>{===>} fin_cen_hot_3=2.5; 
 DEFINE>{===>} ini_cen_cool1_3=2.5; 
 DEFINE>{===>} fin_cen_cool1_3=10.0; 
 DEFINE>{===>} ini_cen_cool2_3=10.0; 
 DEFINE>{===>} fin_cen_cool2_3=10.0; 
 DEFINE>{===>} ini_cen_cool3_3=10.0; 
 DEFINE>{===>} fin_cen_cool3_3=10.0; 
 DEFINE>{+ choice: "NO" "SANI" "XRDC" "VANGLE" +} 
 DEFINE>{===>} rdc4_choice="NO"; 
 DEFINE>{===>} rdc4_firstIt=0; 
 DEFINE>{===>} rdc4_lastIt=2; 
 DEFINE>{===>} rdc4_hot=0.1; 
 DEFINE>{===>} rdc4_cool1=1.0; 
 DEFINE>{===>} rdc4_cool2=1.0; 
 DEFINE>{===>} rdc4_cool3=1.0; 
 DEFINE>{===>} rdc4_r=0.4; 
 DEFINE>{===>} rdc4_d=8.0; 
 DEFINE>{===>} ini_bor_hot_4=1.0; 
 DEFINE>{===>} fin_bor_hot_4=10.0; 
 DEFINE>{===>} ini_bor_cool1_4=10.0; 
 DEFINE>{===>} fin_bor_cool1_4=40.0; 
 DEFINE>{===>} ini_bor_cool2_4=40.0; 
 DEFINE>{===>} fin_bor_cool2_4=40.0; 
 DEFINE>{===>} ini_bor_cool3_4=40.0; 
 DEFINE>{===>} fin_bor_cool3_4=40.0; 
 DEFINE>{===>} ini_cen_hot_4=0.25; 
 DEFINE>{===>} fin_cen_hot_4=2.5; 
 DEFINE>{===>} ini_cen_cool1_4=2.5; 
 DEFINE>{===>} fin_cen_cool1_4=10.0; 
 DEFINE>{===>} ini_cen_cool2_4=10.0; 
 DEFINE>{===>} fin_cen_cool2_4=10.0; 
 DEFINE>{===>} ini_cen_cool3_4=10.0; 
 DEFINE>{===>} fin_cen_cool3_4=10.0; 
 DEFINE>{+ choice: "NO" "SANI" "XRDC" "VANGLE" +} 
 DEFINE>{===>} rdc5_choice="NO"; 
 DEFINE>{===>} rdc5_firstIt=0; 
 DEFINE>{===>} rdc5_lastIt=2; 
 DEFINE>{===>} rdc5_hot=0.1; 
 DEFINE>{===>} rdc5_cool1=1.0; 
 DEFINE>{===>} rdc5_cool2=1.0; 
 DEFINE>{===>} rdc5_cool3=1.0; 
 DEFINE>{===>} rdc5_r=0.4; 
 DEFINE>{===>} rdc5_d=8.0; 
 DEFINE>{===>} ini_bor_hot_5=1.0; 
 DEFINE>{===>} fin_bor_hot_5=10.0; 
 DEFINE>{===>} ini_bor_cool1_5=10.0; 
 DEFINE>{===>} fin_bor_cool1_5=40.0; 
 DEFINE>{===>} ini_bor_cool2_5=40.0; 
 DEFINE>{===>} fin_bor_cool2_5=40.0; 
 DEFINE>{===>} ini_bor_cool3_5=40.0; 
 DEFINE>{===>} fin_bor_cool3_5=40.0; 
 DEFINE>{===>} ini_cen_hot_5=0.25; 
 DEFINE>{===>} fin_cen_hot_5=2.5; 
 DEFINE>{===>} ini_cen_cool1_5=2.5; 
 DEFINE>{===>} fin_cen_cool1_5=10.0; 
 DEFINE>{===>} ini_cen_cool2_5=10.0; 
 DEFINE>{===>} fin_cen_cool2_5=10.0; 
 DEFINE>{===>} ini_cen_cool3_5=10.0; 
 DEFINE>{===>} fin_cen_cool3_5=10.0; 
 DEFINE>{=========================== pseudo contact shifts ===========================} 
 DEFINE>{* Parameters *} 
 DEFINE>{+ table: rows=10 "class1" "class2" "class3" "class4" "class5" "class6" "class7" "class8" "class9" "class10" 
 DEFINE>          cols=9 "type" "firstIt" "lastIt" "Kpcs<br>(hot)" "Kpcs<br>(cool1)" "Kpcs<br>(cool2)" "Kpcs<br>(cool3)" "R" "D" +} 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs1_choice="NO"; 
 DEFINE>{===>} pcs1_firstIt=0; 
 DEFINE>{===>} pcs1_lastIt=2; 
 DEFINE>{===>} pcs1_hot=100.0; 
 DEFINE>{===>} pcs1_cool1=100.0; 
 DEFINE>{===>} pcs1_cool2=100.0; 
 DEFINE>{===>} pcs1_cool3=1000.0; 
 DEFINE>{===>} pcs1_r=1000.0; 
 DEFINE>{===>} pcs1_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs2_choice="NO"; 
 DEFINE>{===>} pcs2_firstIt=0; 
 DEFINE>{===>} pcs2_lastIt=2; 
 DEFINE>{===>} pcs2_hot=100.0; 
 DEFINE>{===>} pcs2_cool1=100.0; 
 DEFINE>{===>} pcs2_cool2=100.0; 
 DEFINE>{===>} pcs2_cool3=1000.0; 
 DEFINE>{===>} pcs2_r=1000.0; 
 DEFINE>{===>} pcs2_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs3_choice="NO"; 
 DEFINE>{===>} pcs3_firstIt=0; 
 DEFINE>{===>} pcs3_lastIt=2; 
 DEFINE>{===>} pcs3_hot=100.0; 
 DEFINE>{===>} pcs3_cool1=100.0; 
 DEFINE>{===>} pcs3_cool2=100.0; 
 DEFINE>{===>} pcs3_cool3=1000.0; 
 DEFINE>{===>} pcs3_r=1000.0; 
 DEFINE>{===>} pcs3_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs4_choice="NO"; 
 DEFINE>{===>} pcs4_firstIt=0; 
 DEFINE>{===>} pcs4_lastIt=2; 
 DEFINE>{===>} pcs4_hot=100.0; 
 DEFINE>{===>} pcs4_cool1=100.0; 
 DEFINE>{===>} pcs4_cool2=100.0; 
 DEFINE>{===>} pcs4_cool3=1000.0; 
 DEFINE>{===>} pcs4_r=1000.0; 
 DEFINE>{===>} pcs4_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs5_choice="NO"; 
 DEFINE>{===>} pcs5_firstIt=0; 
 DEFINE>{===>} pcs5_lastIt=2; 
 DEFINE>{===>} pcs5_hot=100.0; 
 DEFINE>{===>} pcs5_cool1=100.0; 
 DEFINE>{===>} pcs5_cool2=100.0; 
 DEFINE>{===>} pcs5_cool3=1000.0; 
 DEFINE>{===>} pcs5_r=1000.0; 
 DEFINE>{===>} pcs5_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs6_choice="NO"; 
 DEFINE>{===>} pcs6_firstIt=0; 
 DEFINE>{===>} pcs6_lastIt=2; 
 DEFINE>{===>} pcs6_hot=100.0; 
 DEFINE>{===>} pcs6_cool1=100.0; 
 DEFINE>{===>} pcs6_cool2=100.0; 
 DEFINE>{===>} pcs6_cool3=1000.0; 
 DEFINE>{===>} pcs6_r=1000.0; 
 DEFINE>{===>} pcs6_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs7_choice="NO"; 
 DEFINE>{===>} pcs7_firstIt=0; 
 DEFINE>{===>} pcs7_lastIt=2; 
 DEFINE>{===>} pcs7_hot=100.0; 
 DEFINE>{===>} pcs7_cool1=100.0; 
 DEFINE>{===>} pcs7_cool2=100.0; 
 DEFINE>{===>} pcs7_cool3=1000.0; 
 DEFINE>{===>} pcs7_r=1000.0; 
 DEFINE>{===>} pcs7_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs8_choice="NO"; 
 DEFINE>{===>} pcs8_firstIt=0; 
 DEFINE>{===>} pcs8_lastIt=2; 
 DEFINE>{===>} pcs8_hot=100.0; 
 DEFINE>{===>} pcs8_cool1=100.0; 
 DEFINE>{===>} pcs8_cool2=100.0; 
 DEFINE>{===>} pcs8_cool3=1000.0; 
 DEFINE>{===>} pcs8_r=1000.0; 
 DEFINE>{===>} pcs8_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcs9_choice="NO"; 
 DEFINE>{===>} pcs9_firstIt=0; 
 DEFINE>{===>} pcs9_lastIt=2; 
 DEFINE>{===>} pcs9_hot=100.0; 
 DEFINE>{===>} pcs9_cool1=100.0; 
 DEFINE>{===>} pcs9_cool2=100.0; 
 DEFINE>{===>} pcs9_cool3=1000.0; 
 DEFINE>{===>} pcs9_r=1000.0; 
 DEFINE>{===>} pcs9_d=10000.0; 
 DEFINE>{+ choice: "NO" "XPCS" +} 
 DEFINE>{===>} pcsA_choice="NO"; 
 DEFINE>{===>} pcsA_firstIt=0; 
 DEFINE>{===>} pcsA_lastIt=2; 
 DEFINE>{===>} pcsA_hot=100.0; 
 DEFINE>{===>} pcsA_cool1=100.0; 
 DEFINE>{===>} pcsA_cool2=100.0; 
 DEFINE>{===>} pcsA_cool3=1000.0; 
 DEFINE>{===>} pcsA_r=1000.0; 
 DEFINE>{===>} pcsA_d=10000.0; 
 DEFINE>{=========================== relaxation data ======================} 
 DEFINE>{* Parameters *} 
 DEFINE>{+ table: rows=5 "class1" "class2" "class3" "class4" "class5" 
 DEFINE>          cols=12 "type" "firstIt" "lastIt" "Kdani(hot)" "Kdani(cool1)" "Kdani(cool2)" "Kdani(cool3)" "Correlation time" "D" "R" "H frequency" "N frequency" +} 
 DEFINE>{+ choice: "NO" "DANI" +} 
 DEFINE>{===>} dan1_choice="NO"; 
 DEFINE>{===>} dan1_firstIt=0; 
 DEFINE>{===>} dan1_lastIt=2; 
 DEFINE>{===>} dan1_hot=1; 
 DEFINE>{===>} dan1_cool1=5; 
 DEFINE>{===>} dan1_cool2=10; 
 DEFINE>{===>} dan1_cool3=10; 
 DEFINE>{===>} dan1_tc=9.771; 
 DEFINE>{===>} dan1_anis=1.557; 
 DEFINE>{===>} dan1_r=0.455; 
 DEFINE>{===>} dan1_wh=599.91; 
 DEFINE>{===>} dan1_wn=60.82; 
 DEFINE>{+ choice: "NO" "DANI" +} 
 DEFINE>{===>} dan2_choice="NO"; 
 DEFINE>{===>} dan2_firstIt=0; 
 DEFINE>{===>} dan2_lastIt=1; 
 DEFINE>{===>} dan2_hot=1; 
 DEFINE>{===>} dan2_cool1=5; 
 DEFINE>{===>} dan2_cool2=10; 
 DEFINE>{===>} dan2_cool3=10; 
 DEFINE>{===>} dan2_tc=9.84; 
 DEFINE>{===>} dan2_anis=-1.35; 
 DEFINE>{===>} dan2_r=0.308; 
 DEFINE>{===>} dan2_wh=599.91; 
 DEFINE>{===>} dan2_wn=60.82; 
 DEFINE>{+ choice: "NO" "DANI" +} 
 DEFINE>{===>} dan3_choice="NO"; 
 DEFINE>{===>} dan3_firstIt=1; 
 DEFINE>{===>} dan3_lastIt=1; 
 DEFINE>{===>} dan3_hot=1; 
 DEFINE>{===>} dan3_cool1=5; 
 DEFINE>{===>} dan3_cool2=10; 
 DEFINE>{===>} dan3_cool3=10; 
 DEFINE>{===>} dan3_tc=9.84; 
 DEFINE>{===>} dan3_anis=-1.35; 
 DEFINE>{===>} dan3_r=0.308; 
 DEFINE>{===>} dan3_wh=599.91; 
 DEFINE>{===>} dan3_wn=60.82; 
 DEFINE>{+ choice: "NO" "DANI" +} 
 DEFINE>{===>} dan4_choice="NO"; 
 DEFINE>{===>} dan4_firstIt=0; 
 DEFINE>{===>} dan4_lastIt=2; 
 DEFINE>{===>} dan4_hot=1; 
 DEFINE>{===>} dan4_cool1=5; 
 DEFINE>{===>} dan4_cool2=10; 
 DEFINE>{===>} dan4_cool3=10; 
 DEFINE>{===>} dan4_tc=9.84; 
 DEFINE>{===>} dan4_anis=-1.35; 
 DEFINE>{===>} dan4_r=0.308; 
 DEFINE>{===>} dan4_wh=599.91; 
 DEFINE>{===>} dan4_wn=60.82; 
 DEFINE>{+ choice: "NO" "DANI" +} 
 DEFINE>{===>} dan5_choice="NO"; 
 DEFINE>{===>} dan5_firstIt=0; 
 DEFINE>{===>} dan5_lastIt=2; 
 DEFINE>{===>} dan5_hot=1; 
 DEFINE>{===>} dan5_cool1=5; 
 DEFINE>{===>} dan5_cool2=10; 
 DEFINE>{===>} dan5_cool3=10; 
 DEFINE>{===>} dan5_tc=9.84; 
 DEFINE>{===>} dan5_anis=-1.35; 
 DEFINE>{===>} dan5_r=0.308; 
 DEFINE>{===>} dan5_wh=599.91; 
 DEFINE>{===>} dan5_wn=60.82; 
 DEFINE>{===================== topology and parameter files ======================} 
 DEFINE>{* topology file for molecule (protein) A *} 
 DEFINE>{===>} prot_top_A="protein-allhdg5-4.top"; 
 DEFINE>{* topology file for molecule (protein) B *} 
 DEFINE>{===>} prot_top_B="protein-allhdg5-4.top"; 
 DEFINE>{* topology file for molecule (protein) C *} 
 DEFINE>{===>} prot_top_C=""; 
 DEFINE>{* topology file for molecule (protein) D *} 
 DEFINE>{===>} prot_top_D=""; 
 DEFINE>{* topology file for molecule (protein) E *} 
 DEFINE>{===>} prot_top_E=""; 
 DEFINE>{* topology file for molecule (protein) F *} 
 DEFINE>{===>} prot_top_F=""; 
 DEFINE>{* linkage file for molecule (protein) A *} 
 DEFINE>{===>} prot_link_A="protein-allhdg5-4-noter.link"; 
 DEFINE>{* linkage file for molecule (protein) B *} 
 DEFINE>{===>} prot_link_B="protein-allhdg5-4-noter.link"; 
 DEFINE>{* linkage file for molecule (protein) C *} 
 DEFINE>{===>} prot_link_C=""; 
 DEFINE>{* linkage file for molecule (protein) D *} 
 DEFINE>{===>} prot_link_D=""; 
 DEFINE>{* linkage file for molecule (protein) E *} 
 DEFINE>{===>} prot_link_E=""; 
 DEFINE>{* linkage file for molecule (protein) F *} 
 DEFINE>{===>} prot_link_F=""; 
 DEFINE>{* energy parameter file for molecule (protein) A *} 
 DEFINE>{===>} prot_par_A="protein-allhdg5-4.param"; 
 DEFINE>{* energy parameter file for molecule (protein) B *} 
 DEFINE>{===>} prot_par_B="protein-allhdg5-4.param"; 
 DEFINE>{* energy parameter file for molecule (protein) C *} 
 DEFINE>{===>} prot_par_C=""; 
 DEFINE>{* energy parameter file for molecule (protein) D *} 
 DEFINE>{===>} prot_par_D=""; 
 DEFINE>{* energy parameter file for molecule (protein) E *} 
 DEFINE>{===>} prot_par_E=""; 
 DEFINE>{* energy parameter file for molecule (protein) F *} 
 DEFINE>{===>} prot_par_F=""; 
 DEFINE>{* type of non-bonded parameters *} 
 DEFINE>{* specify the type of non-bonded interaction *} 
 DEFINE>{+ choice: "PROLSQ" "PARMALLH6" "PARALLHDG" "OPLSX" +} 
 DEFINE>{===>} par_nonbonded="OPLSX"; 
 DEFINE>{===================== energy and interaction parameters ==================} 
 DEFINE>{ Do you want to include dihedral angle energy terms? } 
 DEFINE>{ choice: true false } 
 DEFINE>dihedflag=true; 
 DEFINE>{* Do you want to include the electrostatic energy term for docking? *} 
 DEFINE>{* Note that it will be automatically included in the solvent refinement *} 
 DEFINE>{* Include electrostatic during rigid body docking (it0)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} elecflag_0=true; 
 DEFINE>{* Include electrostatic during semi-flexible SA (it1)? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} elecflag_1=true; 
 DEFINE>{* Give the epsilon constant for the electrostatic energy term? (Note: for water cdie with epsilon=1 is used) *} 
 DEFINE>{* Note that for explicit solvent refinement cdie with epsilon=1 is used *} 
 DEFINE>{===>} epsilon=10.0; 
 DEFINE>{* Use constant (cdie) or distance-dependent (rdie) dielectric? *} 
 DEFINE>{+ choice: cdie rdie +} 
 DEFINE>{===>} dielec=cdie; 
 DEFINE>{* - *} 
 DEFINE>{* Scaling of intermolecular interactions for rigid body EM*} 
 DEFINE>{===>} inter_rigid=1.0; 
 DEFINE>{* Scaling of intermolecular interactions for semi-flexible SA*} 
 DEFINE>{+ table: rows=3 "Rigid body dynamic " "SA with flexible side-chains (cool2)" "SA with flexible backbone and side-chains (cool3)" 
 DEFINE>          cols=2 "Init value" "Final value" +} 
 DEFINE>{===>} init_rigid=0.001; 
 DEFINE>{===>} fin_rigid=0.001; 
 DEFINE>{===>} init_cool2=0.001; 
 DEFINE>{===>} fin_cool2=1.0; 
 DEFINE>{===>} init_cool3=0.05; 
 DEFINE>{===>} fin_cool3=1.0; 
 DEFINE>{* Interaction matrix for non-bonded interactions*} 
 DEFINE>{+ table: rows=6 "Mol 1" "Mol 2" "Mol 3" "Mol 4" "Mol 5" "Mol 6" 
 DEFINE>          cols=6 "Mol 1" "Mol 2" "Mol 3" "Mol 4" "Mol 5" "Mol 6" +} 
 DEFINE>{===>} int_1_1=1.0; 
 DEFINE>{===>} int_1_2=1.0; 
 DEFINE>{===>} int_1_3=1.0; 
 DEFINE>{===>} int_1_4=1.0; 
 DEFINE>{===>} int_1_5=1.0; 
 DEFINE>{===>} int_1_6=1.0; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_2_1="N.A."; 
 DEFINE>{===>} int_2_2=1.0; 
 DEFINE>{===>} int_2_3=1.0; 
 DEFINE>{===>} int_2_4=1.0; 
 DEFINE>{===>} int_2_5=1.0; 
 DEFINE>{===>} int_2_6=1.0; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_3_1="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_3_2="N.A."; 
 DEFINE>{===>} int_3_3=1.0; 
 DEFINE>{===>} int_3_4=1.0; 
 DEFINE>{===>} int_3_5=1.0; 
 DEFINE>{===>} int_3_6=1.0; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_4_1="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_4_2="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_4_3="N.A."; 
 DEFINE>{===>} int_4_4=1.0; 
 DEFINE>{===>} int_4_5=1.0; 
 DEFINE>{===>} int_4_6=1.0; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_5_1="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_5_2="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_5_3="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_5_4="N.A."; 
 DEFINE>{===>} int_5_5=1.0; 
 DEFINE>{===>} int_5_6=1.0; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_6_1="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_6_2="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_6_3="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_6_4="N.A."; 
 DEFINE>{+ choice: "N.A." +} 
 DEFINE>{===>} int_6_5="N.A."; 
 DEFINE>{===>} int_6_6=1.0; 
 DEFINE>{===================== Number of structures to dock =======================} 
 DEFINE>{* Settings for the rigid body (it0) and semi-flexible refinement (it1) *} 
 DEFINE>{* number of structures for rigid body docking *} 
 DEFINE>{===>} structures_0=20; 
 DEFINE>   keepstruct_0=&structures_0; 
 DEFINE>{* number of structures for refinement *} 
 DEFINE>{===>} structures_1=20; 
 DEFINE>   keepstruct_1=&structures_1; 
 DEFINE>   keepstruct_2=&structures_1; 
 DEFINE>{* number of structures to be analysed*} 
 DEFINE>{===>} anastruc_1=20; 
 DEFINE>   anastruc_0=&anastruc_1; 
 DEFINE>   anastruc_2=&anastruc_1; 
 DEFINE>{* - *} 
 DEFINE>{* Sampling of symmetry related solutions                       *} 
 DEFINE>{* Sample 180 degrees rotated solutions during rigid body EM?   *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rotate180_0=false; 
 DEFINE>{* Sample 180 degrees rotated solutions during semi-flexible SA?*} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rotate180_1=false; 
 DEFINE>{=========================== DOCKING protocol =============================} 
 DEFINE>{* Cross-dock all combinations in the ensembles of starting structures? *} 
 DEFINE>{* Turn off this option if you only want to dock structure 1 of ensemble A *} 
 DEFINE>{*   to structure 1 of ensemble B, structure 2 to structure 2, etc. *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} crossdock=false; 
 DEFINE>{* Randomize starting orientations? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} randorien=false; 
 DEFINE>{* Perform initial rigid body minimisation? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rigidmini=false; 
 DEFINE>{* Allow translation in rigid body minimisation? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} rigidtrans=false; 
 DEFINE>{* Number of trials for rigid body minimisation? *} 
 DEFINE>{===>} ntrials=5; 
 DEFINE>{* initial seed for random number generator *} 
 DEFINE>{* change to get different initial velocities *} 
 DEFINE>{===>} iniseed=917; 
 DEFINE>{* temperature for rigid body high temperature TAD *} 
 DEFINE>{===>} tadhigh_t=2000; 
 DEFINE>{* initial temperature for rigid body first TAD cooling step *} 
 DEFINE>{===>} tadinit1_t=2000; 
 DEFINE>{* final temperature after first cooling step *} 
 DEFINE>{===>} tadfinal1_t=500; 
 DEFINE>{* initial temperature for second TAD cooling step with flexible side-chain at the inferface *} 
 DEFINE>{===>} tadinit2_t=1000; 
 DEFINE>{* finale temperature after second cooling step *} 
 DEFINE>{===>} tadfinal2_t=50; 
 DEFINE>{* initial temperature for third TAD cooling step with fully flexible interface *} 
 DEFINE>{===>} tadinit3_t=500; 
 DEFINE>{* finale temperature after third cooling step *} 
 DEFINE>{===>} tadfinal3_t=50; 
 DEFINE>{* time step *} 
 DEFINE>{===>} timestep=0.002; 
 DEFINE>{* factor for timestep in TAD *} 
 DEFINE>{===>} tadfactor=8; 
 DEFINE>{* number of MD steps for rigid body high temperature TAD *} 
 DEFINE>{===>} initiosteps=0; 
 DEFINE>{* number of MD steps during first rigid body cooling stage *} 
 DEFINE>{===>} cool1_steps=0; 
 DEFINE>{* number of MD steps during second cooling stage with flexible side-chains at interface *} 
 DEFINE>{===>} cool2_steps=0; 
 DEFINE>{* number of MD steps during third cooling stage with fully flexible interface *} 
 DEFINE>{===>} cool3_steps=0; 
 DEFINE>{======================= Solvated rigid body docking=======================} 
 DEFINE>{* perform solvated docking ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} waterdock=false; 
 DEFINE>{* which method to use for solvating? *} 
 DEFINE>{* db: database-based (recommended), restraints: for restrained solvating to amino-acid most often forming 
 DEFINE>water mediated contacts and blank (""): for uniform waterlayer *} 
 DEFINE>{+ choice: "db" "restraints" "" +} 
 DEFINE>{===>} solvate_method="db"; 
 DEFINE>{* which propensity database to use? *} 
 DEFINE>{* statistical: based on an analysis of water-mediated contacts in the PDB, kyte-doolittle: based on the Kyte-Doolittle hydrophobicity scalte *} 
 DEFINE>{+ choice: "statistical" "kytedoolittle" +} 
 DEFINE>{===>} db_method="kytedoolittle"; 
 DEFINE>{* initial cutoff for restraints solvating method *} 
 DEFINE>{* all waters further away from a highly occuring water solvated residue will be removed in the generation 
 DEFINE>of the initial solvation shell *} 
 DEFINE>{===>} water_restraint_initial=5.0; 
 DEFINE>{* cutoff for restraints solvating method *} 
 DEFINE>{* upper distance limit for defining distance restraints between water and amino-acids often found to be 
 DEFINE>involved in water-mediated contacts *} 
 DEFINE>{===>} water_restraint_cutoff=5.0; 
 DEFINE>{* force constant for restraints solvating method *} 
 DEFINE>{===>} water_restraint_scale=25.0; 
 DEFINE>{* fraction of water to keep *} 
 DEFINE>{* this is the fraction of all interface water after the initial rigid body docking that will be kept (note 
 DEFINE>that more waters might be removed if the interaction energy is unfavorable  *} 
 DEFINE>{===>} water_tokeep=0.25; 
 DEFINE>{* this is the fraction of interface water involving DNA phosphates after the initial rigid body docking that will be kept 
 DEFINE>(note that more waters might be removed if the interaction energy is unfavorable  *} 
 DEFINE>{===>} dnap_water_tokeep=0.25; 
 DEFINE>{* random fraction to be added to the fraction of water to keep *} 
 DEFINE>{===>} water_randfrac=0.0; 
 DEFINE>{* water-protein surface-cutoff *} 
 DEFINE>{* waters further away than this cutoff distance from any component of the complex will be removed *} 
 DEFINE>{===>} water_surfcutoff=8.0; 
 DEFINE>{* do some water analysis *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} water_analysis=false; 
 DEFINE>{* allows translation of water molecules during rigid-body docking, true or false: *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} transwater=true; 
 DEFINE>{* number of different initial solvation shells to generate *} 
 DEFINE>{===>} waterensemble=1; 
 DEFINE>{==================== final explicit solvent refinement  ==================} 
 DEFINE>{* Do you want to refine your docking models in explicit solvent? *} 
 DEFINE>{+ choice: "yes" "no" +} 
 DEFINE>{===>} firstwater="yes"; 
 DEFINE>{* Which solvent do you want to use? *} 
 DEFINE>{+ choice: "water" "dmso" +} 
 DEFINE>{===>} solvent="water"; 
 DEFINE>{* number of structures for the explicit solvent refinement *} 
 DEFINE>{* refine the n best structures regarding energy            *} 
 DEFINE>{===>} waterrefine=20; 
 DEFINE>   structures_2=&waterrefine; 
 DEFINE>{* number of steps for heating phase (100, 200, 300K)?      *} 
 DEFINE>{===>} waterheatsteps=100; 
 DEFINE>{* number of steps for 300K phase?                          *} 
 DEFINE>{===>} watersteps=1250; 
 DEFINE>{* number of steps for cooling phase (300, 200, 100K)?      *} 
 DEFINE>{===>} watercoolsteps=500; 
 DEFINE>{* write additional PDB files including solvent ?           *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} keepwater=false; 
 DEFINE>{ calculate explicit desolvation energy (note this will double the cpu requirements) } 
 DEFINE>{ choice: true false } 
 DEFINE>calcdesolv=false; 
 DEFINE>{================================ Scoring =================================} 
 DEFINE>{* Settings for the scoring of the docking solutions *} 
 DEFINE>{* Define the weights for the various terms for the sorting of structures (scoring) *} 
 DEFINE>{+ table: rows=14 "Evdw" "Eelec" "Eair" "Erg" "Esani" "Exrdc" "Expcs" "Edani" "Evean" "Ecdih" "Esym" "BSA" "dEint" "Edesolv" 
 DEFINE>          cols=3 "Rigid body EM" "semi-flexible SA" "Water refinement" +} 
 DEFINE>{===>} w_vdw_0=0.01; 
 DEFINE>{===>} w_vdw_1=1.0; 
 DEFINE>{===>} w_vdw_2=1.0; 
 DEFINE>{===>} w_elec_0=1.0; 
 DEFINE>{===>} w_elec_1=1.0; 
 DEFINE>{===>} w_elec_2=0.2; 
 DEFINE>{===>} w_dist_0=0.01; 
 DEFINE>{===>} w_dist_1=0.1; 
 DEFINE>{===>} w_dist_2=0.1; 
 DEFINE>{===>} w_rg_0=0.1; 
 DEFINE>{===>} w_rg_1=1.0; 
 DEFINE>{===>} w_rg_2=1.0; 
 DEFINE>{===>} w_sani_0=0.1; 
 DEFINE>{===>} w_sani_1=0.1; 
 DEFINE>{===>} w_sani_2=0.1; 
 DEFINE>{===>} w_xrdc_0=0.1; 
 DEFINE>{===>} w_xrdc_1=0.1; 
 DEFINE>{===>} w_xrdc_2=0.1; 
 DEFINE>{===>} w_xpcs_0=0.1; 
 DEFINE>{===>} w_xpcs_1=0.1; 
 DEFINE>{===>} w_xpcs_2=0.1; 
 DEFINE>{===>} w_dani_0=0.01; 
 DEFINE>{===>} w_dani_1=0.1; 
 DEFINE>{===>} w_dani_2=0.1; 
 DEFINE>{===>} w_vean_0=0.1; 
 DEFINE>{===>} w_vean_1=0.1; 
 DEFINE>{===>} w_vean_2=0.1; 
 DEFINE>{===>} w_cdih_0=0.0; 
 DEFINE>{===>} w_cdih_1=0.0; 
 DEFINE>{===>} w_cdih_2=0.0; 
 DEFINE>{===>} w_sym_0=0.1; 
 DEFINE>{===>} w_sym_1=0.1; 
 DEFINE>{===>} w_sym_2=0.1; 
 DEFINE>{===>} w_bsa_0=-0.01; 
 DEFINE>{===>} w_bsa_1=-0.01; 
 DEFINE>{===>} w_bsa_2=0.0; 
 DEFINE>{===>} w_deint_0=0.0; 
 DEFINE>{===>} w_deint_1=0.0; 
 DEFINE>{===>} w_deint_2=0.0; 
 DEFINE>{===>} w_desolv_0=1.0; 
 DEFINE>{===>} w_desolv_1=1.0; 
 DEFINE>{===>} w_desolv_2=1.0; 
 DEFINE>{* Perform smoothed-scoring selection for rigid-body docking solutions ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} smoothing=false; 
 DEFINE>{* It is possible to skip structures in the selection of structure in it0 *} 
 DEFINE>{* Give for this the number of structures to skip: *} 
 DEFINE>{===>} skip_struc=0; 
 DEFINE>{======================= analysis and clustering ==========================} 
 DEFINE>{* Cutoff distance (proton-acceptor) to define an hydrogen bond? *} 
 DEFINE>{===>} dist_hb=2.5; 
 DEFINE>{* Cutoff distance (carbon-carbon) to define an hydrophobic contact? *} 
 DEFINE>{===>} dist_nb=3.9; 
 DEFINE>{* Clustering method (RMSD or Fraction of Common Contacts (FCC)) *} 
 DEFINE>{+ choice: "RMSD" "FCC" +} 
 DEFINE>{===>} clust_meth="FCC"; 
 DEFINE>{* RMSD cutoff for clustering? (Recommended values: RMSD 7.5, FCC 0.75) *} 
 DEFINE>{===>} clust_cutoff=0.6; 
 DEFINE>{* Minimum cluster size? *} 
 DEFINE>{===>} clust_size=4; 
 DEFINE>{* Chain-Agnostic Algorithm (used for FCC clustering in symmetrical complexes) *} 
 DEFINE>{+ choice: "true" "false" +} 
 DEFINE>{===>} fcc_ignc=false; 
 DEFINE>{======================= final clean-up ===================================} 
 DEFINE>{* Clean up the run directory after completion (only files for struct #1 are kept) ? *} 
 DEFINE>{+ choice: true false +} 
 DEFINE>{===>} cleanup=true; 
 DEFINE>{============================ parallel jobs ===============================} 
 DEFINE>{* How many nodes do you want to use in parallel? *} 
 DEFINE>{* leave unused fields blank, make sure that the queues are actually running *} 
 DEFINE>{+ table: rows=10 "1" "2" "3" "4" "5" "6" "7" "8" "9" "10" 
 DEFINE> cols=3 "queue command" "cns executable" "number of jobs" +} 
 DEFINE>{===>} queue_1="/home/diracegi/grid/diracsubmit-haddock2.2"; 
 DEFINE>{===>} cns_exe_1="/home/software/software/cns_solve_1.31-UU/intel-x86_64bit-linux/bin/cns"; 
 DEFINE>{===>} cpunumber_1=10000; 
 DEFINE>{===>} queue_2=""; 
 DEFINE>{===>} cns_exe_2=""; 
 DEFINE>{===>} cpunumber_2=0; 
 DEFINE>{===>} queue_3=""; 
 DEFINE>{===>} cns_exe_3=""; 
 DEFINE>{===>} cpunumber_3=0; 
 DEFINE>{===>} queue_4=""; 
 DEFINE>{===>} cns_exe_4=""; 
 DEFINE>{===>} cpunumber_4=0; 
 DEFINE>{===>} queue_5=""; 
 DEFINE>{===>} cns_exe_5=""; 
 DEFINE>{===>} cpunumber_5=0; 
 DEFINE>{===>} queue_6=""; 
 DEFINE>{===>} cns_exe_6=""; 
 DEFINE>{===>} cpunumber_6=0; 
 DEFINE>{===>} queue_7=""; 
 DEFINE>{===>} cns_exe_7=""; 
 DEFINE>{===>} cpunumber_7=0; 
 DEFINE>{===>} queue_8=""; 
 DEFINE>{===>} cns_exe_8=""; 
 DEFINE>{===>} cpunumber_8=0; 
 DEFINE>{===>} queue_9=""; 
 DEFINE>{===>} cns_exe_9=""; 
 DEFINE>{===>} cpunumber_9=0; 
 DEFINE>{===>} queue_10=""; 
 DEFINE>{===>} cns_exe_10=""; 
 DEFINE>{===>} cpunumber_10=0; 
 DEFINE>{===========================================================================} 
 DEFINE>{        things below this line do not normally need to be changed          } 
 DEFINE>{===========================================================================} 
 DEFINE>) {- end block parameter definition -} 
 CNSsolve>!for global parameters (local variables (suffix ) => global variables): 
 CNSsolve>evaluate (&saprotocol.crossdock=&crossdock) 
 EVALUATE: symbol $_1_SAPROTOCOL.CROSSDOCK set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.randorien=&randorien) 
 EVALUATE: symbol $_1_SAPROTOCOL.RANDORIEN set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.rigidmini=&rigidmini) 
 EVALUATE: symbol $_1_SAPROTOCOL.RIGIDMINI set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.rigidtrans=&rigidtrans) 
 EVALUATE: symbol $_1_SAPROTOCOL.RIGIDTRANS set to FALSE (logical)
 CNSsolve>evaluate (&saprotocol.ntrials=&ntrials) 
 EVALUATE: symbol $_1_SAPROTOCOL.NTRIALS set to    5.00000     (real)
 CNSsolve>evaluate (&saprotocol.iniseed=&iniseed) 
 EVALUATE: symbol $_1_SAPROTOCOL.INISEED set to    917.000     (real)
 CNSsolve>evaluate (&saprotocol.tadhigh_t=&tadhigh_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.TADHIGH_T set to    2000.00     (real)
 CNSsolve>evaluate (&saprotocol.t1_init=&tadinit1_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T1_INIT set to    2000.00     (real)
 CNSsolve>evaluate (&saprotocol.t2_init=&tadinit2_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T2_INIT set to    1000.00     (real)
 CNSsolve>evaluate (&saprotocol.t3_init=&tadinit3_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T3_INIT set to    500.000     (real)
 CNSsolve>evaluate (&saprotocol.t1_final=&tadfinal1_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T1_FINAL set to    500.000     (real)
 CNSsolve>evaluate (&saprotocol.t2_final=&tadfinal2_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T2_FINAL set to    50.0000     (real)
 CNSsolve>evaluate (&saprotocol.t3_final=&tadfinal3_t) 
 EVALUATE: symbol $_1_SAPROTOCOL.T3_FINAL set to    50.0000     (real)
 CNSsolve>evaluate (&saprotocol.inter_rigid=&inter_rigid) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_RIGID set to    1.00000     (real)
 CNSsolve>evaluate (&saprotocol.inter_init_rigid=&init_rigid) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_INIT_RIGID set to   0.100000E-02 (real)
 CNSsolve>evaluate (&saprotocol.inter_fin_rigid=&fin_rigid) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_FIN_RIGID set to   0.100000E-02 (real)
 CNSsolve>evaluate (&saprotocol.inter_init_cool2=&init_cool2) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_INIT_COOL2 set to   0.100000E-02 (real)
 CNSsolve>evaluate (&saprotocol.inter_fin_cool2=&fin_cool2) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_FIN_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&saprotocol.inter_init_cool3=&init_cool3) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_INIT_COOL3 set to   0.500000E-01 (real)
 CNSsolve>evaluate (&saprotocol.inter_fin_cool3=&fin_cool3) 
 EVALUATE: symbol $_1_SAPROTOCOL.INTER_FIN_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&saprotocol.tempstep=50) 
 EVALUATE: symbol $_1_SAPROTOCOL.TEMPSTEP set to    50.0000     (real)
 CNSsolve>evaluate (&saprotocol.timestep=&timestep) 
 EVALUATE: symbol $_1_SAPROTOCOL.TIMESTEP set to   0.200000E-02 (real)
 CNSsolve>evaluate (&saprotocol.tadfactor=&tadfactor) 
 EVALUATE: symbol $_1_SAPROTOCOL.TADFACTOR set to    8.00000     (real)
 CNSsolve>evaluate (&saprotocol.initiosteps=&initiosteps) 
 EVALUATE: symbol $_1_SAPROTOCOL.INITIOSTEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.cool1_steps=&cool1_steps) 
 EVALUATE: symbol $_1_SAPROTOCOL.COOL1_STEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.cool2_steps=&cool2_steps) 
 EVALUATE: symbol $_1_SAPROTOCOL.COOL2_STEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.cool3_steps=&cool3_steps) 
 EVALUATE: symbol $_1_SAPROTOCOL.COOL3_STEPS set to    0.00000     (real)
 CNSsolve>evaluate (&saprotocol.fbeta=100) 
 EVALUATE: symbol $_1_SAPROTOCOL.FBETA set to    100.000     (real)
 CNSsolve>evaluate (&saprotocol.mass=100) 
 EVALUATE: symbol $_1_SAPROTOCOL.MASS set to    100.000     (real)
 CNSsolve>evaluate (&filenames.fileroot=&fileroot) 
 EVALUATE: symbol $_1_FILENAMES.FILEROOT set to "complex" (string)
 CNSsolve>evaluate (&filenames.template=&fileroot + "_1.pdb") 
 EVALUATE: symbol $_1_FILENAMES.TEMPLATE set to "complex_1.pdb" (string)
 CNSsolve>evaluate (&iterations.ini_count    =1) 
 EVALUATE: symbol $_1_ITERATIONS.INI_COUNT set to    1.00000     (real)
 CNSsolve>evaluate (&iterations.structures   =&structures_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.STRUCTURES set to    20.0000     (real)
 CNSsolve>evaluate (&iterations.keepstruct   =&keepstruct_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.KEEPSTRUCT set to    20.0000     (real)
 CNSsolve>evaluate (&iterations.filesort     =&filesort_$iteration) 
 Assuming literal string "&FILESORT_$ITERATION"
 EVALUATE: symbol $_1_ITERATIONS.FILESORT set to "&FILESORT_$ITERATION" (string)
 CNSsolve>evaluate (&iterations.w_vdw        =&w_vdw_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_VDW set to    1.00000     (real)
 CNSsolve>evaluate (&iterations.w_elec       =&w_elec_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_ELEC set to    1.00000     (real)
 CNSsolve>evaluate (&iterations.w_dist       =&w_dist_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DIST set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_rg         =&w_rg_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_RG set to    1.00000     (real)
 CNSsolve>evaluate (&iterations.w_sani       =&w_sani_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_SANI set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_xrdc       =&w_xrdc_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_XRDC set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_xpcs       =&w_xpcs_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_XPCS set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_dani       =&w_dani_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DANI set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_vean       =&w_vean_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_VEAN set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_cdih       =&w_cdih_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_CDIH set to    0.00000     (real)
 CNSsolve>evaluate (&iterations.w_sym        =&w_sym_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_SYM set to   0.100000     (real)
 CNSsolve>evaluate (&iterations.w_bsa        =&w_bsa_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_BSA set to  -0.100000E-01 (real)
 CNSsolve>evaluate (&iterations.w_deint      =&w_deint_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DEINT set to    0.00000     (real)
 CNSsolve>evaluate (&iterations.w_desolv     =&w_desolv_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.W_DESOLV set to    1.00000     (real)
 CNSsolve>evaluate (&iterations.anastruc     =&anastruc_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.ANASTRUC set to    20.0000     (real)
 CNSsolve>evaluate (&iterations.rotate180    =&rotate180_$iteration) 
 EVALUATE: symbol $_1_ITERATIONS.ROTATE180 set to FALSE (logical)
 CNSsolve>!topology and parameters, sequence file, template file, interface definition: 
 CNSsolve>evaluate (&toppar.prot_top_1=&prot_top_A ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_1 set to "protein-allhdg5-4.top" (string)
 CNSsolve>evaluate (&toppar.prot_top_2=&prot_top_B ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_2 set to "protein-allhdg5-4.top" (string)
 CNSsolve>evaluate (&toppar.prot_top_3=&prot_top_C ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_3 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_top_4=&prot_top_D ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_4 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_top_5=&prot_top_E ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_5 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_top_6=&prot_top_F ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_TOP_6 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_link_1=&prot_link_A ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_1 set to "protein-allhdg5-4-noter.link" (string)
 CNSsolve>evaluate (&toppar.prot_link_2=&prot_link_B ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_2 set to "protein-allhdg5-4-noter.link" (string)
 CNSsolve>evaluate (&toppar.prot_link_3=&prot_link_C ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_3 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_link_4=&prot_link_D ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_4 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_link_5=&prot_link_E ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_5 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_link_6=&prot_link_F ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_LINK_6 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_par_1=&prot_par_A ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_1 set to "protein-allhdg5-4.param" (string)
 CNSsolve>evaluate (&toppar.prot_par_2=&prot_par_B ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_2 set to "protein-allhdg5-4.param" (string)
 CNSsolve>evaluate (&toppar.prot_par_3=&prot_par_C ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_3 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_par_4=&prot_par_D ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_4 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_par_5=&prot_par_E ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_5 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_par_6=&prot_par_F ) 
 EVALUATE: symbol $_1_TOPPAR.PROT_PAR_6 set to "" (string)
 CNSsolve>evaluate (&toppar.par_nonbonded=&par_nonbonded) 
 EVALUATE: symbol $_1_TOPPAR.PAR_NONBONDED set to "OPLSX" (string)
 CNSsolve>evaluate (&toppar.prot_coor_1=&prot_coor_A) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_1 set to "protein1.pdb" (string)
 CNSsolve>evaluate (&toppar.prot_coor_2=&prot_coor_B) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_2 set to "protein2.pdb" (string)
 CNSsolve>evaluate (&toppar.prot_coor_3=&prot_coor_C) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_3 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_coor_4=&prot_coor_D) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_4 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_coor_5=&prot_coor_E) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_5 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_coor_6=&prot_coor_F) 
 EVALUATE: symbol $_1_TOPPAR.PROT_COOR_6 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_root_1=&prot_root_A) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_1 set to "protein1" (string)
 CNSsolve>evaluate (&toppar.prot_root_2=&prot_root_B) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_2 set to "protein2" (string)
 CNSsolve>evaluate (&toppar.prot_root_3=&prot_root_C) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_3 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_root_4=&prot_root_D) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_4 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_root_5=&prot_root_E) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_5 set to "" (string)
 CNSsolve>evaluate (&toppar.prot_root_6=&prot_root_F) 
 EVALUATE: symbol $_1_TOPPAR.PROT_ROOT_6 set to "" (string)
 CNSsolve>evaluate (&toppar.dna_1=&dna_A) 
 EVALUATE: symbol $_1_TOPPAR.DNA_1 set to FALSE (logical)
 CNSsolve>evaluate (&toppar.dna_2=&dna_B) 
 EVALUATE: symbol $_1_TOPPAR.DNA_2 set to FALSE (logical)
 CNSsolve>evaluate (&toppar.dna_3=&dna_C) 
 EVALUATE: symbol $_1_TOPPAR.DNA_3 set to FALSE (logical)
 CNSsolve>evaluate (&toppar.dna_4=&dna_D) 
 EVALUATE: symbol $_1_TOPPAR.DNA_4 set to FALSE (logical)
 CNSsolve>evaluate (&toppar.dna_5=&dna_E) 
 EVALUATE: symbol $_1_TOPPAR.DNA_5 set to FALSE (logical)
 CNSsolve>evaluate (&toppar.dna_6=&dna_F) 
 EVALUATE: symbol $_1_TOPPAR.DNA_6 set to FALSE (logical)
 CNSsolve>evaluate (&toppar.prot_segid_1=&prot_segid_A) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_1 set to "A" (string)
 CNSsolve>evaluate (&toppar.prot_segid_2=&prot_segid_B) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_2 set to "B" (string)
 CNSsolve>evaluate (&toppar.prot_segid_3=&prot_segid_C) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_3 set to "C" (string)
 CNSsolve>evaluate (&toppar.prot_segid_4=&prot_segid_D) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_4 set to "D" (string)
 CNSsolve>evaluate (&toppar.prot_segid_5=&prot_segid_E) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_5 set to "E" (string)
 CNSsolve>evaluate (&toppar.prot_segid_6=&prot_segid_F) 
 EVALUATE: symbol $_1_TOPPAR.PROT_SEGID_6 set to "F" (string)
 CNSsolve>evaluate (&data.ncomponents=&ncomponents) 
 EVALUATE: symbol $_1_DATA.NCOMPONENTS set to    2.00000     (real)
 CNSsolve>evaluate (&toppar.nseg_1=&nseg_A) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_1 set to   -1.00000     (real)
 CNSsolve>evaluate (&toppar.nseg_2=&nseg_B) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_2 set to   -1.00000     (real)
 CNSsolve>evaluate (&toppar.nseg_3=&nseg_C) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_3 set to   -1.00000     (real)
 CNSsolve>evaluate (&toppar.nseg_4=&nseg_D) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_4 set to   -1.00000     (real)
 CNSsolve>evaluate (&toppar.nseg_5=&nseg_E) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_5 set to   -1.00000     (real)
 CNSsolve>evaluate (&toppar.nseg_6=&nseg_F) 
 EVALUATE: symbol $_1_TOPPAR.NSEG_6 set to   -1.00000     (real)
 CNSsolve>evaluate (&toppar.start_seg_1_1=&A_start_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_2=&A_start_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_3=&A_start_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_4=&A_start_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_5=&A_start_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_6=&A_start_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_6 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_7=&A_start_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_7 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_8=&A_start_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_8 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_9=&A_start_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_9 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_1_10=&A_start_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_1_10 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_1=&A_end_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_2=&A_end_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_3=&A_end_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_4=&A_end_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_5=&A_end_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_6=&A_end_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_6 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_7=&A_end_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_7 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_8=&A_end_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_8 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_9=&A_end_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_9 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_1_10=&A_end_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_1_10 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_1=&B_start_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_2=&B_start_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_3=&B_start_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_4=&B_start_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_5=&B_start_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_6=&B_start_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_6 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_7=&B_start_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_7 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_8=&B_start_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_8 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_9=&B_start_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_9 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_2_10=&B_start_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_2_10 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_1=&B_end_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_2=&B_end_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_3=&B_end_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_4=&B_end_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_5=&B_end_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_6=&B_end_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_6 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_7=&B_end_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_7 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_8=&B_end_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_8 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_9=&B_end_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_9 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_2_10=&B_end_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_2_10 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_1=&C_start_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_2=&C_start_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_3=&C_start_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_4=&C_start_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_5=&C_start_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_5 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_6=&C_start_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_6 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_7=&C_start_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_7 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_8=&C_start_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_8 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_9=&C_start_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_9 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_3_10=&C_start_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_3_10 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_1=&C_end_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_2=&C_end_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_3=&C_end_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_4=&C_end_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_5=&C_end_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_6=&C_end_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_6 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_7=&C_end_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_7 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_8=&C_end_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_8 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_9=&C_end_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_9 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_3_10=&C_end_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_3_10 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_1=&D_start_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_2=&D_start_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_3=&D_start_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_4=&D_start_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_5=&D_start_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_5 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_6=&D_start_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_6 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_7=&D_start_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_7 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_8=&D_start_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_8 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_9=&D_start_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_9 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_4_10=&D_start_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_4_10 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_1=&D_end_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_2=&D_end_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_3=&D_end_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_4=&D_end_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_5=&D_end_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_6=&D_end_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_6 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_7=&D_end_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_7 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_8=&D_end_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_8 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_9=&D_end_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_9 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_4_10=&D_end_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_4_10 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_1=&E_start_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_2=&E_start_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_3=&E_start_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_4=&E_start_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_5=&E_start_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_5 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_6=&E_start_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_6 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_7=&E_start_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_7 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_8=&E_start_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_8 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_9=&E_start_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_9 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_5_10=&E_start_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_5_10 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_1=&E_end_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_2=&E_end_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_3=&E_end_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_4=&E_end_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_5=&E_end_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_6=&E_end_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_6 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_7=&E_end_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_7 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_8=&E_end_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_8 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_9=&E_end_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_9 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_5_10=&E_end_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_5_10 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_1=&F_start_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_2=&F_start_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_3=&F_start_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_4=&F_start_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_5=&F_start_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_5 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_6=&F_start_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_6 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_7=&F_start_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_7 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_8=&F_start_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_8 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_9=&F_start_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_9 set to "" (string)
 CNSsolve>evaluate (&toppar.start_seg_6_10=&F_start_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.START_SEG_6_10 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_1=&F_end_seg_1) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_2=&F_end_seg_2) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_3=&F_end_seg_3) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_4=&F_end_seg_4) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_5=&F_end_seg_5) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_6=&F_end_seg_6) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_6 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_7=&F_end_seg_7) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_7 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_8=&F_end_seg_8) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_8 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_9=&F_end_seg_9) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_9 set to "" (string)
 CNSsolve>evaluate (&toppar.end_seg_6_10=&F_end_seg_10) 
 EVALUATE: symbol $_1_TOPPAR.END_SEG_6_10 set to "" (string)
 CNSsolve>evaluate (&toppar.nfle_1=&nfle_A) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_1 set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.start_fle_1_1=&A_start_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_1_2=&A_start_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_1_3=&A_start_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_1_4=&A_start_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_1_5=&A_start_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_1_1=&A_end_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_1_2=&A_end_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_1_3=&A_end_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_1_4=&A_end_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_1_5=&A_end_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.nfle_2=&nfle_B) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_2 set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.start_fle_2_1=&B_start_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_2_2=&B_start_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_2_3=&B_start_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_2_4=&B_start_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_2_5=&B_start_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_2_1=&B_end_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_2_2=&B_end_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_2_3=&B_end_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_2_4=&B_end_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_2_5=&B_end_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.nfle_3=&nfle_C) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_3 set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.start_fle_3_1=&C_start_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_3_2=&C_start_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_3_3=&C_start_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_3_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_3_4=&C_start_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_3_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_3_5=&C_start_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_3_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_3_1=&C_end_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_3_2=&C_end_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_3_3=&C_end_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_3_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_3_4=&C_end_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_3_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_3_5=&C_end_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_3_5 set to "" (string)
 CNSsolve>evaluate (&toppar.nfle_4=&nfle_D) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_4 set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.start_fle_4_1=&D_start_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_4_2=&D_start_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_4_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_4_3=&D_start_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_4_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_4_4=&D_start_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_4_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_4_5=&D_start_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_4_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_4_1=&D_end_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_4_2=&D_end_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_4_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_4_3=&D_end_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_4_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_4_4=&D_end_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_4_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_4_5=&D_end_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_4_5 set to "" (string)
 CNSsolve>evaluate (&toppar.nfle_5=&nfle_E) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_5 set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.start_fle_5_1=&E_start_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_5_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_5_2=&E_start_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_5_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_5_3=&E_start_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_5_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_5_4=&E_start_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_5_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_5_5=&E_start_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_5_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_5_1=&E_end_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_5_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_5_2=&E_end_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_5_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_5_3=&E_end_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_5_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_5_4=&E_end_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_5_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_5_5=&E_end_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_5_5 set to "" (string)
 CNSsolve>evaluate (&toppar.nfle_6=&nfle_F) 
 EVALUATE: symbol $_1_TOPPAR.NFLE_6 set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.start_fle_6_1=&F_start_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_6_1 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_6_2=&F_start_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_6_2 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_6_3=&F_start_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_6_3 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_6_4=&F_start_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_6_4 set to "" (string)
 CNSsolve>evaluate (&toppar.start_fle_6_5=&F_start_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.START_FLE_6_5 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_6_1=&F_end_fle_1) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_6_1 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_6_2=&F_end_fle_2) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_6_2 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_6_3=&F_end_fle_3) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_6_3 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_6_4=&F_end_fle_4) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_6_4 set to "" (string)
 CNSsolve>evaluate (&toppar.end_fle_6_5=&F_end_fle_5) 
 EVALUATE: symbol $_1_TOPPAR.END_FLE_6_5 set to "" (string)
 CNSsolve>evaluate (&data.numncs=&numncs) 
 EVALUATE: symbol $_1_DATA.NUMNCS set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.ncs_sta1_1=&ncs_sta1_1) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta1_2=&ncs_sta1_2) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta1_3=&ncs_sta1_3) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta1_4=&ncs_sta1_4) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta1_5=&ncs_sta1_5) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end1_1=&ncs_end1_1) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end1_2=&ncs_end1_2) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end1_3=&ncs_end1_3) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end1_4=&ncs_end1_4) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end1_5=&ncs_end1_5) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg1_1=&ncs_seg1_1) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg1_2=&ncs_seg1_2) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg1_3=&ncs_seg1_3) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg1_4=&ncs_seg1_4) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg1_5=&ncs_seg1_5) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta2_1=&ncs_sta2_1) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta2_2=&ncs_sta2_2) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta2_3=&ncs_sta2_3) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta2_4=&ncs_sta2_4) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_sta2_5=&ncs_sta2_5) 
 EVALUATE: symbol $_1_TOPPAR.NCS_STA2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end2_1=&ncs_end2_1) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end2_2=&ncs_end2_2) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end2_3=&ncs_end2_3) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end2_4=&ncs_end2_4) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_end2_5=&ncs_end2_5) 
 EVALUATE: symbol $_1_TOPPAR.NCS_END2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg2_1=&ncs_seg2_1) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg2_2=&ncs_seg2_2) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg2_3=&ncs_seg2_3) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg2_4=&ncs_seg2_4) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.ncs_seg2_5=&ncs_seg2_5) 
 EVALUATE: symbol $_1_TOPPAR.NCS_SEG2_5 set to "" (string)
 CNSsolve>evaluate (&data.numc2sym=&numc2sym) 
 EVALUATE: symbol $_1_DATA.NUMC2SYM set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.c2sym_sta1_1=&c2sym_sta1_1) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_2=&c2sym_sta1_2) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_3=&c2sym_sta1_3) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_4=&c2sym_sta1_4) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_5=&c2sym_sta1_5) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_6=&c2sym_sta1_6) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_6 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_7=&c2sym_sta1_7) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_7 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_8=&c2sym_sta1_8) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_8 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_9=&c2sym_sta1_8) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_9 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta1_10=&c2sym_sta1_10) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA1_10 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_1=&c2sym_end1_1) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_2=&c2sym_end1_2) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_3=&c2sym_end1_3) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_4=&c2sym_end1_4) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_5=&c2sym_end1_5) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_6=&c2sym_end1_6) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_6 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_7=&c2sym_end1_7) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_7 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_8=&c2sym_end1_8) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_8 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_9=&c2sym_end1_9) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_9 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end1_10=&c2sym_end1_10) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END1_10 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_1=&c2sym_seg1_1) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_2=&c2sym_seg1_2) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_3=&c2sym_seg1_3) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_4=&c2sym_seg1_4) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_5=&c2sym_seg1_5) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_5 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_6=&c2sym_seg1_6) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_6 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_7=&c2sym_seg1_7) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_7 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_8=&c2sym_seg1_8) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_8 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_9=&c2sym_seg1_9) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_9 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg1_10=&c2sym_seg1_10) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG1_10 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_1=&c2sym_sta2_1) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_2=&c2sym_sta2_2) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_3=&c2sym_sta2_3) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_4=&c2sym_sta2_4) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_5=&c2sym_sta2_5) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_6=&c2sym_sta2_6) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_6 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_7=&c2sym_sta2_7) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_7 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_8=&c2sym_sta2_8) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_8 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_9=&c2sym_sta2_9) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_9 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_sta2_10=&c2sym_sta2_10) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_STA2_10 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_1=&c2sym_end2_1) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_2=&c2sym_end2_2) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_3=&c2sym_end2_3) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_4=&c2sym_end2_4) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_5=&c2sym_end2_5) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_6=&c2sym_end2_6) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_6 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_7=&c2sym_end2_7) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_7 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_8=&c2sym_end2_8) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_8 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_9=&c2sym_end2_9) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_9 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_end2_10=&c2sym_end2_10) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_END2_10 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_1=&c2sym_seg2_1) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_2=&c2sym_seg2_2) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_3=&c2sym_seg2_3) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_4=&c2sym_seg2_4) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_5=&c2sym_seg2_5) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_5 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_6=&c2sym_seg2_6) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_6 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_7=&c2sym_seg2_7) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_7 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_8=&c2sym_seg2_8) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_8 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_9=&c2sym_seg2_9) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_9 set to "" (string)
 CNSsolve>evaluate (&toppar.c2sym_seg2_10=&c2sym_seg2_10) 
 EVALUATE: symbol $_1_TOPPAR.C2SYM_SEG2_10 set to "" (string)
 CNSsolve>evaluate (&data.numc3sym=&numc3sym) 
 EVALUATE: symbol $_1_DATA.NUMC3SYM set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.c3sym_sta1_1=&c3sym_sta1_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_STA1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_sta1_2=&c3sym_sta1_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_STA1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_sta2_1=&c3sym_sta2_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_STA2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_sta2_2=&c3sym_sta2_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_STA2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_sta3_1=&c3sym_sta3_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_STA3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_sta3_2=&c3sym_sta3_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_STA3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_end1_1=&c3sym_end1_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_END1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_end1_2=&c3sym_end1_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_END1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_end2_1=&c3sym_end2_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_END2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_end2_2=&c3sym_end2_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_END2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_end3_1=&c3sym_end3_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_END3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_end3_2=&c3sym_end3_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_END3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_seg1_1=&c3sym_seg1_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_SEG1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_seg1_2=&c3sym_seg1_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_SEG1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_seg2_1=&c3sym_seg2_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_SEG2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_seg2_2=&c3sym_seg2_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_SEG2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_seg3_1=&c3sym_seg3_1) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_SEG3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c3sym_seg3_2=&c3sym_seg3_2) 
 EVALUATE: symbol $_1_TOPPAR.C3SYM_SEG3_2 set to "" (string)
 CNSsolve>evaluate (&data.nums3sym=&nums3sym) 
 EVALUATE: symbol $_1_DATA.NUMS3SYM set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.s3sym_sta1_1=&s3sym_sta1_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta1_2=&s3sym_sta1_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta1_3=&s3sym_sta1_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta1_4=&s3sym_sta1_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta2_1=&s3sym_sta2_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta2_2=&s3sym_sta2_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta2_3=&s3sym_sta2_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta2_4=&s3sym_sta2_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta3_1=&s3sym_sta3_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta3_2=&s3sym_sta3_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta3_3=&s3sym_sta3_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA3_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_sta3_4=&s3sym_sta3_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_STA3_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end1_1=&s3sym_end1_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end1_2=&s3sym_end1_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end1_3=&s3sym_end1_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end1_4=&s3sym_end1_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end2_1=&s3sym_end2_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end2_2=&s3sym_end2_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end2_3=&s3sym_end2_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end2_4=&s3sym_end2_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end3_1=&s3sym_end3_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end3_2=&s3sym_end3_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end3_3=&s3sym_end3_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END3_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_end3_4=&s3sym_end3_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_END3_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg1_1=&s3sym_seg1_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg1_2=&s3sym_seg1_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg1_3=&s3sym_seg1_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG1_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg1_4=&s3sym_seg1_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG1_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg2_1=&s3sym_seg2_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg2_2=&s3sym_seg2_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg2_3=&s3sym_seg2_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG2_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg2_4=&s3sym_seg2_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG2_4 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg3_1=&s3sym_seg3_1) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg3_2=&s3sym_seg3_2) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg3_3=&s3sym_seg3_3) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG3_3 set to "" (string)
 CNSsolve>evaluate (&toppar.s3sym_seg3_4=&s3sym_seg3_4) 
 EVALUATE: symbol $_1_TOPPAR.S3SYM_SEG3_4 set to "" (string)
 CNSsolve>evaluate (&data.numc4sym=&numc4sym) 
 EVALUATE: symbol $_1_DATA.NUMC4SYM set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.c4sym_sta1_1=&c4sym_sta1_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_sta1_2=&c4sym_sta1_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_sta2_1=&c4sym_sta2_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_sta2_2=&c4sym_sta2_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_sta3_1=&c4sym_sta3_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_sta3_2=&c4sym_sta3_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_sta4_1=&c4sym_sta4_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_sta4_2=&c4sym_sta4_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_STA4_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end1_1=&c4sym_end1_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end1_2=&c4sym_end1_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end2_1=&c4sym_end2_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end2_2=&c4sym_end2_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end3_1=&c4sym_end3_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end3_2=&c4sym_end3_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end4_1=&c4sym_end4_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_end4_2=&c4sym_end4_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_END4_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg1_1=&c4sym_seg1_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg1_2=&c4sym_seg1_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG1_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg2_1=&c4sym_seg2_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg2_2=&c4sym_seg2_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG2_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg3_1=&c4sym_seg3_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg3_2=&c4sym_seg3_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG3_2 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg4_1=&c4sym_seg4_1) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c4sym_seg3_2=&c4sym_seg4_2) 
 EVALUATE: symbol $_1_TOPPAR.C4SYM_SEG3_2 set to "" (string)
 CNSsolve>evaluate (&data.numc5sym=&numc5sym) 
 EVALUATE: symbol $_1_DATA.NUMC5SYM set to    0.00000     (real)
 CNSsolve>evaluate (&toppar.c5sym_sta1_1=&c5sym_sta1_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_STA1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_sta2_1=&c5sym_sta2_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_STA2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_sta3_1=&c5sym_sta3_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_STA3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_sta4_1=&c5sym_sta4_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_STA4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_sta5_1=&c5sym_sta5_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_STA5_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_end1_1=&c5sym_end1_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_END1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_end2_1=&c5sym_end2_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_END2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_end3_1=&c5sym_end3_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_END3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_end4_1=&c5sym_end4_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_END4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_end5_1=&c5sym_end5_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_END5_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_seg1_1=&c5sym_seg1_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_SEG1_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_seg2_1=&c5sym_seg2_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_SEG2_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_seg3_1=&c5sym_seg3_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_SEG3_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_seg4_1=&c5sym_seg4_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_SEG4_1 set to "" (string)
 CNSsolve>evaluate (&toppar.c5sym_seg5_1=&c5sym_seg5_1) 
 EVALUATE: symbol $_1_TOPPAR.C5SYM_SEG5_1 set to "" (string)
 CNSsolve>if ( &data.numc2sym eq 6) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&iterations.rotate180 = false) 
 CNSsolve>end if 
 CNSsolve>if ( &data.numc3sym ne 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&iterations.rotate180 = false) 
 CNSsolve>end if 
 CNSsolve>if ( &data.numc4sym ne 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&iterations.rotate180 = false) 
 CNSsolve>end if 
 CNSsolve>if ( &data.numc5sym ne 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&iterations.rotate180 = false) 
 CNSsolve>end if 
 CNSsolve>evaluate (&toppar.xplortodiana=&xplortodiana) 
 EVALUATE: symbol $_1_TOPPAR.XPLORTODIANA set to FALSE (logical)
 CNSsolve>evaluate (&toppar.delenph=&delenph) 
 EVALUATE: symbol $_1_TOPPAR.DELENPH set to TRUE (logical)
 CNSsolve>evaluate (&toppar.nhisd=&numhisd) 
 EVALUATE: symbol $_1_TOPPAR.NHISD set to    10.0000     (real)
 CNSsolve>evaluate (&toppar.nhise=&numhise) 
 EVALUATE: symbol $_1_TOPPAR.NHISE set to    10.0000     (real)
 CNSsolve>evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_1 set to    109.000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_1 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    2.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_2 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    3.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_3 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    4.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_4 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    5.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_5 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    6.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_6 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    7.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_7 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    8.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_8 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    9.00000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_9 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    10.0000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_1_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_2_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_3_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_4_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_5_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISD_RESID_6_10 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    11.0000     (real)
 CNSsolve>end loop hisd 
 CNSsolve>while ($ncc <= &numhisd) loop hisd 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.hisd_resid_1_$ncc=&A_hisd_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hisd_resid_2_$ncc=&B_hisd_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hisd_resid_3_$ncc=&C_hisd_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hisd_resid_4_$ncc=&D_hisd_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hisd_resid_5_$ncc=&E_hisd_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hisd_resid_6_$ncc=&F_hisd_resid_$ncc) 
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 CNSsolve>end loop hisd 
 CNSsolve>evaluate ($ncc=1) 
 EVALUATE: symbol $NCC set to    1.00000     (real)
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_1 set to    192.000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_1 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_1 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    2.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_2 set to    197.000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_2 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_2 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    3.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_3 set to    139.000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_3 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_3 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    4.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_4 set to    77.0000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_4 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_4 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    5.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_5 set to    174.000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_5 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_5 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    6.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_6 set to    154.000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_6 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_6 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    7.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_7 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_7 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    8.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_8 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_8 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    9.00000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_9 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_9 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    10.0000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_1_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_2_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_3_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_4_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_5_10 set to    0.00000     (real)
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 EVALUATE: symbol $_1_TOPPAR.HISE_RESID_6_10 set to    0.00000     (real)
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 EVALUATE: symbol $NCC set to    11.0000     (real)
 CNSsolve>end loop hise 
 CNSsolve>while ($ncc <= &numhise) loop hise 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&toppar.hise_resid_1_$ncc=&A_hise_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hise_resid_2_$ncc=&B_hise_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hise_resid_3_$ncc=&C_hise_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hise_resid_4_$ncc=&D_hise_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hise_resid_5_$ncc=&E_hise_resid_$ncc) 
 CNSsolve>  evaluate (&toppar.hise_resid_6_$ncc=&F_hise_resid_$ncc) 
 CNSsolve>  evaluate ($ncc = $ncc + 1) 
 CNSsolve>end loop hise 
 CNSsolve>!Electrostatics: 
 CNSsolve>evaluate (&Data.flags.dihed = &dihedflag) 
 EVALUATE: symbol $_1_DATA.FLAGS.DIHED set to TRUE (logical)
 CNSsolve>evaluate (&Data.flags.elec0 = &elecflag_0) 
 EVALUATE: symbol $_1_DATA.FLAGS.ELEC0 set to TRUE (logical)
 CNSsolve>evaluate (&Data.flags.elec1 = &elecflag_1) 
 EVALUATE: symbol $_1_DATA.FLAGS.ELEC1 set to TRUE (logical)
 CNSsolve>evaluate (&Data.epsilon = &epsilon) 
 EVALUATE: symbol $_1_DATA.EPSILON set to    10.0000     (real)
 CNSsolve>evaluate (&Data.dielec  = &dielec) 
 Assuming literal string "CDIE"
 EVALUATE: symbol $_1_DATA.DIELEC set to "CDIE" (string)
 CNSsolve>!Interaction matrix: 
 CNSsolve>evaluate ($nmol1=1) 
 EVALUATE: symbol $NMOL1 set to    1.00000     (real)
 CNSsolve>while ($nmol1 <= 6) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    2.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_1 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_2 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_1 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    3.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_3 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_3_1 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    4.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_4 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_4_1 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    5.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_5 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_5_1 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    6.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_1_6 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_6_1 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    7.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    2.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= 6) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    3.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_2 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_3 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_3_2 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    4.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_4 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_4_2 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    5.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_5 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_5_2 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    6.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_2_6 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_6_2 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    7.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    3.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= 6) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    4.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_3_3 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_3_4 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_4_3 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    5.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_3_5 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_5_3 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    6.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_3_6 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_6_3 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    7.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    4.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= 6) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    5.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_4_4 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_4_5 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_5_4 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    6.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_4_6 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_6_4 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    7.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    5.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= 6) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    6.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_5_5 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_5_6 set to    1.00000     (real)
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 EVALUATE: symbol $_1_TOPPAR.INT_6_5 set to    1.00000     (real)
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 EVALUATE: symbol $NMOL2 set to    7.00000     (real)
 CNSsolve>  end loop mol2 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    6.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= 6) loop mol1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 EVALUATE: symbol $NMOL2 set to    7.00000     (real)
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 EVALUATE: symbol $_1_TOPPAR.INT_6_6 set to    1.00000     (real)
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 EVALUATE: symbol $NMOL1 set to    7.00000     (real)
 CNSsolve>end loop mol1 
 CNSsolve>while ($nmol1 <= 6) loop mol1 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($nmol2=$nmol1 + 1) 
 CNSsolve>  evaluate (&toppar.int_$nmol1_$nmol1 = &int_$nmol1_$nmol1) 
 CNSsolve>  while ($nmol2 <= 6) loop mol2 
 CNSsolve>    evaluate (&toppar.int_$nmol1_$nmol2 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate (&toppar.int_$nmol2_$nmol1 = &int_$nmol1_$nmol2) 
 CNSsolve>    evaluate ($nmol2=$nmol2 + 1) 
 CNSsolve>  end loop mol2 
 CNSsolve>  evaluate ($nmol1 = $nmol1 + 1) 
 CNSsolve>end loop mol1 
 CNSsolve>!Dihedrals, Jcouplings, Residual dipolar couplints, Hbonds, Analysis: 
 CNSsolve>evaluate (&Data.dnarest = &dnarest_on) 
 EVALUATE: symbol $_1_DATA.DNAREST set to FALSE (logical)
 CNSsolve>evaluate (&Data.flags.noe  =  true) 
 EVALUATE: symbol $_1_DATA.FLAGS.NOE set to TRUE (logical)
 CNSsolve>evaluate (&Data.flags.cdih =  &dihedrals_on) 
 EVALUATE: symbol $_1_DATA.FLAGS.CDIH set to FALSE (logical)
 CNSsolve>evaluate (&Data.cdih.on = &dihedrals_on) 
 EVALUATE: symbol $_1_DATA.CDIH.ON set to FALSE (logical)
 CNSsolve>evaluate (&Data.ssdihed = &ssdihed) 
 Assuming literal string "NONE"
 EVALUATE: symbol $_1_DATA.SSDIHED set to "NONE" (string)
 CNSsolve>evaluate (&Data.flags.coup =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.COUP set to FALSE (logical)
 CNSsolve>evaluate (&Data.flags.vean =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.VEAN set to FALSE (logical)
 CNSsolve>if (&rdc1_choice = "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.vean =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc2_choice = "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.vean =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc3_choice = "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.vean =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc4_choice = "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.vean =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc5_choice = "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.vean =  true) 
 CNSsolve>end if 
 CNSsolve>evaluate (&Data.flags.sani =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.SANI set to FALSE (logical)
 CNSsolve>if (&rdc1_choice = "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.sani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc2_choice = "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.sani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc3_choice = "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.sani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc4_choice = "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.sani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc5_choice = "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.sani =  true) 
 CNSsolve>end if 
 CNSsolve>evaluate (&Data.flags.xrdc =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.XRDC set to FALSE (logical)
 CNSsolve>if (&rdc1_choice = "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xrdc =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc2_choice = "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xrdc =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc3_choice = "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xrdc =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc4_choice = "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xrdc =  true) 
 CNSsolve>end if 
 CNSsolve>if (&rdc5_choice = "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xrdc =  true) 
 CNSsolve>end if 
 CNSsolve>evaluate (&Data.flags.xpcs =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.XPCS set to FALSE (logical)
 CNSsolve>if (&pcs1_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs2_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs3_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs4_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs5_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs6_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs7_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs8_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcs9_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>if (&pcsA_choice = "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.xpcs =  true) 
 CNSsolve>end if 
 CNSsolve>evaluate (&Data.flags.dani =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.DANI set to FALSE (logical)
 CNSsolve>if (&dan1_choice = "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.dani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&dan2_choice = "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.dani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&dan3_choice = "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.dani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&dan4_choice = "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.dani =  true) 
 CNSsolve>end if 
 CNSsolve>if (&dan5_choice = "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&Data.flags.dani =  true) 
 CNSsolve>end if 
 CNSsolve>evaluate (&Data.flags.plan =  false) 
 EVALUATE: symbol $_1_DATA.FLAGS.PLAN set to FALSE (logical)
 CNSsolve>evaluate (&Data.flags.ncs  =  &ncs_on) 
 EVALUATE: symbol $_1_DATA.FLAGS.NCS set to FALSE (logical)
 CNSsolve>evaluate (&Data.flags.sym  =  &sym_on) 
 EVALUATE: symbol $_1_DATA.FLAGS.SYM set to FALSE (logical)
 CNSsolve>evaluate (&data.scaling=&air_scaling) 
 EVALUATE: symbol $_1_DATA.SCALING set to FALSE (logical)
 CNSsolve>evaluate (&data.totnoe_unamb=&tot_unamb) 
 EVALUATE: symbol $_1_DATA.TOTNOE_UNAMB set to    25.0000     (real)
 CNSsolve>evaluate (&data.unamb_firstit=&unamb_firstit) 
 EVALUATE: symbol $_1_DATA.UNAMB_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.unamb_lastit=&unamb_lastit) 
 EVALUATE: symbol $_1_DATA.UNAMB_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.unamb_hot=&unamb_hot) 
 EVALUATE: symbol $_1_DATA.UNAMB_HOT set to    10.0000     (real)
 CNSsolve>evaluate (&data.unamb_cool1=&unamb_cool1) 
 EVALUATE: symbol $_1_DATA.UNAMB_COOL1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.unamb_cool2=&unamb_cool2) 
 EVALUATE: symbol $_1_DATA.UNAMB_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.unamb_cool3=&unamb_cool3) 
 EVALUATE: symbol $_1_DATA.UNAMB_COOL3 set to    50.0000     (real)
 CNSsolve>evaluate (&data.noecv=&noecv) 
 EVALUATE: symbol $_1_DATA.NOECV set to TRUE (logical)
 CNSsolve>evaluate (&data.ncvpart=&ncvpart) 
 EVALUATE: symbol $_1_DATA.NCVPART set to    2.00000     (real)
 CNSsolve>evaluate (&data.ranair=&ranair) 
 EVALUATE: symbol $_1_DATA.RANAIR set to FALSE (logical)
 CNSsolve>if (&data.ranair eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&data.noecv = false) 
 CNSsolve>end if 
 CNSsolve>evaluate (&data.cmrest=&cmrest) 
 EVALUATE: symbol $_1_DATA.CMREST set to TRUE (logical)
 CNSsolve>evaluate (&data.kcont=&kcont) 
 EVALUATE: symbol $_1_DATA.KCONT set to    1.00000     (real)
 CNSsolve>evaluate (&data.surfrest=&surfrest) 
 EVALUATE: symbol $_1_DATA.SURFREST set to TRUE (logical)
 CNSsolve>evaluate (&data.ksurf=&ksurf) 
 EVALUATE: symbol $_1_DATA.KSURF set to    1.00000     (real)
 CNSsolve>evaluate (&data.flags.rg=&rgrest) 
 EVALUATE: symbol $_1_DATA.FLAGS.RG set to FALSE (logical)
 CNSsolve>evaluate (&data.rgtarg=&rgtarg) 
 EVALUATE: symbol $_1_DATA.RGTARG set to    17.7800     (real)
 CNSsolve>evaluate (&data.krg_hot=&krg_hot) 
 EVALUATE: symbol $_1_DATA.KRG_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.krg_cool1=&krg_cool1) 
 EVALUATE: symbol $_1_DATA.KRG_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.krg_cool2=&krg_cool2) 
 EVALUATE: symbol $_1_DATA.KRG_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.krg_cool3=&krg_cool3) 
 EVALUATE: symbol $_1_DATA.KRG_COOL3 set to    100.000     (real)
 CNSsolve>evaluate (&data.rgsele=&rgsele) 
 EVALUATE: symbol $_1_DATA.RGSELE set to "all" (string)
 CNSsolve>evaluate (&data.totnoe_amb=&tot_amb) 
 EVALUATE: symbol $_1_DATA.TOTNOE_AMB set to    0.00000     (real)
 CNSsolve>evaluate (&data.amb_firstit=&amb_firstit) 
 EVALUATE: symbol $_1_DATA.AMB_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.amb_lastit=&amb_lastit) 
 EVALUATE: symbol $_1_DATA.AMB_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.amb_hot=&amb_hot) 
 EVALUATE: symbol $_1_DATA.AMB_HOT set to    10.0000     (real)
 CNSsolve>evaluate (&data.amb_cool1=&amb_cool1) 
 EVALUATE: symbol $_1_DATA.AMB_COOL1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.amb_cool2=&amb_cool2) 
 EVALUATE: symbol $_1_DATA.AMB_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.amb_cool3=&amb_cool3) 
 EVALUATE: symbol $_1_DATA.AMB_COOL3 set to    50.0000     (real)
 CNSsolve>evaluate (&data.kncs=&kncs) 
 EVALUATE: symbol $_1_DATA.KNCS set to    1.00000     (real)
 CNSsolve>evaluate (&data.ksym=&ksym) 
 EVALUATE: symbol $_1_DATA.KSYM set to    10.0000     (real)
 CNSsolve>evaluate (&data.hbond_firstit=&hbond_firstit) 
 EVALUATE: symbol $_1_DATA.HBOND_FIRSTIT set to    1.00000     (real)
 CNSsolve>evaluate (&data.hbond_lastit=&hbond_lastit) 
 EVALUATE: symbol $_1_DATA.HBOND_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.hbond_hot=&hbond_hot) 
 EVALUATE: symbol $_1_DATA.HBOND_HOT set to    10.0000     (real)
 CNSsolve>evaluate (&data.hbond_cool1=&hbond_cool1) 
 EVALUATE: symbol $_1_DATA.HBOND_COOL1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.hbond_cool2=&hbond_cool2) 
 EVALUATE: symbol $_1_DATA.HBOND_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.hbond_cool3=&hbond_cool3) 
 EVALUATE: symbol $_1_DATA.HBOND_COOL3 set to    50.0000     (real)
 CNSsolve>evaluate (&data.mrswi_hot=&mrswi_hot) 
 EVALUATE: symbol $_1_DATA.MRSWI_HOT set to   0.500000     (real)
 CNSsolve>evaluate (&data.mrswi_cool1=&mrswi_cool1) 
 EVALUATE: symbol $_1_DATA.MRSWI_COOL1 set to   0.500000     (real)
 CNSsolve>evaluate (&data.mrswi_cool2=&mrswi_cool2) 
 EVALUATE: symbol $_1_DATA.MRSWI_COOL2 set to   0.500000     (real)
 CNSsolve>evaluate (&data.mrswi_cool3=&mrswi_cool3) 
 EVALUATE: symbol $_1_DATA.MRSWI_COOL3 set to   0.500000     (real)
 CNSsolve>evaluate (&data.rswi_hot=&rswi_hot) 
 EVALUATE: symbol $_1_DATA.RSWI_HOT set to   0.500000     (real)
 CNSsolve>evaluate (&data.rswi_cool1=&rswi_cool1) 
 EVALUATE: symbol $_1_DATA.RSWI_COOL1 set to   0.500000     (real)
 CNSsolve>evaluate (&data.rswi_cool2=&rswi_cool2) 
 EVALUATE: symbol $_1_DATA.RSWI_COOL2 set to   0.500000     (real)
 CNSsolve>evaluate (&data.rswi_cool3=&rswi_cool3) 
 EVALUATE: symbol $_1_DATA.RSWI_COOL3 set to   0.500000     (real)
 CNSsolve>evaluate (&data.masy_hot=&masy_hot) 
 EVALUATE: symbol $_1_DATA.MASY_HOT set to   -1.00000     (real)
 CNSsolve>evaluate (&data.masy_cool1=&masy_cool1) 
 EVALUATE: symbol $_1_DATA.MASY_COOL1 set to   -1.00000     (real)
 CNSsolve>evaluate (&data.masy_cool2=&masy_cool2) 
 EVALUATE: symbol $_1_DATA.MASY_COOL2 set to  -0.100000     (real)
 CNSsolve>evaluate (&data.masy_cool3=&masy_cool3) 
 EVALUATE: symbol $_1_DATA.MASY_COOL3 set to  -0.100000     (real)
 CNSsolve>evaluate (&data.asy_hot=&asy_hot) 
 EVALUATE: symbol $_1_DATA.ASY_HOT set to    1.00000     (real)
 CNSsolve>evaluate (&data.asy_cool1=&asy_cool1) 
 EVALUATE: symbol $_1_DATA.ASY_COOL1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.asy_cool2=&asy_cool2) 
 EVALUATE: symbol $_1_DATA.ASY_COOL2 set to   0.100000     (real)
 CNSsolve>evaluate (&data.asy_cool3=&asy_cool3) 
 EVALUATE: symbol $_1_DATA.ASY_COOL3 set to   0.100000     (real)
 CNSsolve>evaluate (&data.dihedrals.on=&dihedrals_on) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS.ON set to FALSE (logical)
 CNSsolve>evaluate (&data.dihedrals_hot=&dihedrals_hot) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_HOT set to    5.00000     (real)
 CNSsolve>evaluate (&data.dihedrals_cool1=&dihedrals_cool1) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_COOL1 set to    5.00000     (real)
 CNSsolve>evaluate (&data.dihedrals_cool2=&dihedrals_cool2) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_COOL2 set to    50.0000     (real)
 CNSsolve>evaluate (&data.dihedrals_cool3=&dihedrals_cool3) 
 EVALUATE: symbol $_1_DATA.DIHEDRALS_COOL3 set to    200.000     (real)
 CNSsolve>evaluate (&data.hbonds_on=&hbonds_on) 
 EVALUATE: symbol $_1_DATA.HBONDS_ON set to FALSE (logical)
 CNSsolve>evaluate (&data.c1_on=&c1_on) 
 EVALUATE: symbol $_1_DATA.C1_ON set to FALSE (logical)
 CNSsolve>evaluate (&data.c1_karplusa=&c1_karplusa) 
 EVALUATE: symbol $_1_DATA.C1_KARPLUSA set to    6.98000     (real)
 CNSsolve>evaluate (&data.c1_karplusb=&c1_karplusb) 
 EVALUATE: symbol $_1_DATA.C1_KARPLUSB set to   -1.38000     (real)
 CNSsolve>evaluate (&data.c1_karplusc=&c1_karplusc) 
 EVALUATE: symbol $_1_DATA.C1_KARPLUSC set to    1.72000     (real)
 CNSsolve>evaluate (&data.c1_karplusd=&c1_karplusd) 
 EVALUATE: symbol $_1_DATA.C1_KARPLUSD set to   -60.0000     (real)
 CNSsolve>evaluate (&data.c1_hot=&c1_hot) 
 EVALUATE: symbol $_1_DATA.C1_HOT set to    0.00000     (real)
 CNSsolve>evaluate (&data.c1_cool1=&c1_cool1) 
 EVALUATE: symbol $_1_DATA.C1_COOL1 set to   0.200000     (real)
 CNSsolve>evaluate (&data.c1_cool2=&c1_cool2) 
 EVALUATE: symbol $_1_DATA.C1_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c1_cool3=&c1_cool3) 
 EVALUATE: symbol $_1_DATA.C1_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c2_on=&c2_on) 
 EVALUATE: symbol $_1_DATA.C2_ON set to FALSE (logical)
 CNSsolve>evaluate (&data.c2_karplusa=&c2_karplusa) 
 EVALUATE: symbol $_1_DATA.C2_KARPLUSA set to    6.98000     (real)
 CNSsolve>evaluate (&data.c2_karplusb=&c2_karplusb) 
 EVALUATE: symbol $_1_DATA.C2_KARPLUSB set to   -1.38000     (real)
 CNSsolve>evaluate (&data.c2_karplusc=&c2_karplusc) 
 EVALUATE: symbol $_1_DATA.C2_KARPLUSC set to    1.72000     (real)
 CNSsolve>evaluate (&data.c2_karplusd=&c2_karplusd) 
 EVALUATE: symbol $_1_DATA.C2_KARPLUSD set to   -120.000     (real)
 CNSsolve>evaluate (&data.c2_hot=&c2_hot) 
 EVALUATE: symbol $_1_DATA.C2_HOT set to    0.00000     (real)
 CNSsolve>evaluate (&data.c2_cool1=&c2_cool1) 
 EVALUATE: symbol $_1_DATA.C2_COOL1 set to   0.200000     (real)
 CNSsolve>evaluate (&data.c2_cool2=&c2_cool2) 
 EVALUATE: symbol $_1_DATA.C2_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c2_cool3=&c2_cool3) 
 EVALUATE: symbol $_1_DATA.C2_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c3_on=&c3_on) 
 EVALUATE: symbol $_1_DATA.C3_ON set to FALSE (logical)
 CNSsolve>evaluate (&data.c3_karplusa=&c3_karplusa) 
 EVALUATE: symbol $_1_DATA.C3_KARPLUSA set to    6.98000     (real)
 CNSsolve>evaluate (&data.c3_karplusb=&c3_karplusb) 
 EVALUATE: symbol $_1_DATA.C3_KARPLUSB set to   -1.38000     (real)
 CNSsolve>evaluate (&data.c3_karplusc=&c3_karplusc) 
 EVALUATE: symbol $_1_DATA.C3_KARPLUSC set to    1.72000     (real)
 CNSsolve>evaluate (&data.c3_karplusd=&c3_karplusd) 
 EVALUATE: symbol $_1_DATA.C3_KARPLUSD set to   -120.000     (real)
 CNSsolve>evaluate (&data.c3_hot=&c3_hot) 
 EVALUATE: symbol $_1_DATA.C3_HOT set to    0.00000     (real)
 CNSsolve>evaluate (&data.c3_cool1=&c3_cool1) 
 EVALUATE: symbol $_1_DATA.C3_COOL1 set to   0.200000     (real)
 CNSsolve>evaluate (&data.c3_cool2=&c3_cool2) 
 EVALUATE: symbol $_1_DATA.C3_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c3_cool3=&c3_cool3) 
 EVALUATE: symbol $_1_DATA.C3_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c4_on=&c4_on) 
 EVALUATE: symbol $_1_DATA.C4_ON set to FALSE (logical)
 CNSsolve>evaluate (&data.c4_karplusa=&c4_karplusa) 
 EVALUATE: symbol $_1_DATA.C4_KARPLUSA set to    6.98000     (real)
 CNSsolve>evaluate (&data.c4_karplusb=&c4_karplusb) 
 EVALUATE: symbol $_1_DATA.C4_KARPLUSB set to   -1.38000     (real)
 CNSsolve>evaluate (&data.c4_karplusc=&c4_karplusc) 
 EVALUATE: symbol $_1_DATA.C4_KARPLUSC set to    1.72000     (real)
 CNSsolve>evaluate (&data.c4_karplusd=&c4_karplusd) 
 EVALUATE: symbol $_1_DATA.C4_KARPLUSD set to   -120.000     (real)
 CNSsolve>evaluate (&data.c4_hot=&c4_hot) 
 EVALUATE: symbol $_1_DATA.C4_HOT set to    0.00000     (real)
 CNSsolve>evaluate (&data.c4_cool1=&c4_cool1) 
 EVALUATE: symbol $_1_DATA.C4_COOL1 set to   0.200000     (real)
 CNSsolve>evaluate (&data.c4_cool2=&c4_cool2) 
 EVALUATE: symbol $_1_DATA.C4_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c4_cool3=&c4_cool3) 
 EVALUATE: symbol $_1_DATA.C4_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c5_on=&c5_on) 
 EVALUATE: symbol $_1_DATA.C5_ON set to FALSE (logical)
 CNSsolve>evaluate (&data.c5_karplusa=&c5_karplusa) 
 EVALUATE: symbol $_1_DATA.C5_KARPLUSA set to    6.98000     (real)
 CNSsolve>evaluate (&data.c5_karplusb=&c5_karplusb) 
 EVALUATE: symbol $_1_DATA.C5_KARPLUSB set to   -1.38000     (real)
 CNSsolve>evaluate (&data.c5_karplusc=&c5_karplusc) 
 EVALUATE: symbol $_1_DATA.C5_KARPLUSC set to    1.72000     (real)
 CNSsolve>evaluate (&data.c5_karplusd=&c5_karplusd) 
 EVALUATE: symbol $_1_DATA.C5_KARPLUSD set to   -120.000     (real)
 CNSsolve>evaluate (&data.c5_hot=&c5_hot) 
 EVALUATE: symbol $_1_DATA.C5_HOT set to    0.00000     (real)
 CNSsolve>evaluate (&data.c5_cool1=&c5_cool1) 
 EVALUATE: symbol $_1_DATA.C5_COOL1 set to   0.200000     (real)
 CNSsolve>evaluate (&data.c5_cool2=&c5_cool2) 
 EVALUATE: symbol $_1_DATA.C5_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.c5_cool3=&c5_cool3) 
 EVALUATE: symbol $_1_DATA.C5_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc1_choice=&rdc1_choice) 
 EVALUATE: symbol $_1_DATA.RDC1_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.rdc1_firstIt=&rdc1_firstIt) 
 EVALUATE: symbol $_1_DATA.RDC1_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.rdc1_lastIt=&rdc1_lastIt) 
 EVALUATE: symbol $_1_DATA.RDC1_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.rdc1_hot=&rdc1_hot) 
 EVALUATE: symbol $_1_DATA.RDC1_HOT set to   0.100000     (real)
 CNSsolve>evaluate (&data.rdc1_cool1=&rdc1_cool1) 
 EVALUATE: symbol $_1_DATA.RDC1_COOL1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc1_cool2=&rdc1_cool2) 
 EVALUATE: symbol $_1_DATA.RDC1_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc1_cool3=&rdc1_cool3) 
 EVALUATE: symbol $_1_DATA.RDC1_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc1_r=&rdc1_r) 
 EVALUATE: symbol $_1_DATA.RDC1_R set to   0.400000     (real)
 CNSsolve>evaluate (&data.rdc1_d=&rdc1_d) 
 EVALUATE: symbol $_1_DATA.RDC1_D set to    8.00000     (real)
 CNSsolve>evaluate (&data.rdc2_choice=&rdc2_choice) 
 EVALUATE: symbol $_1_DATA.RDC2_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.rdc2_firstIt=&rdc2_firstIt) 
 EVALUATE: symbol $_1_DATA.RDC2_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.rdc2_lastIt=&rdc2_lastIt) 
 EVALUATE: symbol $_1_DATA.RDC2_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.rdc2_hot=&rdc2_hot) 
 EVALUATE: symbol $_1_DATA.RDC2_HOT set to   0.100000     (real)
 CNSsolve>evaluate (&data.rdc2_cool1=&rdc2_cool1) 
 EVALUATE: symbol $_1_DATA.RDC2_COOL1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc2_cool2=&rdc2_cool2) 
 EVALUATE: symbol $_1_DATA.RDC2_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc2_cool3=&rdc2_cool3) 
 EVALUATE: symbol $_1_DATA.RDC2_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc2_r=&rdc2_r) 
 EVALUATE: symbol $_1_DATA.RDC2_R set to   0.400000     (real)
 CNSsolve>evaluate (&data.rdc2_d=&rdc2_d) 
 EVALUATE: symbol $_1_DATA.RDC2_D set to    8.00000     (real)
 CNSsolve>evaluate (&data.rdc3_choice=&rdc3_choice) 
 EVALUATE: symbol $_1_DATA.RDC3_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.rdc3_firstIt=&rdc3_firstIt) 
 EVALUATE: symbol $_1_DATA.RDC3_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.rdc3_lastIt=&rdc3_lastIt) 
 EVALUATE: symbol $_1_DATA.RDC3_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.rdc3_hot=&rdc3_hot) 
 EVALUATE: symbol $_1_DATA.RDC3_HOT set to   0.100000     (real)
 CNSsolve>evaluate (&data.rdc3_cool1=&rdc3_cool1) 
 EVALUATE: symbol $_1_DATA.RDC3_COOL1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc3_cool2=&rdc3_cool2) 
 EVALUATE: symbol $_1_DATA.RDC3_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc3_cool3=&rdc3_cool3) 
 EVALUATE: symbol $_1_DATA.RDC3_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc3_r=&rdc3_r) 
 EVALUATE: symbol $_1_DATA.RDC3_R set to   0.400000     (real)
 CNSsolve>evaluate (&data.rdc3_d=&rdc3_d) 
 EVALUATE: symbol $_1_DATA.RDC3_D set to    8.00000     (real)
 CNSsolve>evaluate (&data.rdc4_choice=&rdc4_choice) 
 EVALUATE: symbol $_1_DATA.RDC4_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.rdc4_firstIt=&rdc4_firstIt) 
 EVALUATE: symbol $_1_DATA.RDC4_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.rdc4_lastIt=&rdc4_lastIt) 
 EVALUATE: symbol $_1_DATA.RDC4_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.rdc4_hot=&rdc4_hot) 
 EVALUATE: symbol $_1_DATA.RDC4_HOT set to   0.100000     (real)
 CNSsolve>evaluate (&data.rdc4_cool1=&rdc4_cool1) 
 EVALUATE: symbol $_1_DATA.RDC4_COOL1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc4_cool2=&rdc4_cool2) 
 EVALUATE: symbol $_1_DATA.RDC4_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc4_cool3=&rdc4_cool3) 
 EVALUATE: symbol $_1_DATA.RDC4_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc4_r=&rdc4_r) 
 EVALUATE: symbol $_1_DATA.RDC4_R set to   0.400000     (real)
 CNSsolve>evaluate (&data.rdc4_d=&rdc4_d) 
 EVALUATE: symbol $_1_DATA.RDC4_D set to    8.00000     (real)
 CNSsolve>evaluate (&data.rdc5_choice=&rdc5_choice) 
 EVALUATE: symbol $_1_DATA.RDC5_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.rdc5_firstIt=&rdc5_firstIt) 
 EVALUATE: symbol $_1_DATA.RDC5_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.rdc5_lastIt=&rdc5_lastIt) 
 EVALUATE: symbol $_1_DATA.RDC5_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.rdc5_hot=&rdc5_hot) 
 EVALUATE: symbol $_1_DATA.RDC5_HOT set to   0.100000     (real)
 CNSsolve>evaluate (&data.rdc5_cool1=&rdc5_cool1) 
 EVALUATE: symbol $_1_DATA.RDC5_COOL1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc5_cool2=&rdc5_cool2) 
 EVALUATE: symbol $_1_DATA.RDC5_COOL2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc5_cool3=&rdc5_cool3) 
 EVALUATE: symbol $_1_DATA.RDC5_COOL3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.rdc5_r=&rdc5_r) 
 EVALUATE: symbol $_1_DATA.RDC5_R set to   0.400000     (real)
 CNSsolve>evaluate (&data.rdc5_d=&rdc5_d) 
 EVALUATE: symbol $_1_DATA.RDC5_D set to    8.00000     (real)
 CNSsolve>evaluate (&data.pcs1_choice=&pcs1_choice) 
 EVALUATE: symbol $_1_DATA.PCS1_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs1_firstIt=&pcs1_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS1_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs1_lastIt=&pcs1_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS1_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs1_hot=&pcs1_hot) 
 EVALUATE: symbol $_1_DATA.PCS1_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs1_cool1=&pcs1_cool1) 
 EVALUATE: symbol $_1_DATA.PCS1_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs1_cool2=&pcs1_cool2) 
 EVALUATE: symbol $_1_DATA.PCS1_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs1_cool3=&pcs1_cool3) 
 EVALUATE: symbol $_1_DATA.PCS1_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs1_r=&pcs1_r) 
 EVALUATE: symbol $_1_DATA.PCS1_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs1_d=&pcs1_d) 
 EVALUATE: symbol $_1_DATA.PCS1_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs2_choice=&pcs2_choice) 
 EVALUATE: symbol $_1_DATA.PCS2_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs2_firstIt=&pcs2_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS2_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs2_lastIt=&pcs2_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS2_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs2_hot=&pcs2_hot) 
 EVALUATE: symbol $_1_DATA.PCS2_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs2_cool1=&pcs2_cool1) 
 EVALUATE: symbol $_1_DATA.PCS2_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs2_cool2=&pcs2_cool2) 
 EVALUATE: symbol $_1_DATA.PCS2_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs2_cool3=&pcs2_cool3) 
 EVALUATE: symbol $_1_DATA.PCS2_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs2_r=&pcs2_r) 
 EVALUATE: symbol $_1_DATA.PCS2_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs2_d=&pcs2_d) 
 EVALUATE: symbol $_1_DATA.PCS2_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs3_choice=&pcs3_choice) 
 EVALUATE: symbol $_1_DATA.PCS3_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs3_firstIt=&pcs3_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS3_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs3_lastIt=&pcs3_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS3_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs3_hot=&pcs3_hot) 
 EVALUATE: symbol $_1_DATA.PCS3_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs3_cool1=&pcs3_cool1) 
 EVALUATE: symbol $_1_DATA.PCS3_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs3_cool2=&pcs3_cool2) 
 EVALUATE: symbol $_1_DATA.PCS3_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs3_cool3=&pcs3_cool3) 
 EVALUATE: symbol $_1_DATA.PCS3_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs3_r=&pcs3_r) 
 EVALUATE: symbol $_1_DATA.PCS3_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs3_d=&pcs3_d) 
 EVALUATE: symbol $_1_DATA.PCS3_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs4_choice=&pcs4_choice) 
 EVALUATE: symbol $_1_DATA.PCS4_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs4_firstIt=&pcs4_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS4_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs4_lastIt=&pcs4_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS4_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs4_hot=&pcs4_hot) 
 EVALUATE: symbol $_1_DATA.PCS4_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs4_cool1=&pcs4_cool1) 
 EVALUATE: symbol $_1_DATA.PCS4_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs4_cool2=&pcs4_cool2) 
 EVALUATE: symbol $_1_DATA.PCS4_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs4_cool3=&pcs4_cool3) 
 EVALUATE: symbol $_1_DATA.PCS4_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs4_r=&pcs4_r) 
 EVALUATE: symbol $_1_DATA.PCS4_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs4_d=&pcs4_d) 
 EVALUATE: symbol $_1_DATA.PCS4_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs5_choice=&pcs5_choice) 
 EVALUATE: symbol $_1_DATA.PCS5_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs5_firstIt=&pcs5_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS5_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs5_lastIt=&pcs5_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS5_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs5_hot=&pcs5_hot) 
 EVALUATE: symbol $_1_DATA.PCS5_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs5_cool1=&pcs5_cool1) 
 EVALUATE: symbol $_1_DATA.PCS5_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs5_cool2=&pcs5_cool2) 
 EVALUATE: symbol $_1_DATA.PCS5_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs5_cool3=&pcs5_cool3) 
 EVALUATE: symbol $_1_DATA.PCS5_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs5_r=&pcs5_r) 
 EVALUATE: symbol $_1_DATA.PCS5_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs5_d=&pcs5_d) 
 EVALUATE: symbol $_1_DATA.PCS5_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs6_choice=&pcs6_choice) 
 EVALUATE: symbol $_1_DATA.PCS6_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs6_firstIt=&pcs6_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS6_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs6_lastIt=&pcs6_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS6_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs6_hot=&pcs6_hot) 
 EVALUATE: symbol $_1_DATA.PCS6_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs6_cool1=&pcs6_cool1) 
 EVALUATE: symbol $_1_DATA.PCS6_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs6_cool2=&pcs6_cool2) 
 EVALUATE: symbol $_1_DATA.PCS6_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs6_cool3=&pcs6_cool3) 
 EVALUATE: symbol $_1_DATA.PCS6_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs6_r=&pcs6_r) 
 EVALUATE: symbol $_1_DATA.PCS6_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs6_d=&pcs6_d) 
 EVALUATE: symbol $_1_DATA.PCS6_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs7_choice=&pcs7_choice) 
 EVALUATE: symbol $_1_DATA.PCS7_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs7_firstIt=&pcs7_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS7_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs7_lastIt=&pcs7_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS7_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs7_hot=&pcs7_hot) 
 EVALUATE: symbol $_1_DATA.PCS7_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs7_cool1=&pcs7_cool1) 
 EVALUATE: symbol $_1_DATA.PCS7_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs7_cool2=&pcs7_cool2) 
 EVALUATE: symbol $_1_DATA.PCS7_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs7_cool3=&pcs7_cool3) 
 EVALUATE: symbol $_1_DATA.PCS7_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs7_r=&pcs7_r) 
 EVALUATE: symbol $_1_DATA.PCS7_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs7_d=&pcs7_d) 
 EVALUATE: symbol $_1_DATA.PCS7_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs8_choice=&pcs8_choice) 
 EVALUATE: symbol $_1_DATA.PCS8_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs8_firstIt=&pcs8_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS8_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs8_lastIt=&pcs8_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS8_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs8_hot=&pcs8_hot) 
 EVALUATE: symbol $_1_DATA.PCS8_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs8_cool1=&pcs8_cool1) 
 EVALUATE: symbol $_1_DATA.PCS8_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs8_cool2=&pcs8_cool2) 
 EVALUATE: symbol $_1_DATA.PCS8_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs8_cool3=&pcs8_cool3) 
 EVALUATE: symbol $_1_DATA.PCS8_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs8_r=&pcs8_r) 
 EVALUATE: symbol $_1_DATA.PCS8_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs8_d=&pcs8_d) 
 EVALUATE: symbol $_1_DATA.PCS8_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcs9_choice=&pcs9_choice) 
 EVALUATE: symbol $_1_DATA.PCS9_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcs9_firstIt=&pcs9_firstIt) 
 EVALUATE: symbol $_1_DATA.PCS9_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcs9_lastIt=&pcs9_lastIt) 
 EVALUATE: symbol $_1_DATA.PCS9_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcs9_hot=&pcs9_hot) 
 EVALUATE: symbol $_1_DATA.PCS9_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs9_cool1=&pcs9_cool1) 
 EVALUATE: symbol $_1_DATA.PCS9_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs9_cool2=&pcs9_cool2) 
 EVALUATE: symbol $_1_DATA.PCS9_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcs9_cool3=&pcs9_cool3) 
 EVALUATE: symbol $_1_DATA.PCS9_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs9_r=&pcs9_r) 
 EVALUATE: symbol $_1_DATA.PCS9_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcs9_d=&pcs9_d) 
 EVALUATE: symbol $_1_DATA.PCS9_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.pcsA_choice=&pcsA_choice) 
 EVALUATE: symbol $_1_DATA.PCSA_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.pcsA_firstIt=&pcsA_firstIt) 
 EVALUATE: symbol $_1_DATA.PCSA_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.pcsA_lastIt=&pcsA_lastIt) 
 EVALUATE: symbol $_1_DATA.PCSA_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.pcsA_hot=&pcsA_hot) 
 EVALUATE: symbol $_1_DATA.PCSA_HOT set to    100.000     (real)
 CNSsolve>evaluate (&data.pcsA_cool1=&pcsA_cool1) 
 EVALUATE: symbol $_1_DATA.PCSA_COOL1 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcsA_cool2=&pcsA_cool2) 
 EVALUATE: symbol $_1_DATA.PCSA_COOL2 set to    100.000     (real)
 CNSsolve>evaluate (&data.pcsA_cool3=&pcsA_cool3) 
 EVALUATE: symbol $_1_DATA.PCSA_COOL3 set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcsA_r=&pcsA_r) 
 EVALUATE: symbol $_1_DATA.PCSA_R set to    1000.00     (real)
 CNSsolve>evaluate (&data.pcsA_d=&pcsA_d) 
 EVALUATE: symbol $_1_DATA.PCSA_D set to    10000.0     (real)
 CNSsolve>evaluate (&data.dan1_choice=&dan1_choice) 
 EVALUATE: symbol $_1_DATA.DAN1_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.dan1_firstIt=&dan1_firstIt) 
 EVALUATE: symbol $_1_DATA.DAN1_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.dan1_lastIt=&dan1_lastIt) 
 EVALUATE: symbol $_1_DATA.DAN1_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.dan1_hot=&dan1_hot) 
 EVALUATE: symbol $_1_DATA.DAN1_HOT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan1_cool1=&dan1_cool1) 
 EVALUATE: symbol $_1_DATA.DAN1_COOL1 set to    5.00000     (real)
 CNSsolve>evaluate (&data.dan1_cool2=&dan1_cool2) 
 EVALUATE: symbol $_1_DATA.DAN1_COOL2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan1_cool3=&dan1_cool3) 
 EVALUATE: symbol $_1_DATA.DAN1_COOL3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan1_tc=&dan1_tc) 
 EVALUATE: symbol $_1_DATA.DAN1_TC set to    9.77100     (real)
 CNSsolve>evaluate (&data.dan1_anis=&dan1_anis) 
 EVALUATE: symbol $_1_DATA.DAN1_ANIS set to    1.55700     (real)
 CNSsolve>evaluate (&data.dan1_r=&dan1_r) 
 EVALUATE: symbol $_1_DATA.DAN1_R set to   0.455000     (real)
 CNSsolve>evaluate (&data.dan1_wh=&dan1_wh) 
 EVALUATE: symbol $_1_DATA.DAN1_WH set to    599.910     (real)
 CNSsolve>evaluate (&data.dan1_wn=&dan1_wn) 
 EVALUATE: symbol $_1_DATA.DAN1_WN set to    60.8200     (real)
 CNSsolve>evaluate (&data.dan2_choice=&dan2_choice) 
 EVALUATE: symbol $_1_DATA.DAN2_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.dan2_firstIt=&dan2_firstIt) 
 EVALUATE: symbol $_1_DATA.DAN2_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.dan2_lastIt=&dan2_lastIt) 
 EVALUATE: symbol $_1_DATA.DAN2_LASTIT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan2_hot=&dan2_hot) 
 EVALUATE: symbol $_1_DATA.DAN2_HOT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan2_cool1=&dan2_cool1) 
 EVALUATE: symbol $_1_DATA.DAN2_COOL1 set to    5.00000     (real)
 CNSsolve>evaluate (&data.dan2_cool2=&dan2_cool2) 
 EVALUATE: symbol $_1_DATA.DAN2_COOL2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan2_cool3=&dan2_cool3) 
 EVALUATE: symbol $_1_DATA.DAN2_COOL3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan2_tc=&dan2_tc) 
 EVALUATE: symbol $_1_DATA.DAN2_TC set to    9.84000     (real)
 CNSsolve>evaluate (&data.dan2_anis=&dan2_anis) 
 EVALUATE: symbol $_1_DATA.DAN2_ANIS set to   -1.35000     (real)
 CNSsolve>evaluate (&data.dan2_r=&dan2_r) 
 EVALUATE: symbol $_1_DATA.DAN2_R set to   0.308000     (real)
 CNSsolve>evaluate (&data.dan2_wh=&dan2_wh) 
 EVALUATE: symbol $_1_DATA.DAN2_WH set to    599.910     (real)
 CNSsolve>evaluate (&data.dan2_wn=&dan2_wn) 
 EVALUATE: symbol $_1_DATA.DAN2_WN set to    60.8200     (real)
 CNSsolve>evaluate (&data.dan3_choice=&dan3_choice) 
 EVALUATE: symbol $_1_DATA.DAN3_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.dan3_firstIt=&dan3_firstIt) 
 EVALUATE: symbol $_1_DATA.DAN3_FIRSTIT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan3_lastIt=&dan3_lastIt) 
 EVALUATE: symbol $_1_DATA.DAN3_LASTIT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan3_hot=&dan3_hot) 
 EVALUATE: symbol $_1_DATA.DAN3_HOT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan3_cool1=&dan3_cool1) 
 EVALUATE: symbol $_1_DATA.DAN3_COOL1 set to    5.00000     (real)
 CNSsolve>evaluate (&data.dan3_cool2=&dan3_cool2) 
 EVALUATE: symbol $_1_DATA.DAN3_COOL2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan3_cool3=&dan3_cool3) 
 EVALUATE: symbol $_1_DATA.DAN3_COOL3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan3_tc=&dan3_tc) 
 EVALUATE: symbol $_1_DATA.DAN3_TC set to    9.84000     (real)
 CNSsolve>evaluate (&data.dan3_anis=&dan3_anis) 
 EVALUATE: symbol $_1_DATA.DAN3_ANIS set to   -1.35000     (real)
 CNSsolve>evaluate (&data.dan3_r=&dan3_r) 
 EVALUATE: symbol $_1_DATA.DAN3_R set to   0.308000     (real)
 CNSsolve>evaluate (&data.dan3_wh=&dan3_wh) 
 EVALUATE: symbol $_1_DATA.DAN3_WH set to    599.910     (real)
 CNSsolve>evaluate (&data.dan3_wn=&dan3_wn) 
 EVALUATE: symbol $_1_DATA.DAN3_WN set to    60.8200     (real)
 CNSsolve>evaluate (&data.dan4_choice=&dan4_choice) 
 EVALUATE: symbol $_1_DATA.DAN4_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.dan4_firstIt=&dan4_firstIt) 
 EVALUATE: symbol $_1_DATA.DAN4_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.dan4_lastIt=&dan4_lastIt) 
 EVALUATE: symbol $_1_DATA.DAN4_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.dan4_hot=&dan4_hot) 
 EVALUATE: symbol $_1_DATA.DAN4_HOT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan4_cool1=&dan4_cool1) 
 EVALUATE: symbol $_1_DATA.DAN4_COOL1 set to    5.00000     (real)
 CNSsolve>evaluate (&data.dan4_cool2=&dan4_cool2) 
 EVALUATE: symbol $_1_DATA.DAN4_COOL2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan4_cool3=&dan4_cool3) 
 EVALUATE: symbol $_1_DATA.DAN4_COOL3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan4_tc=&dan4_tc) 
 EVALUATE: symbol $_1_DATA.DAN4_TC set to    9.84000     (real)
 CNSsolve>evaluate (&data.dan4_anis=&dan4_anis) 
 EVALUATE: symbol $_1_DATA.DAN4_ANIS set to   -1.35000     (real)
 CNSsolve>evaluate (&data.dan4_r=&dan4_r) 
 EVALUATE: symbol $_1_DATA.DAN4_R set to   0.308000     (real)
 CNSsolve>evaluate (&data.dan4_wh=&dan4_wh) 
 EVALUATE: symbol $_1_DATA.DAN4_WH set to    599.910     (real)
 CNSsolve>evaluate (&data.dan4_wn=&dan4_wn) 
 EVALUATE: symbol $_1_DATA.DAN4_WN set to    60.8200     (real)
 CNSsolve>evaluate (&data.dan5_choice=&dan5_choice) 
 EVALUATE: symbol $_1_DATA.DAN5_CHOICE set to "NO" (string)
 CNSsolve>evaluate (&data.dan5_firstIt=&dan5_firstIt) 
 EVALUATE: symbol $_1_DATA.DAN5_FIRSTIT set to    0.00000     (real)
 CNSsolve>evaluate (&data.dan5_lastIt=&dan5_lastIt) 
 EVALUATE: symbol $_1_DATA.DAN5_LASTIT set to    2.00000     (real)
 CNSsolve>evaluate (&data.dan5_hot=&dan5_hot) 
 EVALUATE: symbol $_1_DATA.DAN5_HOT set to    1.00000     (real)
 CNSsolve>evaluate (&data.dan5_cool1=&dan5_cool1) 
 EVALUATE: symbol $_1_DATA.DAN5_COOL1 set to    5.00000     (real)
 CNSsolve>evaluate (&data.dan5_cool2=&dan5_cool2) 
 EVALUATE: symbol $_1_DATA.DAN5_COOL2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan5_cool3=&dan5_cool3) 
 EVALUATE: symbol $_1_DATA.DAN5_COOL3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.dan5_tc=&dan5_tc) 
 EVALUATE: symbol $_1_DATA.DAN5_TC set to    9.84000     (real)
 CNSsolve>evaluate (&data.dan5_anis=&dan5_anis) 
 EVALUATE: symbol $_1_DATA.DAN5_ANIS set to   -1.35000     (real)
 CNSsolve>evaluate (&data.dan5_r=&dan5_r) 
 EVALUATE: symbol $_1_DATA.DAN5_R set to   0.308000     (real)
 CNSsolve>evaluate (&data.dan5_wh=&dan5_wh) 
 EVALUATE: symbol $_1_DATA.DAN5_WH set to    599.910     (real)
 CNSsolve>evaluate (&data.dan5_wn=&dan5_wn) 
 EVALUATE: symbol $_1_DATA.DAN5_WN set to    60.8200     (real)
 CNSsolve>!VEAN statement: 
 CNSsolve>evaluate (&data.ini_bor_hot_1=&ini_bor_hot_1) 
 EVALUATE: symbol $_1_DATA.INI_BOR_HOT_1 set to    1.00000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool1_1=&ini_bor_cool1_1) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL1_1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool2_1=&ini_bor_cool2_1) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL2_1 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool3_1=&ini_bor_cool3_1) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL3_1 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_hot_1=&ini_cen_hot_1) 
 EVALUATE: symbol $_1_DATA.INI_CEN_HOT_1 set to   0.250000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool1_1=&ini_cen_cool1_1) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL1_1 set to    2.50000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool2_1=&ini_cen_cool2_1) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL2_1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool3_1=&ini_cen_cool3_1) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL3_1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_hot_1=&fin_bor_hot_1) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_HOT_1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool1_1=&fin_bor_cool1_1) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL1_1 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool2_1=&fin_bor_cool2_1) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL2_1 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool3_1=&fin_bor_cool3_1) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL3_1 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_hot_1=&fin_cen_hot_1) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_HOT_1 set to    2.50000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool1_1=&fin_cen_cool1_1) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL1_1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool2_1=&fin_cen_cool2_1) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL2_1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool3_1=&fin_cen_cool3_1) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL3_1 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_hot_2=&ini_bor_hot_2) 
 EVALUATE: symbol $_1_DATA.INI_BOR_HOT_2 set to    1.00000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool1_2=&ini_bor_cool1_2) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL1_2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool2_2=&ini_bor_cool2_2) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL2_2 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool3_2=&ini_bor_cool3_2) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL3_2 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_hot_2=&ini_cen_hot_2) 
 EVALUATE: symbol $_1_DATA.INI_CEN_HOT_2 set to   0.250000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool1_2=&ini_cen_cool1_2) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL1_2 set to    2.50000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool2_2=&ini_cen_cool2_2) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL2_2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool3_2=&ini_cen_cool3_2) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL3_2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_hot_2=&fin_bor_hot_2) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_HOT_2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool1_2=&fin_bor_cool1_2) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL1_2 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool2_2=&fin_bor_cool2_2) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL2_2 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool3_2=&fin_bor_cool3_2) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL3_2 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_hot_2=&fin_cen_hot_2) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_HOT_2 set to    2.50000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool1_2=&fin_cen_cool1_2) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL1_2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool2_2=&fin_cen_cool2_2) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL2_2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool3_2=&fin_cen_cool3_2) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL3_2 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_hot_3=&ini_bor_hot_3) 
 EVALUATE: symbol $_1_DATA.INI_BOR_HOT_3 set to    1.00000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool1_3=&ini_bor_cool1_3) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL1_3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool2_3=&ini_bor_cool2_3) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL2_3 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool3_3=&ini_bor_cool3_3) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL3_3 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_hot_3=&ini_cen_hot_3) 
 EVALUATE: symbol $_1_DATA.INI_CEN_HOT_3 set to   0.250000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool1_3=&ini_cen_cool1_3) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL1_3 set to    2.50000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool2_3=&ini_cen_cool2_3) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL2_3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool3_3=&ini_cen_cool3_3) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL3_3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_hot_3=&fin_bor_hot_3) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_HOT_3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool1_3=&fin_bor_cool1_3) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL1_3 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool2_3=&fin_bor_cool2_3) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL2_3 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool3_3=&fin_bor_cool3_3) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL3_3 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_hot_3=&fin_cen_hot_3) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_HOT_3 set to    2.50000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool1_3=&fin_cen_cool1_3) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL1_3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool2_3=&fin_cen_cool2_3) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL2_3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool3_3=&fin_cen_cool3_3) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL3_3 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_hot_4=&ini_bor_hot_4) 
 EVALUATE: symbol $_1_DATA.INI_BOR_HOT_4 set to    1.00000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool1_4=&ini_bor_cool1_4) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL1_4 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool2_4=&ini_bor_cool2_4) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL2_4 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool3_4=&ini_bor_cool3_4) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL3_4 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_hot_4=&ini_cen_hot_4) 
 EVALUATE: symbol $_1_DATA.INI_CEN_HOT_4 set to   0.250000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool1_4=&ini_cen_cool1_4) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL1_4 set to    2.50000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool2_4=&ini_cen_cool2_4) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL2_4 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool3_4=&ini_cen_cool3_4) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL3_4 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_hot_4=&fin_bor_hot_4) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_HOT_4 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool1_4=&fin_bor_cool1_4) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL1_4 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool2_4=&fin_bor_cool2_4) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL2_4 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool3_4=&fin_bor_cool3_4) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL3_4 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_hot_4=&fin_cen_hot_4) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_HOT_4 set to    2.50000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool1_4=&fin_cen_cool1_4) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL1_4 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool2_4=&fin_cen_cool2_4) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL2_4 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool3_4=&fin_cen_cool3_4) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL3_4 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_hot_5=&ini_bor_hot_5) 
 EVALUATE: symbol $_1_DATA.INI_BOR_HOT_5 set to    1.00000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool1_5=&ini_bor_cool1_5) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL1_5 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool2_5=&ini_bor_cool2_5) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL2_5 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_bor_cool3_5=&ini_bor_cool3_5) 
 EVALUATE: symbol $_1_DATA.INI_BOR_COOL3_5 set to    40.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_hot_5=&ini_cen_hot_5) 
 EVALUATE: symbol $_1_DATA.INI_CEN_HOT_5 set to   0.250000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool1_5=&ini_cen_cool1_5) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL1_5 set to    2.50000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool2_5=&ini_cen_cool2_5) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL2_5 set to    10.0000     (real)
 CNSsolve>evaluate (&data.ini_cen_cool3_5=&ini_cen_cool3_5) 
 EVALUATE: symbol $_1_DATA.INI_CEN_COOL3_5 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_hot_5=&fin_bor_hot_5) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_HOT_5 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool1_5=&fin_bor_cool1_5) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL1_5 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool2_5=&fin_bor_cool2_5) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL2_5 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_bor_cool3_5=&fin_bor_cool3_5) 
 EVALUATE: symbol $_1_DATA.FIN_BOR_COOL3_5 set to    40.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_hot_5=&fin_cen_hot_5) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_HOT_5 set to    2.50000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool1_5=&fin_cen_cool1_5) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL1_5 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool2_5=&fin_cen_cool2_5) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL2_5 set to    10.0000     (real)
 CNSsolve>evaluate (&data.fin_cen_cool3_5=&fin_cen_cool3_5) 
 EVALUATE: symbol $_1_DATA.FIN_CEN_COOL3_5 set to    10.0000     (real)
 CNSsolve>!intermolecular contacts analysis 
 CNSsolve>evaluate (&data.hb_dist=&dist_hb) 
 EVALUATE: symbol $_1_DATA.HB_DIST set to    2.50000     (real)
 CNSsolve>evaluate (&data.nb_dist=&dist_nb) 
 EVALUATE: symbol $_1_DATA.NB_DIST set to    3.90000     (real)
 CNSsolve>!water refinement 
 CNSsolve>evaluate (&refine.firstwater=&firstwater) 
 EVALUATE: symbol $_1_REFINE.FIRSTWATER set to "yes" (string)
 CNSsolve>evaluate (&refine.keepwater=&keepwater) 
 EVALUATE: symbol $_1_REFINE.KEEPWATER set to FALSE (logical)
 CNSsolve>evaluate (&refine.waterrefine=min(&structures_1,&waterrefine)) 
 EVALUATE: symbol $_1_REFINE.WATERREFINE set to    20.0000     (real)
 CNSsolve>evaluate (&refine.solvent=&solvent) 
 EVALUATE: symbol $_1_REFINE.SOLVENT set to "water" (string)
 CNSsolve>evaluate (&refine.pmrefine_on=&pmrefine_on) 
 Assuming literal string "&PMREFINE_ON"
 EVALUATE: symbol $_1_REFINE.PMREFINE_ON set to "&PMREFINE_ON" (string)
 CNSsolve>evaluate (&refine.calcdesolv=&calcdesolv) 
 EVALUATE: symbol $_1_REFINE.CALCDESOLV set to FALSE (logical)
 CNSsolve>evaluate (&refine.heatsteps=&waterheatsteps) 
 EVALUATE: symbol $_1_REFINE.HEATSTEPS set to    100.000     (real)
 CNSsolve>evaluate (&refine.steps=&watersteps) 
 EVALUATE: symbol $_1_REFINE.STEPS set to    1250.00     (real)
 CNSsolve>evaluate (&refine.coolsteps=&watercoolsteps) 
 EVALUATE: symbol $_1_REFINE.COOLSTEPS set to    500.000     (real)
 CNSsolve>!for the non-bonded parameters (the section was taken out of 
 CNSsolve>!parallhdg5.0.pro and parallhdg5.1.pro, so be careful!): 
 CNSsolve>if (&toppar.par_nonbonded eq "PROLSQ") then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.repel_radius = 1.0) 
 CNSsolve>    evaluate (&toppar.repel_rcons = 20) 
 CNSsolve>    evaluate (&toppar.repel_rexpo  = 4) 
 CNSsolve>    evaluate (&toppar.repel_irexp  = 1) 
 CNSsolve>elseif (&toppar.par_nonbonded eq "PARMALLH6") then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate (&toppar.repel_radius = 0.8) 
 CNSsolve>    evaluate (&toppar.repel_rcons = 5.0) 
 CNSsolve>    evaluate (&toppar.repel_rexpo  = 2) 
 CNSsolve>    evaluate (&toppar.repel_irexp  = 2) 
 CNSsolve>elseif (&toppar.par_nonbonded eq "OPLSX") then 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate (&toppar.repel_radius = 0.0) 
 EVALUATE: symbol $_1_TOPPAR.REPEL_RADIUS set to    0.00000     (real)
 CNSsolve>else        {...now the standard PARALLHDG parameters} 
 CNSsolve>    evaluate (&toppar.repel_radius = 0.78) 
 CNSsolve>    evaluate (&toppar.repel_rcons = 5.0) 
 CNSsolve>    evaluate (&toppar.repel_rexpo  = 2) 
 CNSsolve>    evaluate (&toppar.repel_irexp  = 2) 
 CNSsolve>end if 
 CNSsolve>! Water in rigid body docking 
 CNSsolve>evaluate (&data.waterdock=&waterdock) 
 EVALUATE: symbol $_1_DATA.WATERDOCK set to FALSE (logical)
 CNSsolve>evaluate (&data.db_method=&db_method) 
 EVALUATE: symbol $_1_DATA.DB_METHOD set to "kytedoolittle" (string)
 CNSsolve>evaluate (&data.water_tokeep=&water_tokeep) 
 EVALUATE: symbol $_1_DATA.WATER_TOKEEP set to   0.250000     (real)
 CNSsolve>evaluate (&data.dnap_water_tokeep=&dnap_water_tokeep) 
 EVALUATE: symbol $_1_DATA.DNAP_WATER_TOKEEP set to   0.250000     (real)
 CNSsolve>evaluate (&data.water_randfrac=&water_randfrac) 
 EVALUATE: symbol $_1_DATA.WATER_RANDFRAC set to    0.00000     (real)
 CNSsolve>evaluate (&data.solvate_method=&solvate_method) 
 EVALUATE: symbol $_1_DATA.SOLVATE_METHOD set to "db" (string)
 CNSsolve>evaluate (&data.water_surfcutoff=&water_surfcutoff) 
 EVALUATE: symbol $_1_DATA.WATER_SURFCUTOFF set to    8.00000     (real)
 CNSsolve>evaluate (&data.water_analysis=&water_analysis) 
 EVALUATE: symbol $_1_DATA.WATER_ANALYSIS set to FALSE (logical)
 CNSsolve>evaluate (&data.transwater=&transwater) 
 EVALUATE: symbol $_1_DATA.TRANSWATER set to TRUE (logical)
 CNSsolve>evaluate (&data.water_restraint_initial=&water_restraint_initial) 
 EVALUATE: symbol $_1_DATA.WATER_RESTRAINT_INITIAL set to    5.00000     (real)
 CNSsolve>evaluate (&data.water_restraint_cutoff=&water_restraint_cutoff) 
 EVALUATE: symbol $_1_DATA.WATER_RESTRAINT_CUTOFF set to    5.00000     (real)
 CNSsolve>evaluate (&data.water_restraint_scale=&water_restraint_scale) 
 EVALUATE: symbol $_1_DATA.WATER_RESTRAINT_SCALE set to    25.0000     (real)
 CNSsolve>evaluate (&data.waterensemble=&waterensemble) 
 EVALUATE: symbol $_1_DATA.WATERENSEMBLE set to    1.00000     (real)
 CNSsolve>if (&data.waterdock eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate (&iterations.rotate180   = false) 
 CNSsolve>  evaluate (&SaProtocol.initiosteps = 0) 
 CNSsolve>  evaluate (&SaProtocol.cool1_steps = 0) 
 CNSsolve>  evaluate (&refine.keepwater = true) 
 CNSsolve>  display SOLVATED DOCKING TURNED ON: initiosteps and cool1_steps set to 0, rotate180 set to false 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($log_level=quiet) 
 Assuming literal string "QUIET"
 EVALUATE: symbol $LOG_LEVEL set to "QUIET" (string)
 CNSsolve>!evaluate ($log_level=verbose) 
 CNSsolve> 
 CNSsolve>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   set message=normal echo=on end 
 CNSsolve>else 
 CNSsolve>   set message=off echo=off end 
 REMARKS FILENAME="complex.psf"
 REMARKS coordinates built for atom:      AEE  1    HAA
 REMARKS coordinates built for atom:      AEE  1    HAB
 REMARKS coordinates built for atom:      AEE  1    HAD
 REMARKS coordinates built for atom:      AEE  1    HAC
 REMARKS DATE:28-Dec-2019  21:11:31       created by user: enmr
 REMARKS VERSION:1.3U
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle C3R  OH   HO  
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of angle HR   C3R  O3R 
 %PARRDR-info: duplication of angle HR   C3R  OH  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 PARRDR> end 
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle C3R  OH   HO  
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of angle HR   C3R  O3R 
 %PARRDR-info: duplication of angle HR   C3R  OH  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 CNSsolve>parameter @@RUN:toppar/ligand.param end 
 PARRDR>! Put in this file your ligand parameters if needed 
 PARRDR>! 
 PARRDR>! 
 PARRDR>!       This file was generated by PRODRG version 070118.0614 
 PARRDR>!       PRODRG written/copyrighted by Daan van Aalten 
 PARRDR>!       and Alexander Schuettelkopf 
 PARRDR>! 
 PARRDR>!       Questions/comments to dava@davapc1.bioch.dundee.ac.uk 
 PARRDR>! 
 PARRDR>!       When using this software in a publication, cite: 
 PARRDR>!       A. W. Schuettelkopf and D. M. F. van Aalten (2004). 
 PARRDR>!       PRODRG - a tool for high-throughput crystallography 
 PARRDR>!       of protein-ligand complexes. 
 PARRDR>!       Acta Crystallogr. D60, 1355--1363. 
 PARRDR>! 
 PARRDR>! 
 PARRDR>!  *** NOTE *** IF YOU USE MORE THAN ONE PRODRG-GENERATED TOPOLOGY IN CNS, 
 PARRDR>!               PLEASE CAREFULLY READ THE FAQ AS THIS MAY CAUSE PROBLEMS 
 PARRDR>! 
 PARRDR>! 
 PARRDR>set echo=off message=on end 
 EVALUATE: symbol $PD_X set to    1.00000     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    17900.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    17900.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    17900.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    17900.0     (real)
 EVALUATE: symbol $PD_V set to    18000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    16000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    20000.0     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    720.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    880.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    400.000     (real)
 EVALUATE: symbol $PD_V set to    400.000     (real)
 EVALUATE: symbol $PD_V set to    400.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    800.000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to    8.10000     (real)
 EVALUATE: symbol $PD_V set to    8.10000     (real)
 EVALUATE: symbol $PD_V set to    8.10000     (real)
 EVALUATE: symbol $PD_V set to    8.10000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to    8.10000     (real)
 EVALUATE: symbol $PD_V set to    8.10000     (real)
 EVALUATE: symbol $PD_V set to   0.100000     (real)
 EVALUATE: symbol $PD_V set to    19.6000     (real)
 EVALUATE: symbol $PD_V set to    640.000     (real)
 EVALUATE: symbol $PD_V set to   0.100000     (real)
 EVALUATE: symbol $PD_V set to   0.100000     (real)
 PARRDR> end 
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle C3R  OH   HO  
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of angle HR   C3R  O3R 
 %PARRDR-info: duplication of angle HR   C3R  OH  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 CNSsolve>parameter @@RUN:toppar/fragment_probes.param end 
 ASSFIL: file fragment_probes.param opened.
 PARRDR>Remarks Parameters for Fragment-based Ligand Binding Site Mapping 
 PARRDR>Remarks created by acpype (Rev: 7268) on Mon Apr 13 10:01:53 2015 
 PARRDR> 
 PARRDR>set echo=false end 
 PARRDR> end 
 %PARRDR-info: duplication of bond CD_  C_  
 %PARRDR-info: duplication of bond CM_  CT_ 
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle C3R  OH   HO  
 %PARRDR-info: duplication of angle C3__ C3__ HC__
 %PARRDR-info: duplication of angle CD_  CM_  CT_ 
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of angle CM_  CT_  CT_ 
 %PARRDR-info: duplication of angle CT_  CT_  C_  
 %PARRDR-info: duplication of angle CT_  CT_  HC_ 
 %PARRDR-info: duplication of angle CT_  CT_  HP_ 
 %PARRDR-info: duplication of angle CT_  CT_  N3_ 
 %PARRDR-info: duplication of angle H1__ C3__ OH__
 %PARRDR-info: duplication of angle HP_  CT_  N3_ 
 %PARRDR-info: duplication of angle HR   C3R  O3R 
 %PARRDR-info: duplication of angle HR   C3R  OH  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 CNSsolve>paramater @@RUN:toppar/hemes-allhdg.param end 
 ASSFIL: file hemes-allhdg.param opened.
 PARRDR>remark  file parallhdg.hemes 
 PARRDR> 
 PARRDR>set message off echo off end 
 PARRDR> end 
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond CD_  C_  
 %PARRDR-info: duplication of bond CM_  CT_ 
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle C3R  OH   HO  
 %PARRDR-info: duplication of angle C3__ C3__ HC__
 %PARRDR-info: duplication of angle CD_  CM_  CT_ 
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of angle CM_  CT_  CT_ 
 %PARRDR-info: duplication of angle CPA  NPH1 FEH 
 %PARRDR-info: duplication of angle CPA  NPH2 FEH 
 %PARRDR-info: duplication of angle CT_  CT_  C_  
 %PARRDR-info: duplication of angle CT_  CT_  HC_ 
 %PARRDR-info: duplication of angle CT_  CT_  HP_ 
 %PARRDR-info: duplication of angle CT_  CT_  N3_ 
 %PARRDR-info: duplication of angle H1__ C3__ OH__
 %PARRDR-info: duplication of angle HP_  CT_  N3_ 
 %PARRDR-info: duplication of angle HR   C3R  O3R 
 %PARRDR-info: duplication of angle HR   C3R  OH  
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 CNSsolve>parameter @@RUN:toppar/water-allhdg5-4.param end 
 ASSFIL: file water-allhdg5-4.param opened.
 PARRDR>remarks file toppar/water-allhdg5-4.param 
 PARRDR>remarks 
 PARRDR>remarks   PARAM19.SOL (solvent parameters) 
 PARRDR>remarks   =========== 
 PARRDR>remarks   available: TIPS3P and DMSO model 
 PARRDR> 
 PARRDR>set message ? end eval ($old_message=$result) set echo ? end eval ($old_echo=$result) 
 MESSage=NORM
 EVALUATE: symbol $OLD_MESSAGE set to "NORM" (string)
 ECHO=TRUE {ON}
 EVALUATE: symbol $OLD_ECHO set to TRUE (logical)
 PARRDR>set message=off echo=off end 
 PARRDR> end 
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond CD_  C_  
 %PARRDR-info: duplication of bond CM_  CT_ 
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle C3R  OH   HO  
 %PARRDR-info: duplication of angle C3__ C3__ HC__
 %PARRDR-info: duplication of angle CD_  CM_  CT_ 
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of angle CM_  CT_  CT_ 
 %PARRDR-info: duplication of angle CPA  NPH1 FEH 
 %PARRDR-info: duplication of angle CPA  NPH2 FEH 
 %PARRDR-info: duplication of angle CT_  CT_  C_  
 %PARRDR-info: duplication of angle CT_  CT_  HC_ 
 %PARRDR-info: duplication of angle CT_  CT_  HP_ 
 %PARRDR-info: duplication of angle CT_  CT_  N3_ 
 %PARRDR-info: duplication of angle H1__ C3__ OH__
 %PARRDR-info: duplication of angle HP_  CT_  N3_ 
 %PARRDR-info: duplication of angle HR   C3R  O3R 
 %PARRDR-info: duplication of angle HR   C3R  OH  
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 CNSsolve> 
 CNSsolve>parameter 
 PARRDR>  nbonds 
 NBDSET>    nbxmod=5 atom cdie shift 
 NBDSET>    cutnb=9.5 ctofnb=8.5 ctonnb=6.5 eps=1.0 e14fac=0.4 inhibit 0.25 
 NBDSET>    wmin=0.5 
 NBDSET>    tolerance  0.5 
 NBDSET>  end 
 PARRDR>end 
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond CD_  C_  
 %PARRDR-info: duplication of bond CM_  CT_ 
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle C3R  OH   HO  
 %PARRDR-info: duplication of angle C3__ C3__ HC__
 %PARRDR-info: duplication of angle CD_  CM_  CT_ 
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of angle CM_  CT_  CT_ 
 %PARRDR-info: duplication of angle CPA  NPH1 FEH 
 %PARRDR-info: duplication of angle CPA  NPH2 FEH 
 %PARRDR-info: duplication of angle CT_  CT_  C_  
 %PARRDR-info: duplication of angle CT_  CT_  HC_ 
 %PARRDR-info: duplication of angle CT_  CT_  HP_ 
 %PARRDR-info: duplication of angle CT_  CT_  N3_ 
 %PARRDR-info: duplication of angle H1__ C3__ OH__
 %PARRDR-info: duplication of angle HP_  CT_  N3_ 
 %PARRDR-info: duplication of angle HR   C3R  O3R 
 %PARRDR-info: duplication of angle HR   C3R  OH  
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 CNSsolve> 
 CNSsolve>igroup 
 IGROup>  interaction  (not (resn ANI or resn DAN or resn XAN)) 
 SELRPN:   3007 atoms have been selected out of   3007
 SELRPN>               (not (resn ANI or resn DAN or resn XAN)) weight * 1 end 
 SELRPN:   3007 atoms have been selected out of   3007
 IGROup>  interaction  (resn ANI or resn DAN or resn XAN) 
 SELRPN:      0 atoms have been selected out of   3007
 SELRPN>               (resn ANI or resn DAN or resn XAN) weight * 1 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3007
 IGROup>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>flag include bond angle impr vdw end 
 CNSsolve> 
 CNSsolve>if ($Data.flags.dihed eq true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  flag include dihed end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>do (fbeta=$Saprotocol.fbeta) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (mass=$Saprotocol.mass) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (mass=1000) (resname ani) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>do (mass=1000) (resname xan) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>do (mass=1000) (resname dan) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>evaluate ($end_count = $iterations.ini_count + $iterations.structures - 1) 
 EVALUATE: symbol $END_COUNT set to    20.0000     (real)
 CNSsolve> 
 CNSsolve>if ($Data.noecv eq true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ($iteration = 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate ($npart = 1 + mod($count,$Data.ncvpart)) 
 CNSsolve>    evaluate ($fileseed="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + ".seed") 
 CNSsolve>    evaluate ($seed = max($iteration,1)*$count*$Saprotocol.iniseed) 
 CNSsolve>  else 
 CNSsolve>    evaluate ($fileseed= $file - ".pdb" + ".seed") 
 EVALUATE: symbol $FILESEED set to "PREVIT:complex_1.seed" (string)
 CNSsolve>    @@$fileseed (seed=$seed;npart=$npart ) 
 ASSFIL: file complex_1.seed opened.
 CNSsolve>module(seed;npart) 
 &_2_SEED set to $_1_SEED 
 &_2_NPART set to $_1_NPART 
 CNSsolve>define ( 
 DEFINE>currentseed = 917; 
 DEFINE>currentpart = 2; 
 DEFINE>) 
 CNSsolve>evaluate (&seed=&currentseed) 
 EVALUATE: symbol $_1_SEED set to    917.000     (real)
 CNSsolve>evaluate (&npart=&currentpart) 
 EVALUATE: symbol $_1_NPART set to    2.00000     (real)
 CNSsolve>    evaluate ($fileseed="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + ".seed") 
 EVALUATE: symbol $FILESEED set to "NEWIT:complex_1.seed" (string)
 CNSsolve>    evaluate ($num = $count + $iterations.structures) 
 EVALUATE: symbol $NUM set to    21.0000     (real)
 CNSsolve>    evaluate ($file_r_seed="NEWIT:" + $Filenames.fileroot + "_" + encode($num) + ".seed") 
 EVALUATE: symbol $FILE_R_SEED set to "NEWIT:complex_21.seed" (string)
 CNSsolve>    if ($iterations.rotate180 eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      set display=$file_r_seed end 
 CNSsolve>      display module(seed;npart) 
 CNSsolve>      display define ( 
 CNSsolve>      display currentseed = $seed; 
 CNSsolve>      display currentpart = $npart; 
 CNSsolve>      display ) 
 CNSsolve>      display evaluate (&seed=&currentseed) 
 CNSsolve>      display evaluate (&npart=&currentpart) 
 CNSsolve>      close $file_r_seed end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  set display=$fileseed end 
 ASSFIL: file complex_1.seed opened.
 CNSsolve>  display module(seed;npart) 
 CNSsolve>  display define ( 
 CNSsolve>  display currentseed = $seed; 
 CNSsolve>  display currentpart = $npart; 
 CNSsolve>  display ) 
 CNSsolve>  display evaluate (&seed=&currentseed) 
 CNSsolve>  display evaluate (&npart=&currentpart) 
 CNSsolve>  close $fileseed end 
 VCLOSE: Display file reset to OUTPUT.
 CNSsolve>else 
 CNSsolve>  evaluate ($seed = max($iteration,1)*$count*$Saprotocol.iniseed) 
 CNSsolve>end if 
 CNSsolve>set seed $seed end 
 CNSsolve> 
 CNSsolve>coor init end 
 COOR: selected main coordinates initialized
 CNSsolve>coor @@$file 
 ASSFIL: file complex_1.pdb opened.
 COOR>REMARK FILENAME="complex_1.pdb0" 
 COOR>REMARK =============================================================== 
 COOR>REMARK HADDOCK run for complex 
 COOR>REMARK initial structure: complex_1.pdb 
 COOR>REMARK final NOE weights: unambig 50 amb: 50 
 COOR>REMARK =============================================================== 
 COOR>REMARK            total,bonds,angles,improper,dihe,vdw,elec,air,cdih,coup,rdcs,vean,dani,xpcs,rg 
 COOR>REMARK energies: 119.614, 0, 0, 0, 0, 88.1379, -9.60256, 41.0782, 0, 0, 0, 0, 0, 0, 0 
 COOR>REMARK =============================================================== 
 COOR>REMARK            bonds,angles,impropers,dihe,air,cdih,coup,rdcs,vean,dani,xpcs 
 COOR>REMARK rms-dev.: 0,0,0,0,5.98548,0,0, 0, 0, 0, 0 
 COOR>REMARK =============================================================== 
 COOR>REMARK               air,cdih,coup,rdcs,vean,dani,xpcs 
 COOR>REMARK               >0.3,>5,>1,>0,>5,>0.2,>0.2 
 COOR>REMARK violations.: 2, 0, 0, 0, 0, 0, 0 
 COOR>REMARK =============================================================== 
 COOR>REMARK                        CVpartition#,violations,rms 
 COOR>REMARK AIRs cross-validation: 2, $TEST_VIOLATIONS, $TEST_RMS 
 %WDSUB-ERR: symbol not found:
 REMARK AIRs cross-validation: 2, $TEST_VIOLATIONS,
                                  ^^^^^^^^^^^^^^^^
 %WDSUB-ERR: symbol not found:
 REMARK AIRs cross-validation: 2, $TEST_VIOLATIONS, $TEST_RMS 
                                                    ^^^^^^^^^
 COOR>REMARK =============================================================== 
 COOR>REMARK NCS energy: 0 
 COOR>REMARK =============================================================== 
 COOR>REMARK Symmetry energy: 0 
 COOR>REMARK =============================================================== 
 COOR>REMARK Desolvation energy: -5.93593 
 COOR>REMARK Internal energy free molecules: 0 
 COOR>REMARK Internal energy complex: 0 
 COOR>REMARK Binding energy: 72.5994 
 COOR>REMARK =============================================================== 
 COOR>REMARK buried surface area: 848.467 
 COOR>REMARK =============================================================== 
 COOR>REMARK water - chain1: 0 0 0 
 COOR>REMARK water - chain2: 0 0 0 
 COOR>REMARK water - chain3: 0 0 0 
 COOR>REMARK water - chain4: 0 0 0 
 COOR>REMARK water - chain5: 0 0 0 
 COOR>REMARK water - chain6: 0 0 0 
 COOR>REMARK =============================================================== 
 COOR>REMARK water - water: 0 0 0 
 COOR>REMARK =============================================================== 
 COOR>REMARK DATE:28-Dec-2019  21:15:16       created by user: enmr049 
 COOR>REMARK VERSION:1.3U 
 COOR>ATOM      1  N   GLU     1       4.273 -17.584 -18.012  1.00 10.00      A 
 COOR>ATOM      2  HN  GLU     1       4.366 -18.496 -18.358  1.00 10.00      A 
 CNSsolve> 
 CNSsolve>! check for the presence of ions and add covalent bond 
 CNSsolve>if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  @RUN:protocols/covalions.cns 
 ASSFIL: file covalions.cns opened.
 CNSsolve>! covalions.cns 
 CNSsolve>!    Add a covalent bond between an ion and its closest coordinating atom 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>  evaluate ($pcount = 0) 
 EVALUATE: symbol $PCOUNT set to    0.00000     (real)
 CNSsolve>  for $id1 in id ( name "LI+1" or name "F-1"  or name "NA+1" or name "MG+2" or name "AL+3" 
 SELRPN>                or name "CL-1" or name "K+1"  or name "CA+2" or name "V+2"  or name "V+3" 
 SELRPN>                or name "CR+2" or name "CR+3" or name "MN+2" or name "MN+3" or name "FE+2" 
 SELRPN>                or name "FE+3" or name "NI+2" or name "CO+2" or name "CO+3" or name "CU+1" 
 SELRPN>                or name "CU+2" or name "ZN+2" or name "BR-1" or name "SR+2" or name "MO+3" 
 SELRPN>                or name "AG+1" or name "CD+2" or name "I-1"  or name "CS+2" or name "HO+3" 
 SELRPN>                or name "YB+2" or name "YB+3" or name "OS+4" or name "IR+3" or name "PT+2" 
 SELRPN>                or name "AU+1" or name "AU+2" or name "HG+1" or name "HG+2" or name "PB+2" 
 SELRPN>                or name "U+3"  or name "U+4"  or name "ZN+1" or name "ZN"  ) loop ions 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>     show (segid) (id $id1) 
 CNSsolve>     evaluate ($segid1=$result) 
 CNSsolve>     show (resid) (id $id1) 
 CNSsolve>     evaluate ($resid1=$result) 
 CNSsolve>     show (resname) (id $id1) 
 CNSsolve>     evaluate ($resname1=$result) 
 CNSsolve>     show (name) (id $id1) 
 CNSsolve>     evaluate ($name1=$result) 
 CNSsolve>     show (chem) (id $id1) 
 CNSsolve>     evaluate ($chem1=$result) 
 CNSsolve> 
 CNSsolve>     evaluate ($mindis = 7.5) 
 CNSsolve>     evaluate ($minid  = 0) 
 CNSsolve>     for $id2 in id ( (name O* or name S* or name N*) and (id $id1) around 7.5 and 
 FOR-clause=                      (resn ALA or resn ARG or resn ASN or resn ASP or resn CYS or resn GLN or resn GLU or 
 FOR-clause=                       resn GLY or resn HIS or resn ILE or resn LEU or resn LYS or resn MET or resn PHE or 
 FOR-clause=                       resn PRO or resn SER or resn THR or resn TRP or resn TYR or resn VAL or resn TYS or 
 FOR-clause=                       resn TYP or resn NEP or resn CYM or resn ADE or resn CYT or resn GUA or resn THY or 
 FOR-clause=                       resn A or resn C or resn G or resn T or resn DA or resn DC or resn DG or resn DT or 
 FOR-clause=                       resn HYP or resn CYP or resn CYM or resn CYF or resn TOP or resn TYP or resn TYS or 
 FOR-clause=                       resn SEP or resn PTR or resn HYP or resn DDZ)) loop search 
 CNSsolve> 
 CNSsolve>         pick bond (id $id1) (id $id2) geometry 
 CNSsolve> 
 CNSsolve>         if ( $result < $mindis) then 
 CNSsolve>           evaluate ($mindis = $result) 
 CNSsolve>           evaluate ($minid = $id2) 
 CNSsolve>         end if 
 CNSsolve> 
 CNSsolve>     end loop search 
 CNSsolve> 
 CNSsolve>     if ($minid> 0) then 
 CNSsolve>         show (segid) (id $minid) 
 CNSsolve>         evaluate ($segid2=$result) 
 CNSsolve>         show (resid) (id $minid) 
 CNSsolve>         evaluate ($resid2=$result) 
 CNSsolve>         show (resname) (id $minid) 
 CNSsolve>         evaluate ($resname2=$result) 
 CNSsolve>         show (name) (id $minid) 
 CNSsolve>         evaluate ($name2=$result) 
 CNSsolve>         show (chem) (id $minid) 
 CNSsolve>         evaluate ($chem2=$result) 
 CNSsolve> 
 CNSsolve>         evaluate ($pat1 = "1"+$name1) 
 CNSsolve>         evaluate ($pat2 = "2"+$name2) 
 CNSsolve>         evaluate ($pcount = $pcount + 1) 
 CNSsolve>         evaluate ($pname = "cb" + encode($pcount)) 
 CNSsolve>         topology 
 CNSsolve>           presidue $pname   ! Patch to add a covalent bond between two atoms 
 CNSsolve>             add bond $pat1 $pat2 
 CNSsolve>           end 
 CNSsolve>         end 
 CNSsolve>         patch $pname refe=1=(resid $resid1 and segid $segid1) refe=2=(resid $resid2 and segid $segid2) end 
 CNSsolve>         display COVALION: ADDED ONE COVALENT BOND BETWEEN $name1 $resid1 AND $name2 $resname2 $resid2 
 CNSsolve>     end if 
 CNSsolve> 
 CNSsolve>     param bond $chem1 $chem2 0.0 $mindis end 
 CNSsolve> 
 CNSsolve>   end loop ions 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>{* Find CoM of protein *} 
 CNSsolve>show ave (x) (name CA or name C1') 
 SELRPN:    306 atoms have been selected out of   3007
 SHOW: average of selected elements =       0.170408
 CNSsolve>evaluate ($xcent=$result) 
 EVALUATE: symbol $XCENT set to   0.170408     (real)
 CNSsolve>show ave (y) (name CA or name C1') 
 SELRPN:    306 atoms have been selected out of   3007
 SHOW: average of selected elements =      -0.073291
 CNSsolve>evaluate ($ycent=$result) 
 EVALUATE: symbol $YCENT set to  -0.732908E-01 (real)
 CNSsolve>show ave (z) (name CA or name C1') 
 SELRPN:    306 atoms have been selected out of   3007
 SHOW: average of selected elements =       0.235422
 CNSsolve>evaluate ($zcent=$result) 
 EVALUATE: symbol $ZCENT set to   0.235422     (real)
 CNSsolve> 
 CNSsolve>coor select (not known and resn ani) end 
 SELRPN:      0 atoms have been selected out of   3007
 COOR: using atom subset.
 CNSsolve>if ($select gt 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  coor @@RUN:toppar/tensor.pdb 
 CNSsolve> 
 CNSsolve>  {* Find CoM of protein and move tensor 100 A away *} 
 CNSsolve>  show ave (x) (name CA or name C1') 
 CNSsolve>  evaluate ($xcent=$result) 
 CNSsolve>  show ave (y) (name CA or name C1') 
 CNSsolve>  evaluate ($ycent=$result) 
 CNSsolve>  show ave (z) (name CA or name C1') 
 CNSsolve>  evaluate ($zcent=$result) 
 CNSsolve>  do (x=x+$xcent+100) (resn ANI) 
 CNSsolve>  do (y=y+$ycent+100) (resn ANI) 
 CNSsolve>  do (z=z+$zcent+100) (resn ANI) 
 CNSsolve>  evaluate ($rantens = true) 
 CNSsolve>else 
 CNSsolve>  evaluate ($rantens = false) 
 EVALUATE: symbol $RANTENS set to FALSE (logical)
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>coor select (not known and resn xan) end 
 SELRPN:      0 atoms have been selected out of   3007
 COOR: using atom subset.
 CNSsolve>if ($select gt 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  coor @@RUN:toppar/tensor_para.pdb 
 CNSsolve>  evaluate ($rantens_para = true) 
 CNSsolve>else 
 CNSsolve>  evaluate ($rantens_para = false) 
 EVALUATE: symbol $RANTENS_PARA set to FALSE (logical)
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>coor select (not known and resn dan) end 
 SELRPN:      0 atoms have been selected out of   3007
 COOR: using atom subset.
 CNSsolve>if ($select gt 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  coor @@RUN:toppar/tensor_dani.pdb 
 CNSsolve> 
 CNSsolve>  {* Find CoM of protein and move tensor 100 A away *} 
 CNSsolve>  show ave (x) (name CA or name C1') 
 CNSsolve>  evaluate ($xcent=$result) 
 CNSsolve>  show ave (y) (name CA or name C1') 
 CNSsolve>  evaluate ($ycent=$result) 
 CNSsolve>  show ave (z) (name CA or name C1') 
 CNSsolve>  evaluate ($zcent=$result) 
 CNSsolve>  do (x=x+$xcent+100) (resn DAN) 
 CNSsolve>  do (y=y+$ycent+100) (resn DAN) 
 CNSsolve>  do (z=z+$zcent+100) (resn DAN) 
 CNSsolve>  evaluate ($rantens_dani = true) 
 CNSsolve>else 
 CNSsolve>  evaluate ($rantens_dani = false) 
 EVALUATE: symbol $RANTENS_DANI set to FALSE (logical)
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!catch possible bound water and set high T steps to 0 
 CNSsolve>coor select ((resn WAT or resn HOH or resn TIP*)) end 
 SELRPN:      0 atoms have been selected out of   3007
 COOR: using atom subset.
 CNSsolve>if ($select gt 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($SaProtocol.initiosteps = 0) 
 CNSsolve>  evaluate ($SaProtocol.cool1_steps = 0) 
 CNSsolve>  evaluate ($refine.keepwater = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>do (refx=x) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (refy=y) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (refz=z) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>!set the energy flags: 
 CNSsolve>@@RUN:protocols/flags_new.cns(Iteration=$Iteration; Data=$Data; ) 
 ASSFIL: file flags_new.cns opened.
 CNSsolve>! flags_new.cns 
 CNSsolve>!    Defines energy flags 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module(Iteration; Data; ) 
 &_2_ITERATION set to $_1_ITERATION 
 &_2_DATA set to $_1_DATA 
 CNSsolve> 
 CNSsolve>if ($Data.cdih.on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   evaluate ($Data.flags.cdih =  true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.c1_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.coup =  true) 
 CNSsolve>elseif ($Data.c2_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.coup =  true) 
 CNSsolve>elseif ($Data.c3_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.coup =  true) 
 CNSsolve>elseif ($Data.c4_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.coup =  true) 
 CNSsolve>elseif ($Data.c5_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.coup =  true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.rdc1_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.sani = true) 
 CNSsolve>elseif ($Data.rdc2_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.sani = true) 
 CNSsolve>elseif ($Data.rdc3_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.sani = true) 
 CNSsolve>elseif ($Data.rdc4_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.sani = true) 
 CNSsolve>elseif ($Data.rdc5_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.sani = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.rdc1_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xrdc = true) 
 CNSsolve>elseif ($Data.rdc2_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xrdc = true) 
 CNSsolve>elseif ($Data.rdc3_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xrdc = true) 
 CNSsolve>elseif ($Data.rdc4_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xrdc = true) 
 CNSsolve>elseif ($Data.rdc5_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xrdc = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.pcs1_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs2_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs3_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs4_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs5_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs6_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs7_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs8_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs9_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcsA_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.dan1_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.DANI = true) 
 CNSsolve>elseif ($Data.dan2_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.DANI = true) 
 CNSsolve>elseif ($Data.dan3_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.DANI = true) 
 CNSsolve>elseif ($Data.dan4_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.DANI = true) 
 CNSsolve>elseif ($Data.dan5_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.DANI = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sani eq TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.harm = true) 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.dani eq TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.harm = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.rdc1_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.vean = true) 
 CNSsolve>end if 
 CNSsolve>if ($Data.rdc2_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.vean = true) 
 CNSsolve>end if 
 CNSsolve>if ($Data.rdc3_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.vean = true) 
 CNSsolve>end if 
 CNSsolve>if ($Data.rdc4_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.vean = true) 
 CNSsolve>end if 
 CNSsolve>if ($Data.rdc5_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.vean = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.noe  =  TRUE) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   flags include noe end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.cdih =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include cdih end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.coup =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include coup end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.vean =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include vean end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.sani =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include sani end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.xrdc =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include xrdc end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.xpcs =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include xpcs end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.dani =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include dani end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.plan =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include plan end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.ncs  =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include ncs end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.rg = TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($data.rgtarg > 0) then 
 CNSsolve>    flags include coll end 
 CNSsolve>  else 
 CNSsolve>    evaluate ($Data.flags.rg = false) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!read all the experimental Data: 
 CNSsolve>set seed $seed end 
 CNSsolve>set message=normal echo=on end 
 CNSsolve>if ($data.waterdock eq false) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  @@RUN:protocols/read_data.cns(Iteration=$Iteration; Data=$Data; count=$count) 
 ASSFIL: file read_data.cns opened.
 CNSsolve>! read_data.cns 
 CNSsolve>!    Read the various restraints data 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module(Iteration; Data; count;) 
 &_2_ITERATION set to $_1_ITERATION 
 &_2_DATA set to $_1_DATA 
 &_2_COUNT set to $_1_COUNT 
 CNSsolve> 
 CNSsolve>!NOEs, hbonds 
 CNSsolve>noe 
 NOE>  reset 
 NOE>  nrestraints = 4000000     ! allocate space for NOEs 
 NOE: allocating space for 4000000 restraints.
 NOE>  ceiling 1000 
 NOE>end 
 CNSsolve> 
 CNSsolve>if (&data.amb_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.amb_firstit le &iteration)   then 
 NEXTCD: condition evaluated as true
 CNSsolve>     evaluate ($filenam0 = "NEWIT:ambig.tbl_" + encode($count)) 
 EVALUATE: symbol $FILENAM0 set to "NEWIT:ambig.tbl_1" (string)
 CNSsolve>     fileexist $filenam0 end 
 MISCOM: file does not exist
 CNSsolve>     if ($result eq false) then 
 NEXTCD: condition evaluated as true
 CNSsolve>       evaluate ($filenam0 = "NEWIT:ambig.tbl") 
 EVALUATE: symbol $FILENAM0 set to "NEWIT:ambig.tbl" (string)
 CNSsolve>     end if 
 CNSsolve>     noe class ambi @@$filenam0 end 
 ASSFIL: file ambig.tbl opened.
 CNSsolve>     if (&data.noecv eq true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>       noe part &data.ncvpart end 
 Data are not partitioned or partitioning removed.
 CNSsolve>     end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.unamb_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.unamb_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>     noe class dist @@NEWIT:unambig.tbl end 
 ASSFIL: file unambig.tbl opened.
 NOE>assign (resid 11 and name CA and segid A) (resid 320 and name CA and segid A) 15.250 0.00 0.00 
 SELRPN:      1 atoms have been selected out of   3007
 SELRPN:      1 atoms have been selected out of   3007
 NOE>assign (resid 317 and name CA and segid A) (resid 15 and name CA and segid A) 15.082 0.00 0.00 
 SELRPN:      1 atoms have been selected out of   3007
 SELRPN:      1 atoms have been selected out of   3007
 NOE> end 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.hbond_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.hbond_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.hbonds_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      noe @@RUN:data/hbonds/hbonds.tbl end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>noe 
 NOE>  averaging  * sum 
 NOE>  potential  * soft 
 NOE>  scale      * 1.0 
 NOE>  sqconstant * 1.0 
 NOE>  sqexponent * 2 
 NOE>  soexponent * 1 
 NOE>  rswitch    * 1.0 
 NOE>  sqoffset   * 0.0 
 NOE>  asymptote  * 2.0 
 NOE>  msoexponent * 1 
 NOE>  masymptote  * -0.1 
 NOE>  mrswitch    * 1.0 
 NOE>  avexpo hbond 20 
 NOE>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 CNSsolve>!dihedral restraints: 
 CNSsolve>restraints dihedral 
 DIHEDRAL>   reset 
 DIHEDRAL>   nassign 10000 
 RSTDIH: allocating space for   10000 assignments.
 DIHEDRAL>end 
 CNSsolve>if (&Data.cdih.on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  restraints dihedral 
 CNSsolve>    @@RUN:data/dihedrals/dihedrals.tbl 
 CNSsolve>  end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>restraints dihedral ? end 
 Total number of dihedral angle restraints=     0
  overall scale =    1.0000
 Number of dihedral angle restraints=    0
 RMS deviation=   0.000
 CNSsolve>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 CNSsolve>!jcouplings: 
 CNSsolve>evaluate ($jcouplings_on = false) 
 EVALUATE: symbol $JCOUPLINGS_ON set to FALSE (logical)
 CNSsolve>if (&data.c1_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate($jcouplings_on = true) 
 CNSsolve>elseif (&data.c2_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate($jcouplings_on = true) 
 CNSsolve>elseif (&data.c3_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate($jcouplings_on = true) 
 CNSsolve>elseif (&data.c4_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate($jcouplings_on = true) 
 CNSsolve>elseif (&data.c5_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate($jcouplings_on = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($jcouplings_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  couplings reset end 
 CNSsolve>  couplings 
 CNSsolve>    nres 500   !number of restraints for allocating memory 
 CNSsolve>    if (&data.c1_on eq true) then 
 CNSsolve>      class c1 
 CNSsolve>      potential harmonic 
 CNSsolve>      {degen 1} 
 CNSsolve>      force 1.0    !1 energy constant 
 CNSsolve>      coefficients &data.c1_karplusa &data.c1_karplusb &data.c1_karplusc &data.c1_karplusd 
 CNSsolve>      evaluate ($loadnow = "RUN:" + "data/jcouplings/c1.tbl") 
 CNSsolve>      @@$loadnow 
 CNSsolve>    end if 
 CNSsolve>    if (&data.c2_on eq true) then 
 CNSsolve>      class c2 
 CNSsolve>      potential harmonic 
 CNSsolve>      {degen 1} 
 CNSsolve>      force 1.0    !1 energy constant 
 CNSsolve>      coefficients &data.c2_karplusa &data.c2_karplusb &data.c2_karplusc &data.c2_karplusd 
 CNSsolve>      evaluate ($loadnow = "RUN:" + "data/jcouplings/c2.tbl") 
 CNSsolve>      @@$loadnow 
 CNSsolve>    end if 
 CNSsolve>    if (&data.c3_on eq true) then 
 CNSsolve>      class c3 
 CNSsolve>      potential harmonic 
 CNSsolve>      {degen 1} 
 CNSsolve>      force 1.0    !1 energy constant 
 CNSsolve>      coefficients &data.c3_karplusa &data.c3_karplusb &data.c3_karplusc &data.c3_karplusd 
 CNSsolve>      evaluate ($loadnow = "RUN:" + "data/jcouplings/c3.tbl") 
 CNSsolve>      @@$loadnow 
 CNSsolve>    end if 
 CNSsolve>    if (&data.c4_on eq true) then 
 CNSsolve>      class c4 
 CNSsolve>      potential harmonic 
 CNSsolve>      {degen 1} 
 CNSsolve>      force 1.0    !1 energy constant 
 CNSsolve>      coefficients &data.c4_karplusa &data.c4_karplusb &data.c4_karplusc &data.c4_karplusd 
 CNSsolve>      evaluate ($loadnow = "RUN:" + "data/jcouplings/c4.tbl") 
 CNSsolve>      @@$loadnow 
 CNSsolve>    end if 
 CNSsolve>    if (&data.c5_on eq true) then 
 CNSsolve>      class c5 
 CNSsolve>      potential harmonic 
 CNSsolve>      {degen 1} 
 CNSsolve>      force 1.0    !1 energy constant 
 CNSsolve>      coefficients &data.c5_karplusa &data.c5_karplusb &data.c5_karplusc &data.c5_karplusd 
 CNSsolve>      evaluate ($loadnow = "RUN:" + "data/jcouplings/c5.tbl") 
 CNSsolve>      @@$loadnow 
 CNSsolve>    end if 
 CNSsolve>  end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 CNSsolve>!residual dipolar couplings: 
 CNSsolve> 
 CNSsolve>evaluate (&data.flags.sani = false) 
 EVALUATE: symbol $_1_DATA.FLAGS.SANI set to FALSE (logical)
 CNSsolve>evaluate (&data.flags.xrdc = false) 
 EVALUATE: symbol $_1_DATA.FLAGS.XRDC set to FALSE (logical)
 CNSsolve>evaluate (&data.flags.xpcs = false) 
 EVALUATE: symbol $_1_DATA.FLAGS.XPCS set to FALSE (logical)
 CNSsolve>evaluate (&data.flags.dani = false) 
 EVALUATE: symbol $_1_DATA.FLAGS.DANI set to FALSE (logical)
 CNSsolve>evaluate (&data.flags.vean = false) 
 EVALUATE: symbol $_1_DATA.FLAGS.VEAN set to FALSE (logical)
 CNSsolve>evaluate ($inisani=0) 
 EVALUATE: symbol $INISANI set to    0.00000     (real)
 CNSsolve>evaluate ($inixrdc=0) 
 EVALUATE: symbol $INIXRDC set to    0.00000     (real)
 CNSsolve>evaluate ($inixpcs=0) 
 EVALUATE: symbol $INIXPCS set to    0.00000     (real)
 CNSsolve>evaluate ($inidani=0) 
 EVALUATE: symbol $INIDANI set to    0.00000     (real)
 CNSsolve>evaluate ($inivean = 0) 
 EVALUATE: symbol $INIVEAN set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>if (&data.rdc1_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.rdc1_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.rdc1_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.sani = true) 
 CNSsolve>      sani reset nres=500 end 
 CNSsolve>      evaluate ($inisani=1) 
 CNSsolve>      sani 
 CNSsolve>        class rdc1 
 CNSsolve>        force 0.0 
 CNSsolve>        potential square 
 CNSsolve>        @@RUN:data/rdcs/rdc1.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>    if (&data.rdc1_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xrdc = true) 
 CNSsolve>      xrdc reset nres=500 end 
 CNSsolve>      evaluate ($inixrdc=1) 
 CNSsolve>      xrdc 
 CNSsolve>        class rdc1 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/rdcs/rdc1.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>    if (&data.rdc1_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.vean = true) 
 CNSsolve>      vean reset nrestraints=10000 end 
 CNSsolve>      evaluate ($inivean = 1) 
 CNSsolve>      if (&data.rdc1_firstIt le &iteration) then 
 CNSsolve>        vean 
 CNSsolve>          class vea1 
 CNSsolve>          force 0.0 0.0 
 CNSsolve>          @@RUN:data/rdcs/rdc1.tbl 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.rdc2_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.rdc2_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.rdc2_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.sani = true) 
 CNSsolve>      if ($inisani = 0) then 
 CNSsolve>        sani reset nres=500 end 
 CNSsolve>        evaluate ($inisani=1) 
 CNSsolve>      end if 
 CNSsolve>      sani 
 CNSsolve>        class rdc2 
 CNSsolve>        force 0.0 
 CNSsolve>        potential square 
 CNSsolve>        @@RUN:data/rdcs/rdc2.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>    if (&data.rdc2_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xrdc = true) 
 CNSsolve>      if ($inixrdc = 0) then 
 CNSsolve>        xrdc reset nres=500 end 
 CNSsolve>        evaluate ($inixrdc=1) 
 CNSsolve>      end if 
 CNSsolve>      xrdc 
 CNSsolve>        class rdc2 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/rdcs/rdc2.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>    if (&data.rdc2_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.vean = true) 
 CNSsolve>      if ($inivean = 0) then 
 CNSsolve>        vean reset nrestraints=10000 end 
 CNSsolve>        evaluate ($inivean = 1) 
 CNSsolve>      end if 
 CNSsolve>      if (&data.rdc2_firstIt le &iteration) then 
 CNSsolve>        vean 
 CNSsolve>          class vea2 
 CNSsolve>          force 0.0 0.0 
 CNSsolve>          @@RUN:data/rdcs/rdc2.tbl 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.rdc3_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.rdc3_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.rdc3_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.sani = true) 
 CNSsolve>      if ($inisani = 0) then 
 CNSsolve>        sani reset nres=500 end 
 CNSsolve>        evaluate ($inisani=1) 
 CNSsolve>      end if 
 CNSsolve>      sani 
 CNSsolve>        class rdc3 
 CNSsolve>        force 0.0 
 CNSsolve>        potential square 
 CNSsolve>        @@RUN:data/rdcs/rdc3.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>    if (&data.rdc3_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xrdc = true) 
 CNSsolve>      if ($inixrdc = 0) then 
 CNSsolve>        xrdc reset nres=500 end 
 CNSsolve>        evaluate ($inixrdc=1) 
 CNSsolve>      end if 
 CNSsolve>      xrdc 
 CNSsolve>        class rdc3 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/rdcs/rdc3.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>    if (&data.rdc3_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.vean = true) 
 CNSsolve>      if ($inivean = 0) then 
 CNSsolve>        vean reset nrestraints=10000 end 
 CNSsolve>        evaluate ($inivean = 1) 
 CNSsolve>      end if 
 CNSsolve>      if (&data.rdc3_firstIt le &iteration) then 
 CNSsolve>        vean 
 CNSsolve>          class vea3 
 CNSsolve>          force 0.0 0.0 
 CNSsolve>          @@RUN:data/rdcs/rdc3.tbl 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.rdc4_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.rdc4_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.rdc4_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.sani = true) 
 CNSsolve>      if ($inisani = 0) then 
 CNSsolve>        sani reset nres=500 end 
 CNSsolve>        evaluate ($inisani=1) 
 CNSsolve>      end if 
 CNSsolve>      sani 
 CNSsolve>        class rdc4 
 CNSsolve>        force 0.0 
 CNSsolve>        potential square 
 CNSsolve>        @@RUN:data/rdcs/rdc4.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>    if (&data.rdc4_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xrdc = true) 
 CNSsolve>      if ($inixrdc = 0) then 
 CNSsolve>        xrdc reset nres=500 end 
 CNSsolve>        evaluate ($inixrdc=1) 
 CNSsolve>      end if 
 CNSsolve>      xrdc 
 CNSsolve>        class rdc4 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/rdcs/rdc4.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>    if (&data.rdc4_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.vean = true) 
 CNSsolve>      if ($inivean = 0) then 
 CNSsolve>        vean reset nrestraints=10000 end 
 CNSsolve>        evaluate ($inivean = 1) 
 CNSsolve>      end if 
 CNSsolve>      if (&data.rdc4_firstIt le &iteration) then 
 CNSsolve>        vean 
 CNSsolve>          class vea4 
 CNSsolve>          force 0.0 0.0 
 CNSsolve>          @@RUN:data/rdcs/rdc4.tbl 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.rdc5_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.rdc5_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.rdc5_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.sani = true) 
 CNSsolve>      if ($inisani = 0) then 
 CNSsolve>        sani reset nres=500 end 
 CNSsolve>        evaluate ($inisani=1) 
 CNSsolve>      end if 
 CNSsolve>      sani 
 CNSsolve>        class rdc5 
 CNSsolve>        force 0.0 
 CNSsolve>        potential square 
 CNSsolve>        @@RUN:data/rdcs/rdc5.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>    if (&data.rdc5_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xrdc = true) 
 CNSsolve>      if ($inixrdc = 0) then 
 CNSsolve>        xrdc reset nres=500 end 
 CNSsolve>        evaluate ($inixrdc=1) 
 CNSsolve>      end if 
 CNSsolve>      xrdc 
 CNSsolve>        class rdc5 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/rdcs/rdc5.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>    if (&data.rdc5_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.vean = true) 
 CNSsolve>      if ($inivean = 0) then 
 CNSsolve>        vean reset nrestraints=10000 end 
 CNSsolve>        evaluate ($inivean = 1) 
 CNSsolve>      end if 
 CNSsolve>      if (&data.rdc5_firstIt le &iteration) then 
 CNSsolve>        vean 
 CNSsolve>          class vea5 
 CNSsolve>          force 0.0 0.0 
 CNSsolve>          @@RUN:data/rdcs/rdc5.tbl 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.pcs1_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.pcs1_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.pcs1_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xpcs = true) 
 CNSsolve>      xpcs reset nres=5000 end 
 CNSsolve>      evaluate ($inixpcs=1) 
 CNSsolve>      xpcs 
 CNSsolve>        class pcs1 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/pcs/pcs1.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.pcs2_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.pcs2_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.pcs2_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xpcs = true) 
 CNSsolve>      if ($inixpcs = 0) then 
 CNSsolve>        xpcs reset nres=5000 end 
 CNSsolve>        evaluate ($inixpcs=1) 
 CNSsolve>      end if 
 CNSsolve>      xpcs 
 CNSsolve>        class pcs2 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/pcs/pcs2.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.pcs3_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.pcs3_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.pcs3_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xpcs = true) 
 CNSsolve>      if ($inixpcs = 0) then 
 CNSsolve>        xpcs reset nres=5000 end 
 CNSsolve>        evaluate ($inixpcs=1) 
 CNSsolve>      end if 
 CNSsolve>      xpcs 
 CNSsolve>        class pcs3 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/pcs/pcs3.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.pcs4_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.pcs4_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.pcs4_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xpcs = true) 
 CNSsolve>      if ($inixpcs = 0) then 
 CNSsolve>        xpcs reset nres=5000 end 
 CNSsolve>        evaluate ($inixpcs=1) 
 CNSsolve>      end if 
 CNSsolve>      xpcs 
 CNSsolve>        class pcs4 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/pcs/pcs4.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.pcs5_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.pcs5_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.pcs5_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xpcs = true) 
 CNSsolve>      if ($inixpcs = 0) then 
 CNSsolve>        xpcs reset nres=5000 end 
 CNSsolve>        evaluate ($inixpcs=1) 
 CNSsolve>      end if 
 CNSsolve>      xpcs 
 CNSsolve>        class pcs5 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/pcs/pcs5.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.pcs6_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.pcs6_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.pcs6_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xpcs = true) 
 CNSsolve>      if ($inixpcs = 0) then 
 CNSsolve>        xpcs reset nres=5000 end 
 CNSsolve>        evaluate ($inixpcs=1) 
 CNSsolve>      end if 
 CNSsolve>      xpcs 
 CNSsolve>        class pcs6 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/pcs/pcs6.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.pcs7_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.pcs7_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.pcs7_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xpcs = true) 
 CNSsolve>      if ($inixpcs = 0) then 
 CNSsolve>        xpcs reset nres=5000 end 
 CNSsolve>        evaluate ($inixpcs=1) 
 CNSsolve>      end if 
 CNSsolve>      xpcs 
 CNSsolve>        class pcs7 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/pcs/pcs7.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.pcs8_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.pcs8_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.pcs8_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xpcs = true) 
 CNSsolve>      if ($inixpcs = 0) then 
 CNSsolve>        xpcs reset nres=5000 end 
 CNSsolve>        evaluate ($inixpcs=1) 
 CNSsolve>      end if 
 CNSsolve>      xpcs 
 CNSsolve>        class pcs8 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/pcs/pcs8.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.pcs9_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.pcs9_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.pcs9_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xpcs = true) 
 CNSsolve>      if ($inixpcs = 0) then 
 CNSsolve>        xpcs reset nres=5000 end 
 CNSsolve>        evaluate ($inixpcs=1) 
 CNSsolve>      end if 
 CNSsolve>      xpcs 
 CNSsolve>        class pcs9 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/pcs/pcs9.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.pcsA_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.pcsA_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.pcsA_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.xpcs = true) 
 CNSsolve>      if ($inixpcs = 0) then 
 CNSsolve>        xpcs reset nres=5000 end 
 CNSsolve>        evaluate ($inixpcs=1) 
 CNSsolve>      end if 
 CNSsolve>      xpcs 
 CNSsolve>        class pcsA 
 CNSsolve>        force 0.0 
 CNSsolve>        @@RUN:data/pcs/pcsA.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($tensread = false) 
 EVALUATE: symbol $TENSREAD set to FALSE (logical)
 CNSsolve>if (&data.flags.xrdc = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  noe 
 CNSsolve>    class tens 
 CNSsolve>    @@RUN:data/tensor/tensor.tbl 
 CNSsolve>    potential tens square 
 CNSsolve>    scale     tens 500.0 
 CNSsolve>  end 
 CNSsolve>  evaluate ($tensread = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.flags.xpcs = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($tensread eq FALSE) then 
 CNSsolve>    noe 
 CNSsolve>      class tens 
 CNSsolve>      @@RUN:data/tensor/tensor.tbl 
 CNSsolve>      potential tens square 
 CNSsolve>      scale     tens 500.0 
 CNSsolve>    end 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if (&data.dan1_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.dan1_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.dan1_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.dani = true) 
 CNSsolve>      dani reset nres=500 end 
 CNSsolve>      evaluate ($inidani=1) 
 CNSsolve>      dani 
 CNSsolve>        class dan1 
 CNSsolve>        force 0.0 
 CNSsolve>        potential square 
 CNSsolve>        @@RUN:data/dani/dani1.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve>if (&data.dan2_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.dan2_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.dan2_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.dani = true) 
 CNSsolve>      dani reset nres=500 end 
 CNSsolve>      evaluate ($inidani=1) 
 CNSsolve>      dani 
 CNSsolve>        class dan2 
 CNSsolve>        force 0.0 
 CNSsolve>        potential square 
 CNSsolve>        @@RUN:data/dani/dani2.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve>if (&data.dan3_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.dan3_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.dan3_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.dani = true) 
 CNSsolve>      dani reset nres=500 end 
 CNSsolve>      evaluate ($inidani=1) 
 CNSsolve>      dani 
 CNSsolve>        class dan3 
 CNSsolve>        force 0.0 
 CNSsolve>        potential square 
 CNSsolve>        @@RUN:data/dani/dani3.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve>if (&data.dan4_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.dan4_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.dan4_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.dani = true) 
 CNSsolve>      dani reset nres=500 end 
 CNSsolve>      evaluate ($inidani=1) 
 CNSsolve>      dani 
 CNSsolve>        class dan4 
 CNSsolve>        force 0.0 
 CNSsolve>        potential square 
 CNSsolve>        @@RUN:data/dani/dani4.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve>if (&data.dan5_lastit ge &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if (&data.dan5_firstit le &iteration) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    if (&data.dan5_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate (&data.flags.dani = true) 
 CNSsolve>      dani reset nres=500 end 
 CNSsolve>      evaluate ($inidani=1) 
 CNSsolve>      dani 
 CNSsolve>        class dan5 
 CNSsolve>        force 0.0 
 CNSsolve>        potential square 
 CNSsolve>        @@RUN:data/dani/dani5.tbl 
 CNSsolve>      end 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>{* ======================= calculate free molecules internal energy *} 
 CNSsolve> 
 CNSsolve>flag excl noe dani sani vean xrdc xpcs coll cdih end 
 CNSsolve> 
 CNSsolve>evaluate ($elec = 0.0) 
 EVALUATE: symbol $ELEC set to    0.00000     (real)
 CNSsolve>evaluate ($esolfree = 0.0) 
 EVALUATE: symbol $ESOLFREE set to    0.00000     (real)
 CNSsolve>evaluate ($eintfree = 0.0) 
 EVALUATE: symbol $EINTFREE set to    0.00000     (real)
 CNSsolve>if ($iteration = 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($Data.flags.elec0 eq true) then 
 CNSsolve>    flag include elec end 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve>if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  if ($Data.flags.elec1 eq true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    flag include elec end 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve>if ($Data.dielec eq rdie) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  parameter nbonds eps=$Data.epsilon rdie shift switch end end 
 CNSsolve>  ! shift statement needed first to activate switch (CNS bug?) 
 CNSsolve>else 
 CNSsolve>  parameter nbonds eps=$Data.epsilon cdie end end 
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond CD_  C_  
 %PARRDR-info: duplication of bond CM_  CT_ 
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle C3R  OH   HO  
 %PARRDR-info: duplication of angle C3__ C3__ HC__
 %PARRDR-info: duplication of angle CD_  CM_  CT_ 
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of angle CM_  CT_  CT_ 
 %PARRDR-info: duplication of angle CPA  NPH1 FEH 
 %PARRDR-info: duplication of angle CPA  NPH2 FEH 
 %PARRDR-info: duplication of angle CT_  CT_  C_  
 %PARRDR-info: duplication of angle CT_  CT_  HC_ 
 %PARRDR-info: duplication of angle CT_  CT_  HP_ 
 %PARRDR-info: duplication of angle CT_  CT_  N3_ 
 %PARRDR-info: duplication of angle H1__ C3__ OH__
 %PARRDR-info: duplication of angle HP_  CT_  N3_ 
 %PARRDR-info: duplication of angle HR   C3R  O3R 
 %PARRDR-info: duplication of angle HR   C3R  OH  
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 CNSsolve>end if 
 CNSsolve>parameter nbonds ? end end 
 -----nonbonded-list-options-------------------------------
 | CUTNb=   9.500 TOLErance=   0.500 WMIN=   0.500 ATOM   |
 | INHIbit=   0.250                                       |
 -----electrostatic options--------------------------------
 | EPS=  10.000 E14Fac=   0.400 CDIElectric POTEN SHIFt   |
 -----van der Waals options--------------------------------
 | VSWItch                                                |
 -----switching /shifting parameters-----------------------
 | CTONNB=   6.500 CTOFNB=   8.500                        |
 -----exclusion list options-------------------------------
 | NBXMOD=   5                                            |
 ----------------------------------------------------------
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond CD_  C_  
 %PARRDR-info: duplication of bond CM_  CT_ 
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle C3R  OH   HO  
 %PARRDR-info: duplication of angle C3__ C3__ HC__
 %PARRDR-info: duplication of angle CD_  CM_  CT_ 
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of angle CM_  CT_  CT_ 
 %PARRDR-info: duplication of angle CPA  NPH1 FEH 
 %PARRDR-info: duplication of angle CPA  NPH2 FEH 
 %PARRDR-info: duplication of angle CT_  CT_  C_  
 %PARRDR-info: duplication of angle CT_  CT_  HC_ 
 %PARRDR-info: duplication of angle CT_  CT_  HP_ 
 %PARRDR-info: duplication of angle CT_  CT_  N3_ 
 %PARRDR-info: duplication of angle H1__ C3__ OH__
 %PARRDR-info: duplication of angle HP_  CT_  N3_ 
 %PARRDR-info: duplication of angle HR   C3R  O3R 
 %PARRDR-info: duplication of angle HR   C3R  OH  
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 CNSsolve>inline @RUN:protocols/calc_free-ene.cns 
 ASSFIL: file calc_free-ene.cns opened.
 CNSsolve>! calc_free-ene.cns 
 CNSsolve>!    Calculate the total energy of the separated components 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>!move molecules far apart 
 CNSsolve> 
 CNSsolve>@RUN:protocols/separate.cns(Data=$Data; Toppar=$Toppar) 
 ASSFIL: file separate.cns opened.
 CNSsolve>! separate.cns 
 CNSsolve>!    Separate molecules in space 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>Module(Data;Toppar;) 
 &_3_DATA set to $_2_DATA 
 &_3_TOPPAR set to $_2_TOPPAR 
 CNSsolve> 
 CNSsolve>  evaluate ($spacing=50) 
 EVALUATE: symbol $SPACING set to    50.0000     (real)
 CNSsolve>  evaluate ($trdis=$spacing/2) 
 EVALUATE: symbol $TRDIS set to    25.0000     (real)
 CNSsolve>  evaluate ($trc=sqrt($spacing**2 - $trdis**2)) 
 EVALUATE: symbol $TRC set to    43.3013     (real)
 CNSsolve>  evaluate ($trd=sqrt($spacing**2 - $trdis**2)) 
 EVALUATE: symbol $TRD set to    43.3013     (real)
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 EVALUATE: symbol $NCOUNT set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 EVALUATE: symbol $NCOUNT set to    1.00000     (real)
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 EVALUATE: symbol $WATERSEGNAME_1 set to "WAT1" (string)
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 SELRPN:   2970 atoms have been selected out of   3007
 COOR: using atom subset.
 MOMENTS
 213336.19355793      0.17822297      0.22189105
                 345412.17200698      0.08481202
                                 634848.66526597


 Oriented coordinate set r' related to original set r by r'=R*r  + T
 Translation vector T = (    0.0000    0.0000    0.0000)

 Rotation matrix =
    1.000000    0.000000    0.000001
    0.000000    1.000000    0.000001
   -0.000001   -0.000001    1.000000
 Corresp. Eulerian angles (theta1,theta2,theta3)     0.0000    0.0001    0.0000
 Corresp. spherical polar angles (psi,phi,kappa)     0.0000    0.0000    0.0000
 Corresp. rotation angle     0.0000 about axis       0.0000    1.0000    0.0000
 Corresp. quaternions     1.0000    0.0000    0.0000    0.0000

 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 SELRPN:   2970 atoms have been selected out of   3007
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 SELRPN:   2970 atoms have been selected out of   3007
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 SELRPN:   2970 atoms have been selected out of   3007
 CNSsolve>  end loop nsloop1 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 EVALUATE: symbol $NCOUNT set to    2.00000     (real)
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 EVALUATE: symbol $WATERSEGNAME_2 set to "WAT2" (string)
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 SELRPN:     37 atoms have been selected out of   3007
 COOR: using atom subset.
 MOMENTS
    477.75271480    494.18870876   -231.98809088
                    635.24566935   -233.56494787
                                    139.67140417


 Oriented coordinate set r' related to original set r by r'=R*r  + T
 Translation vector T = (    5.9451   -3.3562   -9.8137)

 Rotation matrix =
    0.305766   -0.719796   -0.623218
    0.512329    0.676109   -0.529523
    0.802512   -0.157383    0.575504
 Corresp. Eulerian angles (theta1,theta2,theta3)    78.9044   54.8651  229.6468
 Corresp. spherical polar angles (psi,phi,kappa)    42.0746  106.8060   73.8180
 Corresp. rotation angle    73.8180 about axis      -0.1937    0.7423   -0.6415
 Corresp. quaternions     0.7996   -0.1164    0.4458   -0.3852

 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 SELRPN:     37 atoms have been selected out of   3007
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 SELRPN:     37 atoms have been selected out of   3007
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 SELRPN:     37 atoms have been selected out of   3007
 CNSsolve>  end loop nsloop1 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nsloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate ($ncount = $ncount + 1) 
 CNSsolve>    eval($watersegname_$ncount="WAT" + encode($ncount)) 
 CNSsolve>    coor orient sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) end 
 CNSsolve>    do (xcomp = x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (ycomp = y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>    do (zcomp = z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>  end loop nsloop1 
 CNSsolve> 
 CNSsolve>  do (x = xcomp) (not (resn DAN or resn ANI or resn XAN)) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (y = ycomp) (not (resn DAN or resn ANI or resn XAN)) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (z = zcomp) (not (resn DAN or resn ANI or resn XAN)) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>  if ($data.ncomponents>1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 SELRPN:   2970 atoms have been selected out of   3007
 SHOW: maximum of selected elements =      33.664995
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 EVALUATE: symbol $XT set to   -58.6650     (real)
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 SELRPN:   2970 atoms have been selected out of   3007
 COOR: using atom subset.
 COOR: translation vector =(   -58.665000    0.000000    0.000000 )
 COOR: selected coordinates translated
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 SELRPN:     37 atoms have been selected out of   3007
 SHOW: minimum of selected elements =     -10.017396
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 EVALUATE: symbol $XT set to    35.0174     (real)
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 SELRPN:     37 atoms have been selected out of   3007
 COOR: using atom subset.
 COOR: translation vector =(    35.017400    0.000000    0.000000 )
 COOR: selected coordinates translated
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>2) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = $trc - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>3) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($zt = $trd - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>4) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($yt = 0.5 * ($trc - $result) ) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -($trd - $result) ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,$yt,$zt) end 
 CNSsolve>  end if 
 CNSsolve>  if ($data.ncomponents>5) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.ncomponents) loop nsloop2 
 CNSsolve>      evaluate ($ncount = $ncount +1) 
 CNSsolve>      show ave (x) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($xdis=-$result) 
 CNSsolve>      show ave (y) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($ydis=-$result) 
 CNSsolve>      show ave (z) (segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) 
 CNSsolve>      evaluate ($zdis=-$result) 
 CNSsolve>      coor trans sele=(segid $Toppar.prot_segid_$ncount or segid $watersegname_$ncount) vector=($xdis,$ydis,$zdis) end 
 CNSsolve>    end loop nsloop2 
 CNSsolve> 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_1 or segid $watersegname_1) 
 CNSsolve>    evaluate ($xt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_1 or segid $watersegname_1) vector=($xt,0,0) end 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_2 or segid $watersegname_2) 
 CNSsolve>    evaluate ($xt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_2 or segid $watersegname_2) vector=($xt,0,0) end 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_3 or segid $watersegname_3) 
 CNSsolve>    evaluate ($yt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_3 or segid $watersegname_3) vector=(0,$yt,0) end 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_4 or segid $watersegname_4) 
 CNSsolve>    evaluate ($yt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_4 or segid $watersegname_4) vector=(0,$yt,0) end 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_5 or segid $watersegname_5) 
 CNSsolve>    evaluate ($zt = -$trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_5 or segid $watersegname_5) vector=(0,0,$zt) end 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_6 or segid $watersegname_6) 
 CNSsolve>    evaluate ($zt = $trdis - $result ) 
 CNSsolve>    coor trans sele=(segid $Toppar.prot_segid_6 or segid $watersegname_6) vector=(0,0,$zt) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  do (x = refx) (resn ANI or resn DAN or resn XAN) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>  do (y = refy) (resn ANI or resn DAN or resn XAN) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>  do (z = refz) (resn ANI or resn DAN or resn XAN) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve> 
 CNSsolve>do (x = refx) (resn ANI or resn DAN or resn XAN) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>do (y = refy) (resn ANI or resn DAN or resn XAN) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>do (z = refz) (resn ANI or resn DAN or resn XAN) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>igroup 
 IGROup>  interaction  (not (resn ANI or resn DAN or resn XAN)) 
 SELRPN:   3007 atoms have been selected out of   3007
 SELRPN>               (not (resn ANI or resn DAN or resn XAN)) weight * 1 end 
 SELRPN:   3007 atoms have been selected out of   3007
 IGROup>  interaction  (resn ANI or resn DAN or resn XAN) 
 SELRPN:      0 atoms have been selected out of   3007
 SELRPN>               (resn ANI or resn DAN or resn XAN) weight * 1 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3007
 IGROup>end 
 CNSsolve> 
 CNSsolve>evaluate ($eintfree = 0.0) 
 EVALUATE: symbol $EINTFREE set to    0.00000     (real)
 CNSsolve>if ($iteration > 0) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  @RUN:protocols/flex_segment_back.cns 
 ASSFIL: file flex_segment_back.cns opened.
 CNSsolve>! flex_segment_back.cns 
 CNSsolve>!    Define the semi-flexible segments (both side-chains and backbone) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store5 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (store7 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>!first flexible segments for docking 
 CNSsolve>evaluate($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>  evaluate($fcounter=0) 
 EVALUATE: symbol $FCOUNTER set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>  if ($Toppar.nseg_$nchain1 = 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    display NO FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    if ($Toppar.nseg_$nchain1 < 0) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      display AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE $nchain1 
AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE 1
 CNSsolve>      inline @RUN:protocols/flexauto-neighbors.cns 
 ASSFIL: file flexauto-neighbors.cns opened.
 CNSsolve>! flexauto-neighbors.cns 
 CNSsolve>!    Automatic definition of flexible segments for docking for contacting residues 
 CNSsolve>!    including neighboring residues of residues making contacts 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($flcut = 5.0) 
 EVALUATE: symbol $FLCUT set to    5.00000     (real)
 CNSsolve> 
 CNSsolve>do (store5 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 SELRPN>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>do (store7 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 SELRPN>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>do (store6 = 0) (segid $Toppar.prot_segid_$nchain1) 
 SELRPN:   2970 atoms have been selected out of   3007
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = decode($result)) 
 CNSsolve>    evaluate ($preres = $inres) 
 CNSsolve>    evaluate ($nexres = $inres) 
 CNSsolve>    if ($iteration = 1) then 
 CNSsolve>      evaluate ($preres = $preres - 1) 
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>end loop flexres1 
 CNSsolve> 
 CNSsolve>do (store5 = store6) (segid $Toppar.prot_segid_$nchain1) 
 SELRPN:   2970 atoms have been selected out of   3007
 CNSsolve>do (store7 = store6) (segid $Toppar.prot_segid_$nchain1) 
 SELRPN:   2970 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>display THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule $nchain1 
THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule 1
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = $result) 
 CNSsolve>    show (resn) (id $id) 
 CNSsolve>    evaluate ($nares = $result) 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($seres = $result) 
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
 CNSsolve>end loop flexres2 
 CNSsolve> 
 CNSsolve>    else 
 CNSsolve>      display FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>      while ($fcounter < $Toppar.nseg_$nchain1) loop Xflex 
 CNSsolve>        evaluate($fcounter=$fcounter + 1) 
 CNSsolve>        do (store5 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>        display FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>      end loop Xflex 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>  evaluate($fcounter=0) 
 EVALUATE: symbol $FCOUNTER set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>  if ($Toppar.nseg_$nchain1 = 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    display NO FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    if ($Toppar.nseg_$nchain1 < 0) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      display AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE $nchain1 
AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE 2
 CNSsolve>      inline  
 CNSsolve>! flexauto-neighbors.cns 
 CNSsolve>!    Automatic definition of flexible segments for docking for contacting residues 
 CNSsolve>!    including neighboring residues of residues making contacts 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($flcut = 5.0) 
 EVALUATE: symbol $FLCUT set to    5.00000     (real)
 CNSsolve> 
 CNSsolve>do (store5 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 SELRPN>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>do (store7 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 SELRPN>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>do (store6 = 0) (segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     37 atoms have been selected out of   3007
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = decode($result)) 
 CNSsolve>    evaluate ($preres = $inres) 
 CNSsolve>    evaluate ($nexres = $inres) 
 CNSsolve>    if ($iteration = 1) then 
 CNSsolve>      evaluate ($preres = $preres - 1) 
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>end loop flexres1 
 CNSsolve> 
 CNSsolve>do (store5 = store6) (segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     37 atoms have been selected out of   3007
 CNSsolve>do (store7 = store6) (segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     37 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>display THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule $nchain1 
THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule 2
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = $result) 
 CNSsolve>    show (resn) (id $id) 
 CNSsolve>    evaluate ($nares = $result) 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($seres = $result) 
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
 CNSsolve>end loop flexres2 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    else 
 CNSsolve>      display FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>      while ($fcounter < $Toppar.nseg_$nchain1) loop Xflex 
 CNSsolve>        evaluate($fcounter=$fcounter + 1) 
 CNSsolve>        do (store5 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>        display FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>      end loop Xflex 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  evaluate($fcounter=0) 
 CNSsolve> 
 CNSsolve>  if ($Toppar.nseg_$nchain1 = 0) then 
 CNSsolve>    display NO FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    if ($Toppar.nseg_$nchain1 < 0) then 
 CNSsolve>      display AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE $nchain1 
 CNSsolve>      inline  
 CNSsolve>! flexauto-neighbors.cns 
 CNSsolve>!    Automatic definition of flexible segments for docking for contacting residues 
 CNSsolve>!    including neighboring residues of residues making contacts 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($flcut = 5.0) 
 CNSsolve> 
 CNSsolve>do (store5 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve>do (store7 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve> 
 CNSsolve>do (store6 = 0) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = decode($result)) 
 CNSsolve>    evaluate ($preres = $inres) 
 CNSsolve>    evaluate ($nexres = $inres) 
 CNSsolve>    if ($iteration = 1) then 
 CNSsolve>      evaluate ($preres = $preres - 1) 
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>end loop flexres1 
 CNSsolve> 
 CNSsolve>do (store5 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>do (store7 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve> 
 CNSsolve>display THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule $nchain1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = $result) 
 CNSsolve>    show (resn) (id $id) 
 CNSsolve>    evaluate ($nares = $result) 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($seres = $result) 
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
 CNSsolve>end loop flexres2 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    else 
 CNSsolve>      display FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>      while ($fcounter < $Toppar.nseg_$nchain1) loop Xflex 
 CNSsolve>        evaluate($fcounter=$fcounter + 1) 
 CNSsolve>        do (store5 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>        display FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>      end loop Xflex 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>!then fully flexible segments for all stages 
 CNSsolve>evaluate($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
NO FULLY FLEXIBLE SEGMENTS for molecule 1
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop2 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
NO FULLY FLEXIBLE SEGMENTS for molecule 2
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop2 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop2 
 CNSsolve> 
 CNSsolve>do (store5 = 7) ((resn WAT or resn HOH or resn TIP*)) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>evaluate ($nfletot = 0) 
 EVALUATE: symbol $NFLETOT set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>! check number of flexible residues per molecule 
 CNSsolve>evaluate($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop3 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>  do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store6 = 1) (tag and (attr store5 = $nchain1)) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>  show sum (store6) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =       0.000000
 CNSsolve>  evaluate ($numfle=$result) 
 EVALUATE: symbol $NUMFLE set to    0.00000     (real)
 CNSsolve>  do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not (attr store5 = $nchain1)) 
 SELRPN:    306 atoms have been selected out of   3007
 CNSsolve>  show sum (store6) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =     306.000000
 CNSsolve>  evaluate ($numrig=$result) 
 EVALUATE: symbol $NUMRIG set to    306.000     (real)
 CNSsolve>  do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:    306 atoms have been selected out of   3007
 CNSsolve>  show sum (store6) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =     306.000000
 CNSsolve>  evaluate ($numres=$result) 
 EVALUATE: symbol $NUMRES set to    306.000     (real)
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
FLEXIBILITY STATISTIC FOR MOLECULE 1 : Nres=306 Nrigid=306 Nflex=0
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 EVALUATE: symbol $NFLETOT set to    0.00000     (real)
 CNSsolve>end loop nloop3 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop3 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>  do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store6 = 1) (tag and (attr store5 = $nchain1)) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>  show sum (store6) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =       0.000000
 CNSsolve>  evaluate ($numfle=$result) 
 EVALUATE: symbol $NUMFLE set to    0.00000     (real)
 CNSsolve>  do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not (attr store5 = $nchain1)) 
 SELRPN:      1 atoms have been selected out of   3007
 CNSsolve>  show sum (store6) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =       1.000000
 CNSsolve>  evaluate ($numrig=$result) 
 EVALUATE: symbol $NUMRIG set to    1.00000     (real)
 CNSsolve>  do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      1 atoms have been selected out of   3007
 CNSsolve>  show sum (store6) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =       1.000000
 CNSsolve>  evaluate ($numres=$result) 
 EVALUATE: symbol $NUMRES set to    1.00000     (real)
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
FLEXIBILITY STATISTIC FOR MOLECULE 2 : Nres=1 Nrigid=1 Nflex=0
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 EVALUATE: symbol $NFLETOT set to    0.00000     (real)
 CNSsolve>end loop nloop3 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop3 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and (attr store5 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numfle=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not (attr store5 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numrig=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numres=$result) 
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 CNSsolve>end loop nloop3 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 SELRPN:      0 atoms have been selected out of   3007
 SHOW: zero atoms selected
 CNSsolve>evaluate ($nfletot = $nfletot + $result) 
 EVALUATE: symbol $NFLETOT set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = $nfletot + 10) 
 EVALUATE: symbol $NFLETOT set to    10.0000     (real)
 CNSsolve>  fix sele=(((attr store5 = 0) or resn ANI or resn DAN or resn XAN) and not name H* and not (resn WAT or resn HOH or resn TIP*)) end 
 SELRPN:   2481 atoms have been selected out of   3007
 CNSsolve>  minimize powell nstep=200 drop=10.0 nprint=25 end 
 POWELL: number of degrees of freedom=  1578
 NBONDS: generating intra-molecular exclusion list with mode= 5
 MAKINB: mode   5 found   7535 exclusions and   5314 interactions(1-4)
 NBONDS: found   205364 intra-atom interactions
 --------------- cycle=    25 ------ stepsize=    0.0004 -----------------------
 | Etotal =27971.312  grad(E)=131.763    E(BOND)=391.816    E(ANGL)=1444.888   |
 | E(DIHE)=1799.433   E(IMPR)=25143.599  E(VDW )=291.520    E(ELEC)=-1099.944  |
 -------------------------------------------------------------------------------
 --------------- cycle=    50 ------ stepsize=    0.0001 -----------------------
 | Etotal =27968.097  grad(E)=131.760    E(BOND)=391.628    E(ANGL)=1444.457   |
 | E(DIHE)=1801.312   E(IMPR)=25143.807  E(VDW )=291.411    E(ELEC)=-1104.519  |
 -------------------------------------------------------------------------------
 NBONDS: found   205364 intra-atom interactions
 --------------- cycle=    75 ------ stepsize=    0.0001 -----------------------
 | Etotal =27964.845  grad(E)=131.778    E(BOND)=391.657    E(ANGL)=1444.742   |
 | E(DIHE)=1800.633   E(IMPR)=25144.463  E(VDW )=291.084    E(ELEC)=-1107.734  |
 -------------------------------------------------------------------------------
 --------------- cycle=   100 ------ stepsize=    0.0002 -----------------------
 | Etotal =27963.956  grad(E)=131.786    E(BOND)=391.613    E(ANGL)=1444.457   |
 | E(DIHE)=1800.432   E(IMPR)=25143.403  E(VDW )=292.045    E(ELEC)=-1107.994  |
 -------------------------------------------------------------------------------
 NBONDS: found   205368 intra-atom interactions
 --------------- cycle=   125 ------ stepsize=    0.0003 -----------------------
 | Etotal =27960.003  grad(E)=131.734    E(BOND)=391.700    E(ANGL)=1444.487   |
 | E(DIHE)=1799.499   E(IMPR)=25143.936  E(VDW )=291.390    E(ELEC)=-1111.008  |
 -------------------------------------------------------------------------------
 NBONDS: found   205383 intra-atom interactions
 --------------- cycle=   150 ------ stepsize=    0.0001 -----------------------
 | Etotal =27958.190  grad(E)=131.760    E(BOND)=391.604    E(ANGL)=1444.453   |
 | E(DIHE)=1799.294   E(IMPR)=25143.607  E(VDW )=292.267    E(ELEC)=-1113.034  |
 -------------------------------------------------------------------------------
 --------------- cycle=   175 ------ stepsize=    0.0000 -----------------------
 | Etotal =27957.249  grad(E)=131.764    E(BOND)=391.619    E(ANGL)=1444.496   |
 | E(DIHE)=1799.597   E(IMPR)=25143.405  E(VDW )=291.887    E(ELEC)=-1113.754  |
 -------------------------------------------------------------------------------
 --------------- cycle=   200 ------ stepsize=    0.0010 -----------------------
 | Etotal =27956.600  grad(E)=131.783    E(BOND)=391.723    E(ANGL)=1444.519   |
 | E(DIHE)=1800.309   E(IMPR)=25142.978  E(VDW )=291.945    E(ELEC)=-1114.874  |
 -------------------------------------------------------------------------------
 POWELL: STEP number limit. Normal termination
 POWELL: Current coordinates set to last minimum
 CNSsolve>  fix sele=(not all) end 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>  energy end 
 --------------- cycle=     1 --------------------------------------------------
 | Etotal =27956.600  grad(E)=131.783    E(BOND)=391.723    E(ANGL)=1444.519   |
 | E(DIHE)=1800.309   E(IMPR)=25142.978  E(VDW )=291.945    E(ELEC)=-1114.874  |
 -------------------------------------------------------------------------------
 CNSsolve>  evaluate ($eintfree = $bond + $angl + $impr + $dihe + $vdw + $elec) 
 EVALUATE: symbol $EINTFREE set to    27956.6     (real)
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>display FREE MOLECULES INTERNAL ENERGY = $eintfree 
FREE MOLECULES INTERNAL ENERGY = 27956.6
 CNSsolve> 
 CNSsolve>{====>} {* define ASA-based solvation parameters *} 
 CNSsolve>inline @RUN:protocols/def_solv_param.cns 
 ASSFIL: file def_solv_param.cns opened.
 CNSsolve>! def_solv_param.cns 
 CNSsolve>!    Define atomic solvation parameters taken from Fernandez-Recio et al. JMB 335:843 (2004) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($arofac = 6.26) 
 EVALUATE: symbol $AROFAC set to    6.26000     (real)
 CNSsolve>evaluate ($alifac = 1.27) 
 EVALUATE: symbol $ALIFAC set to    1.27000     (real)
 CNSsolve>evaluate ($polfac = 2.30) 
 EVALUATE: symbol $POLFAC set to    2.30000     (real)
 CNSsolve>do (store1 =  0.0000) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (store1 =  0.0151 * $alifac) (name C*) 
 SELRPN:   1598 atoms have been selected out of   3007
 CNSsolve>do (store1 =  0.0176 * $arofac) ((name CG* or name CD* or name CE* or name CH* or name CZ*) and (resn PHE or resn TYR or resn HIS or resn TRP)) 
 SELRPN:    183 atoms have been selected out of   3007
 CNSsolve>do (store1 = -0.0170 * $polfac) (name N*) 
 SELRPN:    415 atoms have been selected out of   3007
 CNSsolve>do (store1 = -0.0548 * $polfac) (name NT* or (name NZ* and resn LYS)) 
 SELRPN:     23 atoms have been selected out of   3007
 CNSsolve>do (store1 = -0.0273 * $polfac) (name NH* and resn ARG) 
 SELRPN:     28 atoms have been selected out of   3007
 CNSsolve>do (store1 = -0.0136 * $polfac) (name O*) 
 SELRPN:    452 atoms have been selected out of   3007
 CNSsolve>do (store1 = -0.0185 * $polfac) (name OG* or name OH) 
 SELRPN:     38 atoms have been selected out of   3007
 CNSsolve>do (store1 = -0.0299 * $polfac) ((name OD* and resn ASP) or (name OE* and resn GLU)) 
 SELRPN:     90 atoms have been selected out of   3007
 CNSsolve>do (store1 =  0.0112 * $polfac) (name S*) 
 SELRPN:     16 atoms have been selected out of   3007
 CNSsolve>do (store1 =  0.0022 * $polfac) ((name S* and attr charge = -0.3) or (name SD and resn MET)) 
 SELRPN:     10 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>{====>} {* buried surface area *} 
 CNSsolve>evaluate ($esolfree = 0) 
 EVALUATE: symbol $ESOLFREE set to    0.00000     (real)
 CNSsolve>evaluate ($nchain1 = 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>evaluate ($saafree = 0) 
 EVALUATE: symbol $SAAFREE set to    0.00000     (real)
 CNSsolve>while ($nchain1 <= $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  coor orient sele=(segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn ANI or resn DAN or resn XAN)) end 
 SELRPN:   2970 atoms have been selected out of   3007
 COOR: using atom subset.
 MOMENTS
 213319.16314875     10.74106531    -40.58283579
                 345423.48320734     53.41944268
                                 634848.24092264


 Oriented coordinate set r' related to original set r by r'=R*r  + T
 Translation vector T = (   58.6643   -0.0112    0.0045)

 Rotation matrix =
    1.000000    0.000185   -0.000096
   -0.000185    1.000000    0.000081
    0.000096   -0.000081    1.000000
 Corresp. Eulerian angles (theta1,theta2,theta3)     0.0106    0.0072    0.0000
 Corresp. spherical polar angles (psi,phi,kappa)   115.5168  113.7878  359.9872
 Corresp. rotation angle     0.0128 about axis       0.3640    0.4308    0.8258
 Corresp. quaternions     1.0000    0.0000    0.0000    0.0001

 CNSsolve>  {====>} {* buried surface area *} 
 CNSsolve>  do (rmsd = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store2 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  surface mode=access accu=0.075 rh2o=1.4 sele=(segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) end 
 SELRPN:   2970 atoms have been selected out of   3007
 SURFAC: half the sigma value being used for atomic radii.
 SURFAC: ACCEssible surface area
 SURFAC: ACCUracy= 0.07 RH2O=  1.40
         Z-grid=  0.32 number-of-Z-sections=  145
         measures-of-arc= 26586 and 34201
 CNSsolve>  show sum (rmsd) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 SELRPN:   2970 atoms have been selected out of   3007
 SHOW: sum over selected elements =   15139.308284
 CNSsolve>  evaluate ($saafree = $saafree + $result) 
 EVALUATE: symbol $SAAFREE set to    15139.3     (real)
 CNSsolve>  do (store2 = rmsd * store1) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 SELRPN:   2970 atoms have been selected out of   3007
 CNSsolve>  show sum (store2) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 SELRPN:   2970 atoms have been selected out of   3007
 SHOW: sum over selected elements =     -80.459274
 CNSsolve>  evaluate ($esolfree = $esolfree + $result) 
 EVALUATE: symbol $ESOLFREE set to   -80.4593     (real)
 CNSsolve>  evaluate ($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain1 <= $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  coor orient sele=(segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn ANI or resn DAN or resn XAN)) end 
 SELRPN:     37 atoms have been selected out of   3007
 COOR: using atom subset.
 MOMENTS
     19.11088045     -0.00957987      0.10707133
                     71.21497114     -0.19997852
                                   1162.33527854


 Oriented coordinate set r' related to original set r by r'=R*r  + T
 Translation vector T = (  -93.6817    0.0005    0.0008)

 Rotation matrix =
    1.000000   -0.000183    0.000094
    0.000183    1.000000   -0.000183
   -0.000094    0.000184    1.000000
 Corresp. Eulerian angles (theta1,theta2,theta3)   207.0314    0.0118  152.9581
 Corresp. spherical polar angles (psi,phi,kappa)   109.8527  135.0320    0.0158
 Corresp. rotation angle     0.0158 about axis      -0.6655   -0.3396   -0.6647
 Corresp. quaternions     1.0000   -0.0001    0.0000   -0.0001

 CNSsolve>  {====>} {* buried surface area *} 
 CNSsolve>  do (rmsd = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store2 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  surface mode=access accu=0.075 rh2o=1.4 sele=(segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) end 
 SELRPN:     37 atoms have been selected out of   3007
 SURFAC: half the sigma value being used for atomic radii.
 SURFAC: ACCEssible surface area
 SURFAC: ACCUracy= 0.07 RH2O=  1.40
         Z-grid=  0.32 number-of-Z-sections=   27
         measures-of-arc=   106 and   333
 CNSsolve>  show sum (rmsd) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 SELRPN:     37 atoms have been selected out of   3007
 SHOW: sum over selected elements =     628.342596
 CNSsolve>  evaluate ($saafree = $saafree + $result) 
 EVALUATE: symbol $SAAFREE set to    15767.7     (real)
 CNSsolve>  do (store2 = rmsd * store1) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 SELRPN:     37 atoms have been selected out of   3007
 CNSsolve>  show sum (store2) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 SELRPN:     37 atoms have been selected out of   3007
 SHOW: sum over selected elements =      10.127271
 CNSsolve>  evaluate ($esolfree = $esolfree + $result) 
 EVALUATE: symbol $ESOLFREE set to   -70.3320     (real)
 CNSsolve>  evaluate ($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    3.00000     (real)
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain1 <= $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>  coor orient sele=(segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS or resn ANI or resn DAN or resn XAN)) end 
 CNSsolve>  {====>} {* buried surface area *} 
 CNSsolve>  do (rmsd = 0) (all) 
 CNSsolve>  do (store2 = 0) (all) 
 CNSsolve>  surface mode=access accu=0.075 rh2o=1.4 sele=(segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) end 
 CNSsolve>  show sum (rmsd) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 CNSsolve>  evaluate ($saafree = $saafree + $result) 
 CNSsolve>  do (store2 = rmsd * store1) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 CNSsolve>  show sum (store2) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 CNSsolve>  evaluate ($esolfree = $esolfree + $result) 
 CNSsolve>  evaluate ($nchain1 = $nchain1 + 1) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>do (x = refx) (resn ANI or resn DAN or resn XAN) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>do (y = refy) (resn ANI or resn DAN or resn XAN) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>do (z = refz) (resn ANI or resn DAN or resn XAN) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>{* ======================= reset coordinates and proceed *} 
 CNSsolve> 
 CNSsolve>do (x = refx) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (y = refy) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (z = refz) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>inline @RUN:protocols/read_water1.cns 
 ASSFIL: file read_water1.cns opened.
 CNSsolve>! read_water1.cns 
 CNSsolve>!   Read water coordinates from solvated docking 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($nchain=0) 
 EVALUATE: symbol $NCHAIN set to    0.00000     (real)
 CNSsolve>while ($nchain < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    1.00000     (real)
 CNSsolve>  evaluate ($watersegname_$nchain="WAT" + encode($nchain)) 
 EVALUATE: symbol $WATERSEGNAME_1 set to "WAT1" (string)
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    2.00000     (real)
 CNSsolve>  evaluate ($watersegname_$nchain="WAT" + encode($nchain)) 
 EVALUATE: symbol $WATERSEGNAME_2 set to "WAT2" (string)
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($nchain = $nchain + 1) 
 CNSsolve>  evaluate ($watersegname_$nchain="WAT" + encode($nchain)) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($data.waterdock eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  noe reset end 
 CNSsolve>  rest dihe reset end 
 CNSsolve>  evaluate($watercoorfile = $file - ".pdb" + "_water.pdbw") 
 CNSsolve>  fileexist $watercoorfile end 
 CNSsolve>  evaluate ($waterfileexist=$result) 
 CNSsolve>  if ($waterfileexist eq true) then 
 CNSsolve>    if ($iteration < 2) then 
 CNSsolve>      evaluate($sol_topology_infile="RUN:/toppar/water-allhdg5-4.top") 
 CNSsolve>      topology @@$sol_topology_infile end 
 CNSsolve>    end if 
 CNSsolve>    segment 
 CNSsolve>      chain 
 CNSsolve>        separate-by-segid = true 
 CNSsolve>        coor @@$watercoorfile 
 CNSsolve>      end 
 CNSsolve>    end 
 CNSsolve>    coor @@$watercoorfile 
 CNSsolve>    ident (store5) (not all) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve>if ($data.waterdock eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  inline @RUN:protocols/water_rest.cns 
 ASSFIL: file water_rest.cns opened.
 CNSsolve>! water_rest.cns 
 CNSsolve>!    Define restraints between interfacial water molecules and highly solvated 
 CNSsolve>!    amino-acids 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>! This script define distance restraints between water molecule and amino-acids 
 CNSsolve>! often found to be involved in water-mediated contacts 
 CNSsolve>! See van Dijk and Bonvin, Bioinformatics 2006 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($nchain=0) 
 CNSsolve>while ($nchain < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate ($nchain = $nchain + 1) 
 CNSsolve>  evaluate ($watersegname_$nchain="WAT" + encode($nchain)) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($data.waterdock eq true) then 
 CNSsolve> 
 CNSsolve>  if ($data.solvate_method eq "restraints") then 
 CNSsolve>    evaluate ($nchain=0) 
 CNSsolve>    while ($nchain < $data.ncomponents) loop nloop2 
 CNSsolve>      evaluate ($nchain = $nchain + 1) 
 CNSsolve>      noe class amwa end 
 CNSsolve>      for $atom_id in id ((resn WAT or resn HOH) and name OH2 and segid $watersegname_$nchain and not store5) loop waterrestraint 
 CNSsolve>        noe 
 CNSsolve>          assi (segid $toppar.prot_segid_$nchain and 
 CNSsolve>	        (resn arg or resn asn or resn asp or resn gln or resn glu or resn his* 
 CNSsolve>		 or resn lys or resn pro or resn ser or resn thr or resn tyr) 
 CNSsolve>	        and ((id $atom_id) around $data.water_restraint_cutoff)) 
 CNSsolve>               (id $atom_id) $data.water_restraint_cutoff $data.water_restraint_cutoff 0.0 
 CNSsolve>        end 
 CNSsolve>      end loop waterrestraint 
 CNSsolve>    end loop nloop2 
 CNSsolve>    evaluate($amwa_scale = $data.water_restraint_scale) 
 CNSsolve>    noe scale amwa $amwa_scale end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve>  set seed $seed end 
 CNSsolve>  set message=normal echo=on end 
 CNSsolve>  @@RUN:protocols/read_data.cns(Iteration=$Iteration; Data=$Data; count=$count) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>!set the energy flags: 
 CNSsolve>@@RUN:protocols/flags_new.cns(Iteration=$Iteration; Data=$Data; ) 
 ASSFIL: file flags_new.cns opened.
 CNSsolve>! flags_new.cns 
 CNSsolve>!    Defines energy flags 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module(Iteration; Data; ) 
 &_2_ITERATION set to $_1_ITERATION 
 &_2_DATA set to $_1_DATA 
 CNSsolve> 
 CNSsolve>if ($Data.cdih.on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   evaluate ($Data.flags.cdih =  true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.c1_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.coup =  true) 
 CNSsolve>elseif ($Data.c2_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.coup =  true) 
 CNSsolve>elseif ($Data.c3_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.coup =  true) 
 CNSsolve>elseif ($Data.c4_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.coup =  true) 
 CNSsolve>elseif ($Data.c5_on eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.coup =  true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.rdc1_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.sani = true) 
 CNSsolve>elseif ($Data.rdc2_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.sani = true) 
 CNSsolve>elseif ($Data.rdc3_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.sani = true) 
 CNSsolve>elseif ($Data.rdc4_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.sani = true) 
 CNSsolve>elseif ($Data.rdc5_choice eq "SANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.sani = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.rdc1_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xrdc = true) 
 CNSsolve>elseif ($Data.rdc2_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xrdc = true) 
 CNSsolve>elseif ($Data.rdc3_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xrdc = true) 
 CNSsolve>elseif ($Data.rdc4_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xrdc = true) 
 CNSsolve>elseif ($Data.rdc5_choice eq "XRDC") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xrdc = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.pcs1_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs2_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs3_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs4_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs5_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs6_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs7_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs8_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcs9_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>elseif ($Data.pcsA_choice eq "XPCS") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.xpcs = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.dan1_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.DANI = true) 
 CNSsolve>elseif ($Data.dan2_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.DANI = true) 
 CNSsolve>elseif ($Data.dan3_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.DANI = true) 
 CNSsolve>elseif ($Data.dan4_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.DANI = true) 
 CNSsolve>elseif ($Data.dan5_choice eq "DANI") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.DANI = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sani eq TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.harm = true) 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.dani eq TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.harm = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.rdc1_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.vean = true) 
 CNSsolve>end if 
 CNSsolve>if ($Data.rdc2_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.vean = true) 
 CNSsolve>end if 
 CNSsolve>if ($Data.rdc3_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.vean = true) 
 CNSsolve>end if 
 CNSsolve>if ($Data.rdc4_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.vean = true) 
 CNSsolve>end if 
 CNSsolve>if ($Data.rdc5_choice eq "VANGLE") then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($Data.flags.vean = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.noe  =  TRUE) then 
 NEXTCD: condition evaluated as true
 CNSsolve>   flags include noe end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.cdih =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include cdih end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.coup =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include coup end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.vean =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include vean end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.sani =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include sani end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.xrdc =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include xrdc end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.xpcs =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include xpcs end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.dani =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include dani end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.plan =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include plan end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.ncs  =  TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   flags include ncs end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.rg = TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($data.rgtarg > 0) then 
 CNSsolve>    flags include coll end 
 CNSsolve>  else 
 CNSsolve>    evaluate ($Data.flags.rg = false) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>{* random removal of restaints ================================== *} 
 CNSsolve>if ($Data.noecv eq true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  set message=on echo=on end 
 CNSsolve>  noe cv $npart ? end 
 NOE: total number of restraints:     2 partitioned into      2 classes
 NOE: ceiling=    1000.000 current allocation= 4000000
 NOE: data are partitioned into working set and test set.
 NOE: test set number=     2
 CNSsolve>else 
 CNSsolve>  evaluate ($npart = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ( $log_level = verbose ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>   set message=normal echo=on end 
 CNSsolve>else 
 CNSsolve>   set message=off echo=off end 
 NOE: total number of restraints:     2 partitioned into      2 classes
 NOE: ceiling=    1000.000 current allocation= 4000000
 NOE: data are partitioned into working set and test set.
 NOE: test set number=     2
 MISCOM: file does not exist
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond CD_  C_  
 %PARRDR-info: duplication of bond CM_  CT_ 
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle C3R  OH   HO  
 %PARRDR-info: duplication of angle C3__ C3__ HC__
 %PARRDR-info: duplication of angle CD_  CM_  CT_ 
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of angle CM_  CT_  CT_ 
 %PARRDR-info: duplication of angle CPA  NPH1 FEH 
 %PARRDR-info: duplication of angle CPA  NPH2 FEH 
 %PARRDR-info: duplication of angle CT_  CT_  C_  
 %PARRDR-info: duplication of angle CT_  CT_  HC_ 
 %PARRDR-info: duplication of angle CT_  CT_  HP_ 
 %PARRDR-info: duplication of angle CT_  CT_  N3_ 
 %PARRDR-info: duplication of angle H1__ C3__ OH__
 %PARRDR-info: duplication of angle HP_  CT_  N3_ 
 %PARRDR-info: duplication of angle HR   C3R  O3R 
 %PARRDR-info: duplication of angle HR   C3R  OH  
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond CD_  C_  
 %PARRDR-info: duplication of bond CM_  CT_ 
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle C3R  OH   HO  
 %PARRDR-info: duplication of angle C3__ C3__ HC__
 %PARRDR-info: duplication of angle CD_  CM_  CT_ 
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of angle CM_  CT_  CT_ 
 %PARRDR-info: duplication of angle CPA  NPH1 FEH 
 %PARRDR-info: duplication of angle CPA  NPH2 FEH 
 %PARRDR-info: duplication of angle CT_  CT_  C_  
 %PARRDR-info: duplication of angle CT_  CT_  HC_ 
 %PARRDR-info: duplication of angle CT_  CT_  HP_ 
 %PARRDR-info: duplication of angle CT_  CT_  N3_ 
 %PARRDR-info: duplication of angle H1__ C3__ OH__
 %PARRDR-info: duplication of angle HP_  CT_  N3_ 
 %PARRDR-info: duplication of angle HR   C3R  O3R 
 %PARRDR-info: duplication of angle HR   C3R  OH  
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 -----nonbonded-list-options-------------------------------
 | CUTNb=   9.500 TOLErance=   0.500 WMIN=   0.500 ATOM   |
 | INHIbit=   0.250                                       |
 -----electrostatic options--------------------------------
 | EPS=  10.000 E14Fac=   0.400 CDIElectric POTEN SHIFt   |
 -----van der Waals options--------------------------------
 | VSWItch                                                |
 -----switching /shifting parameters-----------------------
 | CTONNB=   6.500 CTOFNB=   8.500                        |
 -----exclusion list options-------------------------------
 | NBXMOD=   5                                            |
 ----------------------------------------------------------
 %PARRDR-info: duplication of bond C    OC  
 %PARRDR-info: duplication of bond CD_  C_  
 %PARRDR-info: duplication of bond CM_  CT_ 
 %PARRDR-info: duplication of bond HC   NC2 
 %PARRDR-info: duplication of angle C3R  OH   HO  
 %PARRDR-info: duplication of angle C3__ C3__ HC__
 %PARRDR-info: duplication of angle CD_  CM_  CT_ 
 %PARRDR-info: duplication of angle CH2P CH2E HA  
 %PARRDR-info: duplication of angle CM_  CT_  CT_ 
 %PARRDR-info: duplication of angle CPA  NPH1 FEH 
 %PARRDR-info: duplication of angle CPA  NPH2 FEH 
 %PARRDR-info: duplication of angle CT_  CT_  C_  
 %PARRDR-info: duplication of angle CT_  CT_  HC_ 
 %PARRDR-info: duplication of angle CT_  CT_  HP_ 
 %PARRDR-info: duplication of angle CT_  CT_  N3_ 
 %PARRDR-info: duplication of angle H1__ C3__ OH__
 %PARRDR-info: duplication of angle HP_  CT_  N3_ 
 %PARRDR-info: duplication of angle HR   C3R  O3R 
 %PARRDR-info: duplication of angle HR   C3R  OH  
 %PARRDR-info: duplication of angle OC   C    OC  
 %PARRDR-info: duplication of nonbonded entry H   
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HC  
 %PARRDR-info: duplication of nonbonded entry HO  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry HA  
 %PARRDR-info: duplication of nonbonded entry OC  
 %PARRDR-info: duplication of nonbonded entry C   
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = 0) 
 EVALUATE: symbol $NCOUNT set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate ($dim_$ncount = 0.0) 
 EVALUATE: symbol $DIM_0 set to    0.00000     (real)
 CNSsolve>    evaluate ($ncount = $ncount +1) 
 EVALUATE: symbol $NCOUNT set to    1.00000     (real)
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 SELRPN:    306 atoms have been selected out of   3007
 SHOW: maximum of selected elements =      31.030000
 CNSsolve>    evaluate ($xdim = $result) 
 EVALUATE: symbol $XDIM set to    31.0300     (real)
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 SELRPN:    306 atoms have been selected out of   3007
 SHOW: maximum of selected elements =      24.597000
 CNSsolve>    evaluate ($ydim = $result) 
 EVALUATE: symbol $YDIM set to    24.5970     (real)
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 SELRPN:    306 atoms have been selected out of   3007
 SHOW: maximum of selected elements =      18.902000
 CNSsolve>    evaluate ($zdim = $result) 
 EVALUATE: symbol $ZDIM set to    18.9020     (real)
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 SELRPN:    306 atoms have been selected out of   3007
 SHOW: minimum of selected elements =     -26.110000
 CNSsolve>    evaluate ($xdim = $xdim - $result) 
 EVALUATE: symbol $XDIM set to    57.1400     (real)
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 SELRPN:    306 atoms have been selected out of   3007
 SHOW: minimum of selected elements =     -20.978000
 CNSsolve>    evaluate ($ydim = $ydim - $result) 
 EVALUATE: symbol $YDIM set to    45.5750     (real)
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 SELRPN:    306 atoms have been selected out of   3007
 SHOW: minimum of selected elements =     -19.516000
 CNSsolve>    evaluate ($zdim = $zdim - $result) 
 EVALUATE: symbol $ZDIM set to    38.4180     (real)
 CNSsolve>    evaluate ($corr = max($xdim,$ydim)) 
 EVALUATE: symbol $CORR set to    57.1400     (real)
 CNSsolve>    evaluate ($corr = max($corr,$zdim)) 
 EVALUATE: symbol $CORR set to    57.1400     (real)
 CNSsolve>    do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>    do (store6 = 1) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 SELRPN:    306 atoms have been selected out of   3007
 CNSsolve>    show sum (store6) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =     306.000000
 CNSsolve>    if ($result eq 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($corr = 0.0) 
 CNSsolve>    end if 
 CNSsolve>    evaluate ($dim_$ncount = ($xdim + $ydim + $zdim - $corr)/4.0) 
 EVALUATE: symbol $DIM_1 set to    20.9983     (real)
 CNSsolve>    if ($toppar.dna_$ncount = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($dim_$ncount = 0.0) 
 CNSsolve>    end if 
 CNSsolve>  end loop nloop1 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate ($dim_$ncount = 0.0) 
 EVALUATE: symbol $DIM_1 set to    0.00000     (real)
 CNSsolve>    evaluate ($ncount = $ncount +1) 
 EVALUATE: symbol $NCOUNT set to    2.00000     (real)
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 SELRPN:      1 atoms have been selected out of   3007
 SHOW: maximum of selected elements =       8.991000
 CNSsolve>    evaluate ($xdim = $result) 
 EVALUATE: symbol $XDIM set to    8.99100     (real)
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 SELRPN:      1 atoms have been selected out of   3007
 SHOW: maximum of selected elements =       2.126000
 CNSsolve>    evaluate ($ydim = $result) 
 EVALUATE: symbol $YDIM set to    2.12600     (real)
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 SELRPN:      1 atoms have been selected out of   3007
 SHOW: maximum of selected elements =       3.562000
 CNSsolve>    evaluate ($zdim = $result) 
 EVALUATE: symbol $ZDIM set to    3.56200     (real)
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 SELRPN:      1 atoms have been selected out of   3007
 SHOW: minimum of selected elements =       8.991000
 CNSsolve>    evaluate ($xdim = $xdim - $result) 
 EVALUATE: symbol $XDIM set to    0.00000     (real)
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 SELRPN:      1 atoms have been selected out of   3007
 SHOW: minimum of selected elements =       2.126000
 CNSsolve>    evaluate ($ydim = $ydim - $result) 
 EVALUATE: symbol $YDIM set to    0.00000     (real)
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 SELRPN:      1 atoms have been selected out of   3007
 SHOW: minimum of selected elements =       3.562000
 CNSsolve>    evaluate ($zdim = $zdim - $result) 
 EVALUATE: symbol $ZDIM set to    0.00000     (real)
 CNSsolve>    evaluate ($corr = max($xdim,$ydim)) 
 EVALUATE: symbol $CORR set to    0.00000     (real)
 CNSsolve>    evaluate ($corr = max($corr,$zdim)) 
 EVALUATE: symbol $CORR set to    0.00000     (real)
 CNSsolve>    do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>    do (store6 = 1) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 SELRPN:      1 atoms have been selected out of   3007
 CNSsolve>    show sum (store6) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =       1.000000
 CNSsolve>    if ($result eq 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($corr = 0.0) 
 CNSsolve>    end if 
 CNSsolve>    evaluate ($dim_$ncount = ($xdim + $ydim + $zdim - $corr)/4.0) 
 EVALUATE: symbol $DIM_2 set to    0.00000     (real)
 CNSsolve>    if ($toppar.dna_$ncount = true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($dim_$ncount = 0.0) 
 CNSsolve>    end if 
 CNSsolve>  end loop nloop1 
 CNSsolve>  while ($ncount < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate ($dim_$ncount = 0.0) 
 CNSsolve>    evaluate ($ncount = $ncount +1) 
 CNSsolve>    show max (x) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 CNSsolve>    evaluate ($xdim = $result) 
 CNSsolve>    show max (y) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 CNSsolve>    evaluate ($ydim = $result) 
 CNSsolve>    show max (z) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 CNSsolve>    evaluate ($zdim = $result) 
 CNSsolve>    show min (x) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 CNSsolve>    evaluate ($xdim = $xdim - $result) 
 CNSsolve>    show min (y) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 CNSsolve>    evaluate ($ydim = $ydim - $result) 
 CNSsolve>    show min (z) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 CNSsolve>    evaluate ($zdim = $zdim - $result) 
 CNSsolve>    evaluate ($corr = max($xdim,$ydim)) 
 CNSsolve>    evaluate ($corr = max($corr,$zdim)) 
 CNSsolve>    do (store6 = 0) (all) 
 CNSsolve>    do (store6 = 1) (segid $Toppar.prot_segid_$ncount and (name CA or name N1)) 
 CNSsolve>    show sum (store6) (all) 
 CNSsolve>    if ($result eq 0) then 
 CNSsolve>      evaluate ($corr = 0.0) 
 CNSsolve>    end if 
 CNSsolve>    evaluate ($dim_$ncount = ($xdim + $ydim + $zdim - $corr)/4.0) 
 CNSsolve>    if ($toppar.dna_$ncount = true) then 
 CNSsolve>      evaluate ($dim_$ncount = 0.0) 
 CNSsolve>    end if 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  eval($nchain = 0) 
 EVALUATE: symbol $NCHAIN set to    0.00000     (real)
 CNSsolve>  do (store9 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store9 = 1) (name CA or name N1) 
 SELRPN:    307 atoms have been selected out of   3007
 CNSsolve>  while ($nchain < $data.ncomponents) loop nloop0 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    1.00000     (real)
 CNSsolve>    show sum (store9) (segid $Toppar.prot_segid_$nchain) 
 SELRPN:   2970 atoms have been selected out of   3007
 SHOW: sum over selected elements =     306.000000
 CNSsolve>    if ($result < 3) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($selat$nchain = 0 ) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($selat$nchain = 1 ) 
 EVALUATE: symbol $SELAT1 set to    1.00000     (real)
 CNSsolve>    end if 
 CNSsolve>  end loop nloop0 
 CNSsolve>  while ($nchain < $data.ncomponents) loop nloop0 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    2.00000     (real)
 CNSsolve>    show sum (store9) (segid $Toppar.prot_segid_$nchain) 
 SELRPN:     37 atoms have been selected out of   3007
 SHOW: sum over selected elements =       1.000000
 CNSsolve>    if ($result < 3) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($selat$nchain = 0 ) 
 EVALUATE: symbol $SELAT2 set to    0.00000     (real)
 CNSsolve>    else 
 CNSsolve>      evaluate ($selat$nchain = 1 ) 
 CNSsolve>    end if 
 CNSsolve>  end loop nloop0 
 CNSsolve>  while ($nchain < $data.ncomponents) loop nloop0 
 NEXTCD: condition evaluated as false
 CNSsolve>    eval($nchain = $nchain + 1) 
 CNSsolve>    show sum (store9) (segid $Toppar.prot_segid_$nchain) 
 CNSsolve>    if ($result < 3) then 
 CNSsolve>      evaluate ($selat$nchain = 0 ) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($selat$nchain = 1 ) 
 CNSsolve>    end if 
 CNSsolve>  end loop nloop0 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>  noe 
 NOE>    class contact 
 NOE>    while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 NOE>      eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 NOE>      eval($nchain2 = $nchain1 ) 
 EVALUATE: symbol $NCHAIN2 set to    1.00000     (real)
 NOE>      while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as true
 NOE>        eval($nchain2 = $nchain2 + 1) 
 EVALUATE: symbol $NCHAIN2 set to    2.00000     (real)
 NOE>        eval($cm_dist = $dim_$nchain1 + $dim_$nchain2) 
 EVALUATE: symbol $CM_DIST set to    0.00000     (real)
 NOE>        if ($selat$nchain1 = 1) then 
 NEXTCD: condition evaluated as true
 NOE>          if ($selat$nchain2 = 1) then 
 NEXTCD: condition evaluated as false
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 SELRPN:    306 atoms have been selected out of   3007
 SELRPN>	               (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 SELRPN:     37 atoms have been selected out of   3007
 NOE>	      end if 
 NOE>	    else 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>	      end if 
 NOE>	    end if 
 NOE>      end loop nloop2 
 NOE>      while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as false
 NOE>        eval($nchain2 = $nchain2 + 1) 
 NOE>        eval($cm_dist = $dim_$nchain1 + $dim_$nchain2) 
 NOE>        if ($selat$nchain1 = 1) then 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>	      end if 
 NOE>	    else 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>	      end if 
 NOE>	    end if 
 NOE>      end loop nloop2 
 NOE>    end loop nloop1 
 NOE>    while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 NOE>      eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 NOE>      eval($nchain2 = $nchain1 ) 
 EVALUATE: symbol $NCHAIN2 set to    2.00000     (real)
 NOE>      while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as false
 NOE>        eval($nchain2 = $nchain2 + 1) 
 NOE>        eval($cm_dist = $dim_$nchain1 + $dim_$nchain2) 
 NOE>        if ($selat$nchain1 = 1) then 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>	      end if 
 NOE>	    else 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>	      end if 
 NOE>	    end if 
 NOE>      end loop nloop2 
 NOE>    end loop nloop1 
 NOE>    while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 NOE>      eval($nchain1 = $nchain1 + 1) 
 NOE>      eval($nchain2 = $nchain1 ) 
 NOE>      while ($nchain2 < $data.ncomponents) loop nloop2 
 NOE>        eval($nchain2 = $nchain2 + 1) 
 NOE>        eval($cm_dist = $dim_$nchain1 + $dim_$nchain2) 
 NOE>        if ($selat$nchain1 = 1) then 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>	      end if 
 NOE>	    else 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $cm_dist $cm_dist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $cm_dist $cm_dist 1.0 
 NOE>	      end if 
 NOE>	    end if 
 NOE>      end loop nloop2 
 NOE>    end loop nloop1 
 NOE> 
 NOE>    averaging  contact center 
 NOE>    scale      contact $Data.kcont 
 NOE>    sqconstant contact 1.0 
 NOE>    sqexponent contact 2 
 NOE>    soexponent contact 1 
 NOE>    rswitch    contact 1.0 
 NOE>    sqoffset   contact 0.0 
 NOE>    asymptote  contact 2.0 
 NOE>    msoexponent contact 1 
 NOE>    masymptote  contact -0.1 
 NOE>    mrswitch    contact 1.0 
 NOE>  end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.surfrest eq true ) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  @RUN:protocols/surf-restraints.cns 
 ASSFIL: file surf-restraints.cns opened.
 CNSsolve>! surf-restraints.cns 
 CNSsolve>!    Define surface contact restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>!define surface contact restraints between all molecules 
 CNSsolve>!using distance restraints between CA atoms with sum averaging 
 CNSsolve> 
 CNSsolve>  set echo=on message=on end 
 CNSsolve> 
 CNSsolve>  eval($nchain = 0) 
 EVALUATE: symbol $NCHAIN set to    0.00000     (real)
 CNSsolve>  do (store9 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store9 = 1) (name CA or name N1) 
 SELRPN:    307 atoms have been selected out of   3007
 CNSsolve>  while ($nchain < $data.ncomponents) loop nloop0 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    1.00000     (real)
 CNSsolve>    show sum (store9) (segid $Toppar.prot_segid_$nchain) 
 SELRPN:   2970 atoms have been selected out of   3007
 SHOW: sum over selected elements =     306.000000
 CNSsolve>    if ($result < 3) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($selat$nchain = 0) 
 CNSsolve>      evaluate ($dist$nchain = 1.0) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($selat$nchain = 1) 
 EVALUATE: symbol $SELAT1 set to    1.00000     (real)
 CNSsolve>      evaluate ($dist$nchain = 3.5) 
 EVALUATE: symbol $DIST1 set to    3.50000     (real)
 CNSsolve>    end if 
 CNSsolve>  end loop nloop0 
 CNSsolve>  while ($nchain < $data.ncomponents) loop nloop0 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain = $nchain + 1) 
 EVALUATE: symbol $NCHAIN set to    2.00000     (real)
 CNSsolve>    show sum (store9) (segid $Toppar.prot_segid_$nchain) 
 SELRPN:     37 atoms have been selected out of   3007
 SHOW: sum over selected elements =       1.000000
 CNSsolve>    if ($result < 3) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($selat$nchain = 0) 
 EVALUATE: symbol $SELAT2 set to    0.00000     (real)
 CNSsolve>      evaluate ($dist$nchain = 1.0) 
 EVALUATE: symbol $DIST2 set to    1.00000     (real)
 CNSsolve>    else 
 CNSsolve>      evaluate ($selat$nchain = 1) 
 CNSsolve>      evaluate ($dist$nchain = 3.5) 
 CNSsolve>    end if 
 CNSsolve>  end loop nloop0 
 CNSsolve>  while ($nchain < $data.ncomponents) loop nloop0 
 NEXTCD: condition evaluated as false
 CNSsolve>    eval($nchain = $nchain + 1) 
 CNSsolve>    show sum (store9) (segid $Toppar.prot_segid_$nchain) 
 CNSsolve>    if ($result < 3) then 
 CNSsolve>      evaluate ($selat$nchain = 0) 
 CNSsolve>      evaluate ($dist$nchain = 1.0) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($selat$nchain = 1) 
 CNSsolve>      evaluate ($dist$nchain = 3.5) 
 CNSsolve>    end if 
 CNSsolve>  end loop nloop0 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>  noe class surface 
 NOE>    while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 NOE>      eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 NOE>      eval($nchain2 = $nchain1 ) 
 EVALUATE: symbol $NCHAIN2 set to    1.00000     (real)
 NOE>      while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as true
 NOE>        eval($nchain2 = $nchain2 + 1) 
 EVALUATE: symbol $NCHAIN2 set to    2.00000     (real)
 NOE>        evaluate ($updist = $dist$nchain1 + $dist$nchain2) 
 EVALUATE: symbol $UPDIST set to    4.50000     (real)
 NOE>        if ($selat$nchain1 = 1) then 
 NEXTCD: condition evaluated as true
 NOE>          if ($selat$nchain2 = 1) then 
 NEXTCD: condition evaluated as false
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 SELRPN:    306 atoms have been selected out of   3007
 SELRPN>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 SELRPN:     37 atoms have been selected out of   3007
 NOE>	      end if 
 NOE>	    else 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    end if 
 NOE>      end loop nloop2 
 NOE>      while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as false
 NOE>        eval($nchain2 = $nchain2 + 1) 
 NOE>        evaluate ($updist = $dist$nchain1 + $dist$nchain2) 
 NOE>        if ($selat$nchain1 = 1) then 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    else 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    end if 
 NOE>      end loop nloop2 
 NOE>    end loop nloop1 
 NOE>    while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 NOE>      eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 NOE>      eval($nchain2 = $nchain1 ) 
 EVALUATE: symbol $NCHAIN2 set to    2.00000     (real)
 NOE>      while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as false
 NOE>        eval($nchain2 = $nchain2 + 1) 
 NOE>        evaluate ($updist = $dist$nchain1 + $dist$nchain2) 
 NOE>        if ($selat$nchain1 = 1) then 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    else 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    end if 
 NOE>      end loop nloop2 
 NOE>    end loop nloop1 
 NOE>    while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 NOE>      eval($nchain1 = $nchain1 + 1) 
 NOE>      eval($nchain2 = $nchain1 ) 
 NOE>      while ($nchain2 < $data.ncomponents) loop nloop2 
 NOE>        eval($nchain2 = $nchain2 + 1) 
 NOE>        evaluate ($updist = $dist$nchain1 + $dist$nchain2) 
 NOE>        if ($selat$nchain1 = 1) then 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1 and ( name CA or name N1 )) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    else 
 NOE>          if ($selat$nchain2 = 1) then 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2 and ( name CA or name N1 )) $updist $updist 1.0 
 NOE>	      else 
 NOE>            assign (segid $Toppar.prot_segid_$nchain1) 
 NOE>	               (segid $Toppar.prot_segid_$nchain2) $updist $updist 1.0 
 NOE>	      end if 
 NOE>	    end if 
 NOE>      end loop nloop2 
 NOE>    end loop nloop1 
 NOE> 
 NOE>    averaging  surface sum 
 NOE>    scale      surface $Data.ksurf 
 NOE>    sqconstant surface 1.0 
 NOE>    sqexponent surface 2 
 NOE>    soexponent surface 1 
 NOE>    rswitch    surface 1.0 
 NOE>    sqoffset   surface 0.0 
 NOE>    asymptote  surface 2.0 
 NOE>    msoexponent surface 1 
 NOE>    masymptote  surface -0.1 
 NOE>    mrswitch    surface 1.0 
 NOE>  end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.dnarest eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  @RUN:data/sequence/dna-rna_restraints.def 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.rg eq true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  collapse 
 CNSsolve>    force  $Data.krg_hot 
 CNSsolve>    target $Data.rgtarg 
 CNSsolve>    sele   (not (resn ANI or resn XAN or resn TIP*)) 
 CNSsolve>  end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.ssdihed eq all ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  @RUN:protocols/protein-ss-restraints-all.def 
 ASSFIL: file protein-ss-restraints-all.def opened.
 CNSsolve>! protein-ss-restraints-all.def 
 CNSsolve>!    Define automatically secondary stucture dihedral angle restraints for all residues 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{+ file: protein-ss-restraints.def       directory: protocols +} 
 CNSsolve>{+ description: Creates dihedral angle restraints to maintain conformation of the protein backbone 
 CNSsolve>            <br><br> 
 CNSsolve>Additions and changes were made to allow for flexibility during docking<br><br> 
 CNSsolve>Changes include: <br> 
 CNSsolve><ul> 
 CNSsolve><li> flags to turn all options on or off 
 CNSsolve><li> separation of sugar 
 CNSsolve><li> pucker restraints and phosphate backbone restraints 
 CNSsolve><li> option to have sugar-phosphate backbone dihedrals measured and restrained within a user defined error range 
 CNSsolve><li> option to have the length of the Watson-Crick hydrogen bonds measured from the structure measured and restrained within a user defined error range. 
 CNSsolve></ul> 
 CNSsolve> 
 CNSsolve> +} 
 CNSsolve>{+ comment:This file is to be read by refinement files that modify atom coordinates +} 
 CNSsolve>{+ authors: Axel T. Brunger, and Paul D. Adams, <br> 
 CNSsolve>            modified by Alexandre Bonvin for HADDOCK use +} 
 CNSsolve> 
 CNSsolve>set message=normal echo=on end 
 CNSsolve> 
 CNSsolve>{- begin block parameter definition -} define( 
 CNSsolve> 
 CNSsolve>{================================ backbone dihedral angle restraints =============================} 
 CNSsolve> 
 CNSsolve>{* Pick the dihedral angles of the protein backbone from the input structure and 
 CNSsolve>   restrain them within the given error range *} 
 CNSsolve>{+ choice: true false +} 
 CNSsolve>{===>} prot_pick_bacdih=true; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 1 *} 
 CNSsolve>{===>} prot_dihedral_1=(segid A); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_1=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 2 *} 
 CNSsolve>{===>} prot_dihedral_2=(segid B); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_2=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 3 *} 
 CNSsolve>{===>} prot_dihedral_3=(segid C); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_3=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 4 *} 
 CNSsolve>{===>} prot_dihedral_4=(segid D); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_4=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 5 *} 
 CNSsolve>{===>} prot_dihedral_5=(segid E); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_5=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 6 *} 
 CNSsolve>{===>} prot_dihedral_6=(segid F); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_6=10.0; 
 CNSsolve> 
 CNSsolve>{=========================================================================================================} 
 CNSsolve>{                        things below this line do not normally need to be changed                        } 
 CNSsolve>{=========================================================================================================} 
 CNSsolve> 
 CNSsolve> ) {- end block parameter definition -} 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{- Dihedral restraints for the protein backbone -} 
 CNSsolve> 
 CNSsolve>if (&prot_pick_bacdih=true) then 
 CNSsolve>  restraint dihedral 
 CNSsolve>    nass = 10000 
 CNSsolve>  end 
 CNSsolve>  evaluate ($group=1) 
 CNSsolve>  evaluate ($done=false) 
 CNSsolve>  while ( $done = false ) loop bdihe 
 CNSsolve>   if ( &exist_prot_dihedral_$group = true ) then 
 CNSsolve>     show sum(1) ( &prot_dihedral_$group ) 
 CNSsolve>     if ( $result > 0 ) then 
 CNSsolve>       evaluate ($error_phi=&error_dih_$group) 
 CNSsolve>       evaluate ($error_psi=&error_dih_$group) 
 CNSsolve> 
 CNSsolve>       for $id in id ( &prot_dihedral_$group and tag and not resn TIP* ) loop resid 
 CNSsolve>         show (segid) (id $id) 
 CNSsolve>         evaluate ($segid=$result) 
 CNSsolve>         show (resid) ( id $id ) 
 CNSsolve>         evaluate ($resid=decode($result)) 
 CNSsolve>         evaluate ($rprec = $resid - 1) 
 CNSsolve>         show (resid) (resid $rprec and name CA) 
 CNSsolve>         if ($result ne 0) then 
 CNSsolve>           evaluate ($rprec = $resid - 1) 
 CNSsolve>	   pick dihedral 
 CNSsolve>                     ( segid $segid and resid $rprec and name C ) 
 CNSsolve>                     ( segid $segid and resid $resid and name N ) 
 CNSsolve>                     ( segid $segid and resid $resid and name CA ) 
 CNSsolve>                     ( segid $segid and resid $resid and name C ) 
 CNSsolve>		  geometry 
 CNSsolve>	   evaluatate ($dihedral_phi=$result) 
 CNSsolve>           restraint dihedral 
 CNSsolve>	    ! phi 
 CNSsolve>             assign  ( segid $segid and resid $rprec and name C ) 
 CNSsolve>                     ( segid $segid and resid $resid and name N ) 
 CNSsolve>                     ( segid $segid and resid $resid and name CA ) 
 CNSsolve>                     ( segid $segid and resid $resid and name C ) 
 CNSsolve>                                                       1.0 $dihedral_phi $error_phi 2 
 CNSsolve>             scale 200.0 
 CNSsolve>           end 
 CNSsolve>         end if 
 CNSsolve> 
 CNSsolve>         evaluate ($rnext = $resid + 1) 
 CNSsolve>         show (resid) (resid $rnext and name CA) 
 CNSsolve>         if ($result ne 0) then 
 CNSsolve>  	   pick dihedral 
 CNSsolve>                     ( segid $segid and resid $resid and name N ) 
 CNSsolve>                     ( segid $segid and resid $resid and name CA ) 
 CNSsolve>                     ( segid $segid and resid $resid and name C ) 
 CNSsolve>                     ( segid $segid and resid $rnext and name N ) 
 CNSsolve>		  geometry 
 CNSsolve>	   evaluatate ($dihedral_psi=$result) 
 CNSsolve>           restraint dihedral 
 CNSsolve>	    ! psi 
 CNSsolve>             assign  ( segid $segid and resid $resid and name N ) 
 CNSsolve>                     ( segid $segid and resid $resid and name CA ) 
 CNSsolve>                     ( segid $segid and resid $resid and name C ) 
 CNSsolve>                     ( segid $segid and resid $rnext and name N ) 
 CNSsolve>                                                       1.0 $dihedral_psi $error_psi 2 
 CNSsolve>             scale 200.0 
 CNSsolve>           end 
 CNSsolve>         end if 
 CNSsolve>       end loop resid 
 CNSsolve>     end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve>     evaluate ($group=$group+1) 
 CNSsolve> end loop bdihe 
 CNSsolve> 
 CNSsolve> flags include cdih end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>set message=off echo=off end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve>if ($Data.ssdihed eq alpha ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  @RUN:protocols/protein-ss-restraints-alpha.def 
 ASSFIL: file protein-ss-restraints-alpha.def opened.
 CNSsolve>! protein-ss-restraints-alpha.def 
 CNSsolve>!    Define automatically secondary structure dihedral angle restraints 
 CNSsolve>!    for helical segments 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{+ file: protein-ss-restraints.def       directory: protocols +} 
 CNSsolve>{+ description: Creates dihedral angle restraints to maintain conformation of the protein backbone +} 
 CNSsolve>{+ comment:This file is to be read by refinement files that modify atom coordinates +} 
 CNSsolve>{+ authors: Axel T. Brunger, and Paul D. Adams, <br> 
 CNSsolve>            modified by Alexandre Bonvin for HADDOCK use +} 
 CNSsolve> 
 CNSsolve>set message=normal echo=on end 
 CNSsolve> 
 CNSsolve>{- begin block parameter definition -} define( 
 CNSsolve> 
 CNSsolve>{================================ backbone dihedral angle restraints =============================} 
 CNSsolve> 
 CNSsolve>{* Pick the dihedral angles of the protein backbone from the input structure and 
 CNSsolve>   restrain them within the given error range *} 
 CNSsolve>{+ choice: true false +} 
 CNSsolve>{===>} prot_pick_bacdih=true; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 1 *} 
 CNSsolve>{===>} prot_dihedral_1=(segid A); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_1=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 2 *} 
 CNSsolve>{===>} prot_dihedral_2=(segid B); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_2=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 3 *} 
 CNSsolve>{===>} prot_dihedral_3=(segid C); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_3=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 4 *} 
 CNSsolve>{===>} prot_dihedral_4=(segid D); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_4=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 5 *} 
 CNSsolve>{===>} prot_dihedral_5=(segid E); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_5=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 6 *} 
 CNSsolve>{===>} prot_dihedral_6=(segid F); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_6=10.0; 
 CNSsolve> 
 CNSsolve>{=========================================================================================================} 
 CNSsolve>{                        things below this line do not normally need to be changed                        } 
 CNSsolve>{=========================================================================================================} 
 CNSsolve> 
 CNSsolve> ) {- end block parameter definition -} 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{- Dihedral restraints for the protein backbone -} 
 CNSsolve> 
 CNSsolve>if (&prot_pick_bacdih=true) then 
 CNSsolve>  restraint dihedral 
 CNSsolve>    nass = 10000 
 CNSsolve>  end 
 CNSsolve>  evaluate ($group=1) 
 CNSsolve>  evaluate ($done=false) 
 CNSsolve>  while ( $done = false ) loop bdihe 
 CNSsolve>   if ( &exist_prot_dihedral_$group = true ) then 
 CNSsolve>     show sum(1) ( &prot_dihedral_$group ) 
 CNSsolve>     if ( $result > 0 ) then 
 CNSsolve>       evaluate ($error_phi=&error_dih_$group) 
 CNSsolve>       evaluate ($error_psi=&error_dih_$group) 
 CNSsolve> 
 CNSsolve>       for $id in id ( &prot_dihedral_$group and tag and not resn TIP* ) loop resid 
 CNSsolve>         show (segid) (id $id) 
 CNSsolve>         evaluate ($segid=$result) 
 CNSsolve>         show (resid) ( id $id ) 
 CNSsolve>         evaluate ($resid=decode($result)) 
 CNSsolve>	 evaluate ($alphaphi = 0) 
 CNSsolve>	 evaluate ($alphapsi = 0) 
 CNSsolve> 	 evaluate ($alpha_check = 0) 
 CNSsolve> 
 CNSsolve>         evaluate ($rprec = $resid - 1) 
 CNSsolve>         show (resid) (resid $rprec and name CA) 
 CNSsolve>         if ($result ne 0) then 
 CNSsolve>	   pick dihedral 
 CNSsolve>                     ( segid $segid and resid $rprec and name C ) 
 CNSsolve>                     ( segid $segid and resid $resid and name N ) 
 CNSsolve>                     ( segid $segid and resid $resid and name CA ) 
 CNSsolve>                     ( segid $segid and resid $resid and name C ) 
 CNSsolve>		  geometry 
 CNSsolve>	   evaluate ($dihedral_phi=$result) 
 CNSsolve>           evaluate ($alphaphi=max($dihedral_phi,-77)) 
 CNSsolve>           evaluate ($alphaphi=max($dihedral_phi,-37)) 
 CNSsolve>	   if ($alphaphi eq -37) then 
 CNSsolve>             evaluate ($alpha_check = 1) 
 CNSsolve>	   else 
 CNSsolve>	     evaluate ($alpha_check = 0) 
 CNSsolve>	   end if 
 CNSsolve>         end if 
 CNSsolve> 
 CNSsolve>         evaluate ($rnext = $resid + 1) 
 CNSsolve>         show (resid) (resid $rnext and name CA) 
 CNSsolve>         if ($result ne 0) then 
 CNSsolve>  	   pick dihedral 
 CNSsolve>                     ( segid $segid and resid $resid and name N ) 
 CNSsolve>                     ( segid $segid and resid $resid and name CA ) 
 CNSsolve>                     ( segid $segid and resid $resid and name C ) 
 CNSsolve>                     ( segid $segid and resid $rnext and name N ) 
 CNSsolve>		  geometry 
 CNSsolve>	   evaluate ($dihedral_psi=$result) 
 CNSsolve>           evaluate ($alphapsi=max($dihedral_psi,-67)) 
 CNSsolve>           evaluate ($alphapsi=max($dihedral_psi,-27)) 
 CNSsolve>	   if ($alphapsi eq -27) then 
 CNSsolve>             evaluate ($alpha_check = $alpha_check + 1) 
 CNSsolve>	   end if 
 CNSsolve>	 end if 
 CNSsolve> 
 CNSsolve>	 evaluate ($defrest = 0) 
 CNSsolve>	 if ($alpha_check eq 2) then 
 CNSsolve>	   evaluate ($defrest = 1) 
 CNSsolve>	 end if 
 CNSsolve>	 if ($defrest = 1) then 
 CNSsolve>           restraint dihedral 
 CNSsolve>	    ! phi 
 CNSsolve>             assign  ( segid $segid and resid $rprec and name C ) 
 CNSsolve>                     ( segid $segid and resid $resid and name N ) 
 CNSsolve>                     ( segid $segid and resid $resid and name CA ) 
 CNSsolve>                     ( segid $segid and resid $resid and name C ) 
 CNSsolve>                                                       1.0 $dihedral_phi $error_phi 2 
 CNSsolve>	    ! psi 
 CNSsolve>             assign  ( segid $segid and resid $resid and name N ) 
 CNSsolve>                     ( segid $segid and resid $resid and name CA ) 
 CNSsolve>                     ( segid $segid and resid $resid and name C ) 
 CNSsolve>                     ( segid $segid and resid $rnext and name N ) 
 CNSsolve>                                                       1.0 $dihedral_psi $error_psi 2 
 CNSsolve>             scale 200.0 
 CNSsolve>           end 
 CNSsolve>         end if 
 CNSsolve>       end loop resid 
 CNSsolve>     end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve>     evaluate ($group=$group+1) 
 CNSsolve> end loop bdihe 
 CNSsolve> 
 CNSsolve> flags include cdih end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>set message=off echo=off end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve>if ($Data.ssdihed eq alphabeta ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  @RUN:protocols/protein-ss-restraints-alpha-beta.def 
 ASSFIL: file protein-ss-restraints-alpha-beta.def opened.
 CNSsolve>! protein-ss-restraints-alpha-beta.def 
 CNSsolve>!    Define automatically secondary structure dihedral angle restraints 
 CNSsolve>!    for helical and beta-sheet segments 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{+ file: protein-ss-restraints.def       directory: protocols +} 
 CNSsolve>{+ description: Creates dihedral angle restraints to maintain conformation of the protein backbone +} 
 CNSsolve>{+ comment:This file is to be read by refinement files that modify atom coordinates +} 
 CNSsolve>{+ authors: Axel T. Brunger, and Paul D. Adams, <br> 
 CNSsolve>            modified by Alexandre Bonvin for HADDOCK use +} 
 CNSsolve> 
 CNSsolve>set message=normal echo=on end 
 CNSsolve> 
 CNSsolve>{- begin block parameter definition -} define( 
 CNSsolve> 
 CNSsolve>{================================ backbone dihedral angle restraints =============================} 
 CNSsolve> 
 CNSsolve>{* Pick the dihedral angles of the protein backbone from the input structure and 
 CNSsolve>   restrain them within the given error range *} 
 CNSsolve>{+ choice: true false +} 
 CNSsolve>{===>} prot_pick_bacdih=true; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 1 *} 
 CNSsolve>{===>} prot_dihedral_1=(segid A); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_1=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 2 *} 
 CNSsolve>{===>} prot_dihedral_2=(segid B); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_2=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 3 *} 
 CNSsolve>{===>} prot_dihedral_3=(segid C); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_3=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 4 *} 
 CNSsolve>{===>} prot_dihedral_4=(segid D); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_4=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 5 *} 
 CNSsolve>{===>} prot_dihedral_5=(segid E); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_5=10.0; 
 CNSsolve> 
 CNSsolve>{* residues with backbone restrained - group 6 *} 
 CNSsolve>{===>} prot_dihedral_6=(segid F); 
 CNSsolve> 
 CNSsolve>{* dihedral angle range *} 
 CNSsolve>{===>} error_dih_6=10.0; 
 CNSsolve> 
 CNSsolve>{=========================================================================================================} 
 CNSsolve>{                        things below this line do not normally need to be changed                        } 
 CNSsolve>{=========================================================================================================} 
 CNSsolve> 
 CNSsolve> ) {- end block parameter definition -} 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{- Dihedral restraints for the protein backbone -} 
 CNSsolve> 
 CNSsolve>if (&prot_pick_bacdih=true) then 
 CNSsolve>  restraint dihedral 
 CNSsolve>    nass = 10000 
 CNSsolve>  end 
 CNSsolve>  evaluate ($group=1) 
 CNSsolve>  evaluate ($done=false) 
 CNSsolve>  while ( $done = false ) loop bdihe 
 CNSsolve>   if ( &exist_prot_dihedral_$group = true ) then 
 CNSsolve>     show sum(1) ( &prot_dihedral_$group ) 
 CNSsolve>     if ( $result > 0 ) then 
 CNSsolve>       evaluate ($error_phi=&error_dih_$group) 
 CNSsolve>       evaluate ($error_psi=&error_dih_$group) 
 CNSsolve> 
 CNSsolve>       for $id in id ( &prot_dihedral_$group and tag and not resn TIP* ) loop resid 
 CNSsolve>         show (segid) (id $id) 
 CNSsolve>         evaluate ($segid=$result) 
 CNSsolve>         show (resid) ( id $id ) 
 CNSsolve>         evaluate ($resid=decode($result)) 
 CNSsolve>	 evaluate ($alphaphi = 0) 
 CNSsolve>	 evaluate ($alphapsi = 0) 
 CNSsolve> 	 evaluate ($alpha_check = 0) 
 CNSsolve>	 evaluate ($betaphi = 0) 
 CNSsolve>	 evaluate ($betapsi = 0) 
 CNSsolve> 	 evaluate ($beta_check = 0) 
 CNSsolve> 
 CNSsolve>         evaluate ($rprec = $resid - 1) 
 CNSsolve>         show (resid) (resid $rprec and name CA) 
 CNSsolve>         if ($result ne 0) then 
 CNSsolve>	   pick dihedral 
 CNSsolve>                     ( segid $segid and resid $rprec and name C ) 
 CNSsolve>                     ( segid $segid and resid $resid and name N ) 
 CNSsolve>                     ( segid $segid and resid $resid and name CA ) 
 CNSsolve>                     ( segid $segid and resid $resid and name C ) 
 CNSsolve>		  geometry 
 CNSsolve>	   evaluate ($dihedral_phi=$result) 
 CNSsolve>           evaluate ($alphaphi=max($dihedral_phi,-77)) 
 CNSsolve>           evaluate ($alphaphi=max($dihedral_phi,-37)) 
 CNSsolve>	   if ($alphaphi eq -37) then 
 CNSsolve>             evaluate ($alpha_check = 1) 
 CNSsolve>	   else 
 CNSsolve>	     evaluate ($alpha_check = 0) 
 CNSsolve>	   end if 
 CNSsolve>           evaluate ($betaphi=max($dihedral_phi,-145)) 
 CNSsolve>           evaluate ($betaphi=max($dihedral_phi,-105)) 
 CNSsolve>	   if ($betaphi eq -105) then 
 CNSsolve>             evaluate ($beta_check = 1) 
 CNSsolve>	   else 
 CNSsolve>	     evaluate ($beta_check = 0) 
 CNSsolve>	   end if 
 CNSsolve>         end if 
 CNSsolve> 
 CNSsolve>         evaluate ($rnext = $resid + 1) 
 CNSsolve>         show (resid) (resid $rnext and name CA) 
 CNSsolve>         if ($result ne 0) then 
 CNSsolve>  	   pick dihedral 
 CNSsolve>                     ( segid $segid and resid $resid and name N ) 
 CNSsolve>                     ( segid $segid and resid $resid and name CA ) 
 CNSsolve>                     ( segid $segid and resid $resid and name C ) 
 CNSsolve>                     ( segid $segid and resid $rnext and name N ) 
 CNSsolve>		  geometry 
 CNSsolve>	   evaluate ($dihedral_psi=$result) 
 CNSsolve>           evaluate ($alphapsi=max($dihedral_psi,-67)) 
 CNSsolve>           evaluate ($alphapsi=max($dihedral_psi,-27)) 
 CNSsolve>	   if ($alphapsi eq -27) then 
 CNSsolve>             evaluate ($alpha_check = $alpha_check + 1) 
 CNSsolve>	   end if 
 CNSsolve>           evaluate ($betapsi=max($dihedral_psi,105)) 
 CNSsolve>           evaluate ($betapsi=max($dihedral_psi,145)) 
 CNSsolve>	   if ($betapsi eq 145) then 
 CNSsolve>             evaluate ($beta_check = $beta_check + 1) 
 CNSsolve>	   end if 
 CNSsolve>	 end if 
 CNSsolve> 
 CNSsolve>	 evaluate ($defrest = 0) 
 CNSsolve>	 if ($alpha_check eq 2) then 
 CNSsolve>	   evaluate ($defrest = 1) 
 CNSsolve>	 end if 
 CNSsolve>	 if ($beta_check eq 2) then 
 CNSsolve>	   evaluate ($defrest = 1) 
 CNSsolve>	 end if 
 CNSsolve>	 if ($defrest = 1) then 
 CNSsolve>           restraint dihedral 
 CNSsolve>	    ! phi 
 CNSsolve>             assign  ( segid $segid and resid $rprec and name C ) 
 CNSsolve>                     ( segid $segid and resid $resid and name N ) 
 CNSsolve>                     ( segid $segid and resid $resid and name CA ) 
 CNSsolve>                     ( segid $segid and resid $resid and name C ) 
 CNSsolve>                                                       1.0 $dihedral_phi $error_phi 2 
 CNSsolve>	    ! psi 
 CNSsolve>             assign  ( segid $segid and resid $resid and name N ) 
 CNSsolve>                     ( segid $segid and resid $resid and name CA ) 
 CNSsolve>                     ( segid $segid and resid $resid and name C ) 
 CNSsolve>                     ( segid $segid and resid $rnext and name N ) 
 CNSsolve>                                                       1.0 $dihedral_psi $error_psi 2 
 CNSsolve>             scale 200.0 
 CNSsolve>           end 
 CNSsolve>         end if 
 CNSsolve>       end loop resid 
 CNSsolve>     end if 
 CNSsolve>   else 
 CNSsolve>     evaluate ($done=true) 
 CNSsolve>   end if 
 CNSsolve>     evaluate ($group=$group+1) 
 CNSsolve> end loop bdihe 
 CNSsolve> 
 CNSsolve> flags include cdih end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>set message=off echo=off end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! get initial energy 
 CNSsolve>energy end 
 NBONDS: generating intra-molecular exclusion list with mode= 5
 MAKINB: mode   5 found   7535 exclusions and   5314 interactions(1-4)
 NBONDS: found   210476 intra-atom interactions
 --------------- cycle=     2 --------------------------------------------------
 | Etotal =28094.495  grad(E)=132.092    E(BOND)=391.471    E(ANGL)=1444.444   |
 | E(DIHE)=1799.217   E(IMPR)=25142.369  E(VDW )=382.460    E(ELEC)=-1106.544  |
 | E(NOE )=41.078                                                              |
 -------------------------------------------------------------------------------
 CNSsolve> 
 CNSsolve>coor copy end 
 COOR: selected main coordinates copied to comp
 CNSsolve> 
 CNSsolve>if ($iterations.rotate180 eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($rotiter = 2)  {* two iteration in rotloop1, rotation *} 
 CNSsolve>else 
 CNSsolve>  evaluate ($rotiter = 1)  {* only one iteration in rotloop1, no rotation *} 
 EVALUATE: symbol $ROTITER set to    1.00000     (real)
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($nlcount = 0)  {* two iterations in rotloop1, first rotated *} 
 EVALUATE: symbol $NLCOUNT set to    0.00000     (real)
 CNSsolve>{* ================== Loop to sample 180 degrees rotated solutions if requested *} 
 CNSsolve> 
 CNSsolve>while ($nlcount < $rotiter) loop rotloop1 
 NEXTCD: condition evaluated as true
 CNSsolve> 
 CNSsolve>  evaluate ($nlcount = $nlcount + 1) 
 EVALUATE: symbol $NLCOUNT set to    1.00000     (real)
 CNSsolve> 
 CNSsolve>  evaluate ($unamb_scale = $Data.unamb_hot) 
 EVALUATE: symbol $UNAMB_SCALE set to    10.0000     (real)
 CNSsolve>  evaluate ($ambig_scale = $Data.amb_hot) 
 EVALUATE: symbol $AMBIG_SCALE set to    10.0000     (real)
 CNSsolve>  evaluate ($hbond_scale = $Data.hbond_hot) 
 EVALUATE: symbol $HBOND_SCALE set to    10.0000     (real)
 CNSsolve> 
 CNSsolve>  noe 
 NOE>    scale dist $unamb_scale 
 NOE>    scale ambi $ambig_scale 
 NOE>    scale hbon $hbond_scale 
 NOE>  end 
 CNSsolve> 
 CNSsolve>  if ($Data.flags.dihed eq true) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    flag include dihed end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.scaling eq TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    inline @RUN:protocols/set_noe_scale.cns 
 ASSFIL: file set_noe_scale.cns opened.
 CNSsolve>! set_noe_scale.cns 
 CNSsolve>!    Set the distance restraint force constant 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($enoe   = 0.0 ) 
 CNSsolve>evaluate ($vdw    = 0.0 ) 
 CNSsolve>evaluate ($elec   = 0.0 ) 
 CNSsolve>evaluate ($einter = 0.0 ) 
 CNSsolve>evaluate ($noescale = 1.0 ) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym ne true) then 
 CNSsolve>  print threshold=0.5 noe 
 CNSsolve>  evaluate ($numnoe=$violations) 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_amb > 0) then 
 CNSsolve>    evaluate ($ambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_amb)))) 
 CNSsolve>    if ($ambcorr = 0) then 
 CNSsolve>      evaluate ($ambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($ambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_unamb > 0) then 
 CNSsolve>    evaluate ($unambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_unamb)))) 
 CNSsolve>    if ($unambcorr = 0) then 
 CNSsolve>      evaluate ($unambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($unambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve>else 
 CNSsolve>  evaluate ($unambcorr = 1) 
 CNSsolve>  evaluate ($ambcorr = 1) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>eval ($nchain1 = 0) 
 CNSsolve>igroup 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction  (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                   (segid $Toppar.prot_segid_$nchain2) weights * 1 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>  end loop nloop1 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>energy end 
 CNSsolve>igroup 
 CNSsolve>    interaction  (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($einter = abs($vdw + $elec)) 
 CNSsolve>evaluate ($enoe   = $noe) 
 CNSsolve> 
 CNSsolve>if ($enoe ne 0) then 
 CNSsolve>  evaluate ($noescale = min(5000, (2 * $einter / $enoe))) 
 CNSsolve>  if ($noescale ne 0) then 
 CNSsolve>    evaluate ($Data.unamb_hot   = $Data.unamb_hot   * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_hot     = $Data.amb_hot     * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool1 = $Data.unamb_cool1 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool1   = $Data.amb_cool1   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool2 = $Data.unamb_cool2 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool2   = $Data.amb_cool2   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool3 = $Data.unamb_cool3 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool3   = $Data.amb_cool3   * $noescale * $ambcorr) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>    energy end 
 CNSsolve>    noe 
 CNSsolve>      scale dist $Data.unamb_hot 
 CNSsolve>      scale ambi $Data.amb_hot 
 CNSsolve>    end 
 CNSsolve>    energy end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.flags.sani eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    sani class rdc1 force $Data.rdc1_hot end 
 CNSsolve>    sani class rdc2 force $Data.rdc2_hot end 
 CNSsolve>    sani class rdc3 force $Data.rdc3_hot end 
 CNSsolve>    sani class rdc4 force $Data.rdc4_hot end 
 CNSsolve>    sani class rdc5 force $Data.rdc5_hot end 
 CNSsolve>    if ($rantens eq true) then 
 CNSsolve>      @RUN:protocols/mini_tensor.cns 
 ASSFIL: file mini_tensor.cns opened.
 CNSsolve>! mini_tensor.cns 
 CNSsolve>!    Optimize the RDC tensor orientation 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{* Optimize tensor orientation *} 
 CNSsolve> 
 CNSsolve>{* first randomize the tensor orientation because of some CNS problems *} 
 CNSsolve>{* possible resulting in infinite gradient and a failure of the EM     *} 
 CNSsolve> 
 CNSsolve>eval ($erdc = 999999999.0) 
 CNSsolve>eval ($ncount = 0) 
 CNSsolve>while ($ncount < 4) loop trial 
 CNSsolve>  eval ($ncount = $ncount + 1) 
 CNSsolve>  do (xcomp = x) (resn ANI) 
 CNSsolve>  do (ycomp = y) (resn ANI) 
 CNSsolve>  do (zcomp = z) (resn ANI) 
 CNSsolve> 
 CNSsolve>  !random rotation of tensor 
 CNSsolve> 
 CNSsolve>  show aver (x) (resn ANI) 
 CNSsolve>  evaluate ($xc = $result) 
 CNSsolve>  show aver (y) (resn ANI) 
 CNSsolve>  evaluate ($yc = $result) 
 CNSsolve>  show aver (z) (resn ANI) 
 CNSsolve>  evaluate ($zc = $result) 
 CNSsolve> 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  {* rotate around z axis *} 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = -sin($xr)) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = sin($xr)) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = 1 ) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn ANI) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  {* rotate around x axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = 1 ) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = -sin($xr)) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = sin($xr)) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn ANI) 
 CNSsolve>  end 
 CNSsolve>  {* rotate around y axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = -sin($xr)) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = 1 ) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = sin($xr)) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn ANI) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  energy end 
 CNSsolve> 
 CNSsolve>  if ($ncount = 1) then 
 CNSsolve>    eval ($erdc=$sani) 
 CNSsolve>  end if 
 CNSsolve>  if ($sani < $erdc) then 
 CNSsolve>    eval ($erdc=$sani) 
 CNSsolve>    do (xcomp = x) (resn ANI) 
 CNSsolve>    do (ycomp = y) (resn ANI) 
 CNSsolve>    do (zcomp = z) (resn ANI) 
 CNSsolve>  else 
 CNSsolve>    do (x = xcomp) (resn ANI) 
 CNSsolve>    do (y = ycomp) (resn ANI) 
 CNSsolve>    do (z = zcomp) (resn ANI) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>end loop trial 
 CNSsolve> 
 CNSsolve>fix sele=(not all) end 
 CNSsolve>fix sele=(name OO) end 
 CNSsolve>minimize rigid 
 CNSsolve>  group (not resn ANI) 
 CNSsolve>  translation=false 
 CNSsolve>  for $id in id (resn ANI and name OO) loop miniani 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop miniani 
 CNSsolve>  translation=false 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve>minimize rigid 
 CNSsolve>  eval($nchain1= 1) 
 CNSsolve>  while ($nchain1 <= $data.ncomponents) loop cloop1 
 CNSsolve>    group (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    translation=false 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>  end loop cloop1 
 CNSsolve>  for $id in id (resn ANI and name OO) loop miniani 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop miniani 
 CNSsolve>  translation=false 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.flags.xrdc eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    xrdc class rdc1 force $Data.rdc1_hot end 
 CNSsolve>    xrdc class rdc2 force $Data.rdc2_hot end 
 CNSsolve>    xrdc class rdc3 force $Data.rdc3_hot end 
 CNSsolve>    xrdc class rdc4 force $Data.rdc4_hot end 
 CNSsolve>    xrdc class rdc5 force $Data.rdc5_hot end 
 CNSsolve>    if ($rantens_para eq true) then 
 CNSsolve>      @RUN:protocols/mini_tensor_para.cns 
 ASSFIL: file mini_tensor_para.cns opened.
 CNSsolve>! mini_tensor_para.cns 
 CNSsolve>!    Optimize the tensor orientation for PCS restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>!set message on echo on end 
 CNSsolve> 
 CNSsolve>display STARTing mini_tensor_para.cns 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="trial.pdb" end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{* minimize tensor position *} 
 CNSsolve>display STARTing minimization of OO-LA distance 
 CNSsolve> 
 CNSsolve>!flag excl * include noe end 
 CNSsolve>flag excl xpcs include noe end 
 CNSsolve>fix sele=(not resn XAN) end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve>  interaction (not all) (not all) 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>minimize rigid 
 CNSsolve>  group (resname XAN) 
 CNSsolve>  translation=true 
 CNSsolve>  nstep 1000 
 CNSsolve>  tole 0.1 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="position.pdb" end 
 CNSsolve> 
 CNSsolve>display ENDing minimization of OO-LA distance 
 CNSsolve> 
 CNSsolve>display STARTing minimization of orientation 
 CNSsolve> 
 CNSsolve>{* minimize tensor orientation *} 
 CNSsolve> 
 CNSsolve>evaluate ($protocol = 0) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($protocol = 0) then {* powell minimization protocol together *} 
 CNSsolve> 
 CNSsolve>  display protocol 0 
 CNSsolve>!  flag excl * include noe xpcs bond end 
 CNSsolve>  flag  include noe xpcs bond end 
 CNSsolve> 
 CNSsolve>  igroup 
 CNSsolve>    interaction (not all) (not all) 
 CNSsolve>    interaction ( resn XAN ) ( resn XAN ) weight * 0 bond 1.0 end 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  fix sele=(not (resn XAN)) end 
 CNSsolve> 
 CNSsolve>  minimize powell 
 CNSsolve>    nstep=5000 
 CNSsolve>    drop=10 
 CNSsolve>    nprint=10 
 CNSsolve>    tolgradient=0.01 
 CNSsolve>  end 
 CNSsolve>elseif ($protocol = 1) then {* powell minimization protocol *} 
 CNSsolve> 
 CNSsolve>  display protocol 1 
 CNSsolve>  flag excl * include noe xpcs bond end 
 CNSsolve> 
 CNSsolve>  for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>    igroup 
 CNSsolve>      interaction (not all) (not all) 
 CNSsolve>      interaction ( (byres(id $id)) ) ( (byres(id $id)) ) weight * 0 bond 1.0 end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    fix sele=(not ( (byres(id $id)) )) end 
 CNSsolve> 
 CNSsolve>    minimize powell 
 CNSsolve>      nstep=500 
 CNSsolve>      drop=10 
 CNSsolve>      nprint=10 
 CNSsolve>      tolgradient=0.01 
 CNSsolve>    end 
 CNSsolve>  end loop miniani 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 4) then {* powell minimization protocol simultaneously *} 
 CNSsolve> 
 CNSsolve>  display protocol 4 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve> 
 CNSsolve>  fix sele=(not ( resname XAN )) end 
 CNSsolve> 
 CNSsolve>  minimize powell 
 CNSsolve>    nstep=5000 
 CNSsolve>    drop=10 
 CNSsolve>    nprint=10 
 CNSsolve>    tolgradient=0.01 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 2) then  {* rigid body minimization protocol *} 
 CNSsolve> 
 CNSsolve>  display protocol 2 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve>  for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>    minimize rigid 
 CNSsolve>      group (byres(id $id)) 
 CNSsolve>      translation=true 
 CNSsolve>      nstep 500 
 CNSsolve>      nprint 10 
 CNSsolve>      drop=10 
 CNSsolve>    end 
 CNSsolve>  end loop miniani 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 3) then {* original rigid body minimization protocol *} 
 CNSsolve>  display protocol 3 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve>  fix sele=(not resname XAN) end 
 CNSsolve>  minimize rigid 
 CNSsolve>    group (not resname XAN) 
 CNSsolve>    translation=true 
 CNSsolve>    for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>      group (byres(id $id)) 
 CNSsolve>      translation=true 
 CNSsolve>    end loop miniani 
 CNSsolve>    translation=true 
 CNSsolve>    nstep 5000 
 CNSsolve> 
 CNSsolve>    nprint 10 
 CNSsolve>  end 
 CNSsolve>  display XPCS_ENERGY $xpcs 
 CNSsolve>  fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>!xpcs print thresh=0.0 class pcs1 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs2 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs3 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs4 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs5 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs6 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs7 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs8 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs9 end 
 CNSsolve>!xpcs print thresh=0.0 class pcsA end 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="min.pdb" end 
 CNSsolve> 
 CNSsolve>display ENDing minimization of orientation 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.flags.xpcs eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    xpcs class pcs1 force $Data.pcs1_hot end 
 CNSsolve>    xpcs class pcs2 force $Data.pcs2_hot end 
 CNSsolve>    xpcs class pcs3 force $Data.pcs3_hot end 
 CNSsolve>    xpcs class pcs4 force $Data.pcs4_hot end 
 CNSsolve>    xpcs class pcs5 force $Data.pcs5_hot end 
 CNSsolve>    xpcs class pcs6 force $Data.pcs6_hot end 
 CNSsolve>    xpcs class pcs7 force $Data.pcs7_hot end 
 CNSsolve>    xpcs class pcs8 force $Data.pcs8_hot end 
 CNSsolve>    xpcs class pcs9 force $Data.pcs9_hot end 
 CNSsolve>    xpcs class pcsA force $Data.pcsA_hot end 
 CNSsolve>    !if ($rantens_para eq true) then 
 CNSsolve>      @RUN:protocols/mini_tensor_para.cns 
 ASSFIL: file mini_tensor_para.cns opened.
 CNSsolve>! mini_tensor_para.cns 
 CNSsolve>!    Optimize the tensor orientation for PCS restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>!set message on echo on end 
 CNSsolve> 
 CNSsolve>display STARTing mini_tensor_para.cns 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="trial.pdb" end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{* minimize tensor position *} 
 CNSsolve>display STARTing minimization of OO-LA distance 
 CNSsolve> 
 CNSsolve>!flag excl * include noe end 
 CNSsolve>flag excl xpcs include noe end 
 CNSsolve>fix sele=(not resn XAN) end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve>  interaction (not all) (not all) 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>minimize rigid 
 CNSsolve>  group (resname XAN) 
 CNSsolve>  translation=true 
 CNSsolve>  nstep 1000 
 CNSsolve>  tole 0.1 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="position.pdb" end 
 CNSsolve> 
 CNSsolve>display ENDing minimization of OO-LA distance 
 CNSsolve> 
 CNSsolve>display STARTing minimization of orientation 
 CNSsolve> 
 CNSsolve>{* minimize tensor orientation *} 
 CNSsolve> 
 CNSsolve>evaluate ($protocol = 0) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($protocol = 0) then {* powell minimization protocol together *} 
 CNSsolve> 
 CNSsolve>  display protocol 0 
 CNSsolve>!  flag excl * include noe xpcs bond end 
 CNSsolve>  flag  include noe xpcs bond end 
 CNSsolve> 
 CNSsolve>  igroup 
 CNSsolve>    interaction (not all) (not all) 
 CNSsolve>    interaction ( resn XAN ) ( resn XAN ) weight * 0 bond 1.0 end 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  fix sele=(not (resn XAN)) end 
 CNSsolve> 
 CNSsolve>  minimize powell 
 CNSsolve>    nstep=5000 
 CNSsolve>    drop=10 
 CNSsolve>    nprint=10 
 CNSsolve>    tolgradient=0.01 
 CNSsolve>  end 
 CNSsolve>elseif ($protocol = 1) then {* powell minimization protocol *} 
 CNSsolve> 
 CNSsolve>  display protocol 1 
 CNSsolve>  flag excl * include noe xpcs bond end 
 CNSsolve> 
 CNSsolve>  for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>    igroup 
 CNSsolve>      interaction (not all) (not all) 
 CNSsolve>      interaction ( (byres(id $id)) ) ( (byres(id $id)) ) weight * 0 bond 1.0 end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    fix sele=(not ( (byres(id $id)) )) end 
 CNSsolve> 
 CNSsolve>    minimize powell 
 CNSsolve>      nstep=500 
 CNSsolve>      drop=10 
 CNSsolve>      nprint=10 
 CNSsolve>      tolgradient=0.01 
 CNSsolve>    end 
 CNSsolve>  end loop miniani 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 4) then {* powell minimization protocol simultaneously *} 
 CNSsolve> 
 CNSsolve>  display protocol 4 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve> 
 CNSsolve>  fix sele=(not ( resname XAN )) end 
 CNSsolve> 
 CNSsolve>  minimize powell 
 CNSsolve>    nstep=5000 
 CNSsolve>    drop=10 
 CNSsolve>    nprint=10 
 CNSsolve>    tolgradient=0.01 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 2) then  {* rigid body minimization protocol *} 
 CNSsolve> 
 CNSsolve>  display protocol 2 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve>  for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>    minimize rigid 
 CNSsolve>      group (byres(id $id)) 
 CNSsolve>      translation=true 
 CNSsolve>      nstep 500 
 CNSsolve>      nprint 10 
 CNSsolve>      drop=10 
 CNSsolve>    end 
 CNSsolve>  end loop miniani 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 3) then {* original rigid body minimization protocol *} 
 CNSsolve>  display protocol 3 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve>  fix sele=(not resname XAN) end 
 CNSsolve>  minimize rigid 
 CNSsolve>    group (not resname XAN) 
 CNSsolve>    translation=true 
 CNSsolve>    for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>      group (byres(id $id)) 
 CNSsolve>      translation=true 
 CNSsolve>    end loop miniani 
 CNSsolve>    translation=true 
 CNSsolve>    nstep 5000 
 CNSsolve> 
 CNSsolve>    nprint 10 
 CNSsolve>  end 
 CNSsolve>  display XPCS_ENERGY $xpcs 
 CNSsolve>  fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>!xpcs print thresh=0.0 class pcs1 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs2 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs3 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs4 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs5 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs6 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs7 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs8 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs9 end 
 CNSsolve>!xpcs print thresh=0.0 class pcsA end 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="min.pdb" end 
 CNSsolve> 
 CNSsolve>display ENDing minimization of orientation 
 CNSsolve>    !end if 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.flags.dani eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      dani class dan1 force $Data.dan1_hot end 
 CNSsolve>      dani class dan2 force $Data.dan2_hot end 
 CNSsolve>      dani class dan3 force $Data.dan3_hot end 
 CNSsolve>      dani class dan4 force $Data.dan4_hot end 
 CNSsolve>      dani class dan5 force $Data.dan5_hot end 
 CNSsolve>      if ($rantens_dani eq true) then 
 CNSsolve>       @RUN:protocols/mini_tensor_dani.cns 
 ASSFIL: file mini_tensor_dani.cns opened.
 CNSsolve>! mini_tensor_dani.cns 
 CNSsolve>!    Optimize the tensor orientation for diffusion anisotropy restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{* Optimize tensor orientation *} 
 CNSsolve>{* ADJ van Dijk*} 
 CNSsolve>{* copied from mini_tensor.cns *} 
 CNSsolve> 
 CNSsolve>{* first randomize the tensor orientation because of some CNS problems *} 
 CNSsolve>{* possible resulting in infinite gradient and a failure of the EM     *} 
 CNSsolve> 
 CNSsolve>eval ($edani = 999999999.0) 
 CNSsolve>eval ($ncount = 0) 
 CNSsolve>while ($ncount < 4) loop trial 
 CNSsolve>  eval ($ncount = $ncount + 1) 
 CNSsolve>  do (xcomp = x) (resn DAN) 
 CNSsolve>  do (ycomp = y) (resn DAN) 
 CNSsolve>  do (zcomp = z) (resn DAN) 
 CNSsolve> 
 CNSsolve>  !random rotation of tensor 
 CNSsolve> 
 CNSsolve>  show aver (x) (resn DAN) 
 CNSsolve>  evaluate ($xc = $result) 
 CNSsolve>  show aver (y) (resn DAN) 
 CNSsolve>  evaluate ($yc = $result) 
 CNSsolve>  show aver (z) (resn DAN) 
 CNSsolve>  evaluate ($zc = $result) 
 CNSsolve> 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  {* rotate around z axis *} 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = -sin($xr)) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = sin($xr)) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = 1 ) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn DAN) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  {* rotate around x axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = 1 ) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = -sin($xr)) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = sin($xr)) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn DAN) 
 CNSsolve>  end 
 CNSsolve>  {* rotate around y axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = -sin($xr)) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = 1 ) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = sin($xr)) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn DAN) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  energy end 
 CNSsolve> 
 CNSsolve>  if ($ncount = 1) then 
 CNSsolve>    eval ($edani=$dani) 
 CNSsolve>  end if 
 CNSsolve>  if ($dani < $edani) then 
 CNSsolve>    eval ($edani=$dani) 
 CNSsolve>    do (xcomp = x) (resn DAN) 
 CNSsolve>    do (ycomp = y) (resn DAN) 
 CNSsolve>    do (zcomp = z) (resn DAN) 
 CNSsolve>  else 
 CNSsolve>    do (x = xcomp) (resn DAN) 
 CNSsolve>    do (y = ycomp) (resn DAN) 
 CNSsolve>    do (z = zcomp) (resn DAN) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>end loop trial 
 CNSsolve> 
 CNSsolve>fix sele=(not all) end 
 CNSsolve>fix sele=(name OO) end 
 CNSsolve>minimize rigid 
 CNSsolve>  group (not resn DAN) 
 CNSsolve>  translation=false 
 CNSsolve>  for $id in id (resn DAN and name OO) loop minidan 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop minidan 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve>minimize rigid 
 CNSsolve>  eval($nchain1= 1) 
 CNSsolve>  while ($nchain1 <= $data.ncomponents) loop cloop1 
 CNSsolve>    group (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop cloop1 
 CNSsolve>  for $id in id (resn DAN and name OO) loop minidan 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop minidan 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>      end if 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  if ($nlcount = 2) then 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>    flag excl bond angl dihe impr end 
 CNSsolve> 
 CNSsolve>    evaluate ($kinter = $SaProtocol.inter_rigid) 
 CNSsolve>    @RUN:protocols/scale_inter_only.cns 
 ASSFIL: file scale_inter_only.cns opened.
 CNSsolve>! scale_inter_only.cns 
 CNSsolve>!   Scaling of intermolecular interaction (not internal energies) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction ((resn WAT or resn HOH or resn TIP*)) ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 end 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>    eval($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < $data.ncomponents) loop nloop4 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>      eval($nchain2 = $nchain1 ) 
 CNSsolve>      while ($nchain2 < $data.ncomponents) loop nloop3 
 CNSsolve>        eval($nchain2 = $nchain2 + 1) 
 CNSsolve>        @RUN:protocols/rotation180.cns 
 ASSFIL: file rotation180.cns opened.
 CNSsolve>! rotation180.cns 
 CNSsolve>!    Perform a 180 degree rotation around a vector perpendicular to 
 CNSsolve>!    the interface of the complex 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>	eval($distcu = 5.0) 
 CNSsolve>        eval($rotate180 = 180.0) 
 CNSsolve>	eval($xa = 0.0) 
 CNSsolve>	eval($ya = 0.0) 
 CNSsolve>	eval($za = 0.0) 
 CNSsolve>	eval($xb = 0.0) 
 CNSsolve>	eval($zb = 0.0) 
 CNSsolve>	eval($zb = 0.0) 
 CNSsolve> 
 CNSsolve>        show aver (x) (segid $Toppar.prot_segid_$nchain1 and ((segid $Toppar.prot_segid_$nchain2) around $distcu)) 
 CNSsolve>        evaluate ($xa = $result) 
 CNSsolve>        show aver (y) (segid $Toppar.prot_segid_$nchain1 and ((segid $Toppar.prot_segid_$nchain2) around $distcu)) 
 CNSsolve>        evaluate ($ya = $result) 
 CNSsolve>        show aver (z) (segid $Toppar.prot_segid_$nchain1 and ((segid $Toppar.prot_segid_$nchain2) around $distcu)) 
 CNSsolve>        evaluate ($za = $result) 
 CNSsolve>        show aver (x) (segid $Toppar.prot_segid_$nchain2 and ((segid $Toppar.prot_segid_$nchain1) around $distcu)) 
 CNSsolve>        evaluate ($xb = $result) 
 CNSsolve>        show aver (y) (segid $Toppar.prot_segid_$nchain2 and ((segid $Toppar.prot_segid_$nchain1) around $distcu)) 
 CNSsolve>        evaluate ($yb = $result) 
 CNSsolve>        show aver (z) (segid $Toppar.prot_segid_$nchain2 and ((segid $Toppar.prot_segid_$nchain1) around $distcu)) 
 CNSsolve>        evaluate ($zb = $result) 
 CNSsolve>        eval($xdiff=$xa-$xb) 
 CNSsolve>        eval($ydiff=$ya-$yb) 
 CNSsolve>        eval($zdiff=$za-$zb) 
 CNSsolve>	eval($rnorm=$xdiff**2+$ydiff**2+$zdiff**2) 
 CNSsolve> 
 CNSsolve>	if ($rnorm > 0.0) then 
 CNSsolve> 
 CNSsolve>          coor 
 CNSsolve>            rotate sele= (segid $Toppar.prot_segid_$nchain2 or segid $watersegname_$nchain2) 
 CNSsolve>            center=($xa $ya $za) 
 CNSsolve>            axis ($xdiff $ydiff $zdiff) 
 CNSsolve>            $rotate180 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>   	  fix sele=(name OO) end 
 CNSsolve>	 
 CNSsolve>          minimize rigid 
 CNSsolve>            eval ($nch1 = 0) 
 CNSsolve>            while ($nch1 < $data.ncomponents) loop nloop1 
 CNSsolve>	      eval($nch1 = $nch1 + 1) 
 CNSsolve>              group (segid $Toppar.prot_segid_$nch1 or segid $watersegname_$nch1) 
 CNSsolve>              translation=true 
 CNSsolve>            end loop nloop1 
 CNSsolve>            translation=true 
 CNSsolve>            nstep 250 
 CNSsolve>            nprint 10 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          minimize rigid 
 CNSsolve>            eval ($nch1 = 0) 
 CNSsolve>            while ($nch1 < $data.ncomponents) loop nloop1 
 CNSsolve>	      eval($nch1 = $nch1 + 1) 
 CNSsolve>              group (segid $Toppar.prot_segid_$nch1 or segid $watersegname_$nch1) 
 CNSsolve>              translation=true 
 CNSsolve>            end loop nloop1 
 CNSsolve>            translation=true 
 CNSsolve>            nstep 250 
 CNSsolve>            nprint 10 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          energy end 
 CNSsolve> 
 CNSsolve>          if ($anisotropy eq true) then 
 CNSsolve>            fix sele=(not all) end 
 CNSsolve>   	    fix sele=(name OO) end 
 CNSsolve>            minimize rigid 
 CNSsolve>              group (not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>              translation=false 
 CNSsolve>              for $id in id ((resn ANI or resn DAN or resn XAN) and name OO) loop miniani 
 CNSsolve>                group (byres(id $id)) 
 CNSsolve>                translation=false 
 CNSsolve>              end loop miniani 
 CNSsolve>              translation=false 
 CNSsolve>              nstep 100 
 CNSsolve>              drop 10.0 
 CNSsolve>              nprint 10 
 CNSsolve>            end 
 CNSsolve>            minimize rigid 
 CNSsolve>              eval ($nch1 = 0) 
 CNSsolve>              while ($nch1 < $data.ncomponents) loop nloop1 
 CNSsolve>                eval($nch1 = $nch1 + 1) 
 CNSsolve>                group (segid $Toppar.prot_segid_$nch1 or segid $watersegname_$nch1) 
 CNSsolve>                translation=true 
 CNSsolve>              end loop nloop1 
 CNSsolve>              for $id in id ((resn ANI or resn DAN or resn XAN) and name OO) loop miniani 
 CNSsolve>                group (byres(id $id)) 
 CNSsolve>                translation=true 
 CNSsolve>              end loop miniani 
 CNSsolve>              translation=true 
 CNSsolve>              nstep 250 
 CNSsolve>              nprint 10 
 CNSsolve>            end 
 CNSsolve>          end if 
 CNSsolve>	 
 CNSsolve>	end if 
 CNSsolve>      end loop nloop3 
 CNSsolve>    end loop nloop4 
 CNSsolve> 
 CNSsolve>    @@RUN:protocols/flags_new.cns(Iteration=$Iteration; Data=$Data; ) 
 CNSsolve>    if ($Data.flags.elec1 eq true) then 
 CNSsolve>      flag include elec end 
 CNSsolve>    end if 
 CNSsolve>    if ($Data.flags.dihed eq true) then 
 CNSsolve>      flag include dihed end 
 CNSsolve>    end if 
 CNSsolve>    flag include bond angle impr vdw end 
 CNSsolve> 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  igroup 
 IGROup>    interaction  (not (resname ANI or resname DAN or resname XAN)) 
 SELRPN:   3007 atoms have been selected out of   3007
 SELRPN>                 (not (resname ANI or resname DAN or resname XAN)) weight * 1 end 
 SELRPN:   3007 atoms have been selected out of   3007
 IGROup>    interaction  (resname ANI or resname DAN or resname XAN) 
 SELRPN:      0 atoms have been selected out of   3007
 SELRPN>                 (resname ANI or resname DAN or resname XAN) weight * 1 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3007
 IGROup>  end 
 CNSsolve> 
 CNSsolve>  energy end 
 NBONDS: generating intra-molecular exclusion list with mode= 5
 MAKINB: mode   5 found   7535 exclusions and   5314 interactions(1-4)
 NBONDS: found   210476 intra-atom interactions
 --------------- cycle=     3 --------------------------------------------------
 | Etotal =28094.495  grad(E)=132.092    E(BOND)=391.471    E(ANGL)=1444.444   |
 | E(DIHE)=1799.217   E(IMPR)=25142.369  E(VDW )=382.460    E(ELEC)=-1106.544  |
 | E(NOE )=41.078                                                              |
 -------------------------------------------------------------------------------
 CNSsolve>{* 0 ======================================= initial EM for flexible parts only *} 
 CNSsolve> 
 CNSsolve>  if ($Data.flags.rg eq true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    collapse force $Data.krg_hot end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($SaProtocol.rigidtrans eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    @RUN:protocols/flex_segment_back.cns 
 ASSFIL: file flex_segment_back.cns opened.
 CNSsolve>! flex_segment_back.cns 
 CNSsolve>!    Define the semi-flexible segments (both side-chains and backbone) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store5 = 0) (all) 
 CNSsolve>do (store6 = 0) (all) 
 CNSsolve>do (store7 = 0) (all) 
 CNSsolve> 
 CNSsolve>!first flexible segments for docking 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  evaluate($fcounter=0) 
 CNSsolve> 
 CNSsolve>  if ($Toppar.nseg_$nchain1 = 0) then 
 CNSsolve>    display NO FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    if ($Toppar.nseg_$nchain1 < 0) then 
 CNSsolve>      display AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE $nchain1 
 CNSsolve>      inline @RUN:protocols/flexauto-neighbors.cns 
 ASSFIL: file flexauto-neighbors.cns opened.
 CNSsolve>! flexauto-neighbors.cns 
 CNSsolve>!    Automatic definition of flexible segments for docking for contacting residues 
 CNSsolve>!    including neighboring residues of residues making contacts 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($flcut = 5.0) 
 CNSsolve> 
 CNSsolve>do (store5 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve>do (store7 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve> 
 CNSsolve>do (store6 = 0) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = decode($result)) 
 CNSsolve>    evaluate ($preres = $inres) 
 CNSsolve>    evaluate ($nexres = $inres) 
 CNSsolve>    if ($iteration = 1) then 
 CNSsolve>      evaluate ($preres = $preres - 1) 
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>end loop flexres1 
 CNSsolve> 
 CNSsolve>do (store5 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>do (store7 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve> 
 CNSsolve>display THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule $nchain1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = $result) 
 CNSsolve>    show (resn) (id $id) 
 CNSsolve>    evaluate ($nares = $result) 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($seres = $result) 
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
 CNSsolve>end loop flexres2 
 CNSsolve> 
 CNSsolve>    else 
 CNSsolve>      display FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>      while ($fcounter < $Toppar.nseg_$nchain1) loop Xflex 
 CNSsolve>        evaluate($fcounter=$fcounter + 1) 
 CNSsolve>        do (store5 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>        display FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>      end loop Xflex 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>!then fully flexible segments for all stages 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop2 
 CNSsolve> 
 CNSsolve>do (store5 = 7) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = 0) 
 CNSsolve> 
 CNSsolve>! check number of flexible residues per molecule 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop3 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and (attr store5 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numfle=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not (attr store5 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numrig=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numres=$result) 
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 CNSsolve>end loop nloop3 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = $nfletot + $result) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = $nfletot + 10) 
 CNSsolve>    fix sele=((attr store5 = 0 or name OO) and not name H* and not (resn WAT or resn HOH or resn TIP* or resn XAN)) end 
 CNSsolve>    minimize powell nstep=200 drop=10.0 nprint=25 end 
 CNSsolve>    fix sele=(not all) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  energy end 
 --------------- cycle=     4 --------------------------------------------------
 | Etotal =28094.495  grad(E)=132.092    E(BOND)=391.471    E(ANGL)=1444.444   |
 | E(DIHE)=1799.217   E(IMPR)=25142.369  E(VDW )=382.460    E(ELEC)=-1106.544  |
 | E(NOE )=41.078                                                              |
 -------------------------------------------------------------------------------
 CNSsolve> 
 CNSsolve>  do (refx = x) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (refy = y) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (refz = z) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>  do (harm = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (harm = 20) (name OO and not resn XAN) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>  restraints harmonic exponent=2 end 
 CNSsolve>  flag incl harm end 
 CNSsolve> 
 CNSsolve>  ! the following is added to avoid the generation of the torsion angle topology if not needed 
 CNSsolve>  ! in cases where the number of steps is set to 0 (avoid issues with isolated atoms) 
 CNSsolve>  eval ($torsiondone = false) 
 EVALUATE: symbol $TORSIONDONE set to FALSE (logical)
 CNSsolve>  if ($failure eq false) then 
 NEXTCD: condition evaluated as true
 CNSsolve>{* 1 ======================================= rigid body high temperature search*} 
 CNSsolve>{* rigid bodies *} 
 CNSsolve>    if ($SaProtocol.initiosteps > 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      @RUN:protocols/torsiontop.cns 
 ASSFIL: file torsiontop.cns opened.
 CNSsolve>! torsiontop.cns 
 CNSsolve>!   Create the topology for torsion angle MD first stage 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = 150) 
 CNSsolve>!define flexible segments: 
 CNSsolve>display CALLING flex_segment.cns FOR RIGID BODY SA 
 CNSsolve>inline @RUN:protocols/flex_segment.cns 
 ASSFIL: file flex_segment.cns opened.
 CNSsolve>! flex_segment.cns 
 CNSsolve>!    Define fully flexible segments for docking 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store5 = 0) (all) 
 CNSsolve> 
 CNSsolve>display NO FLEXIBLE SEGMENTS for all molecule at this stage 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>do (store5 = 7) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = 0) 
 CNSsolve>! check number of flexible residues per molecule 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and attr store5 = $nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numfle=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not attr store5 = $nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numrig=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numres=$result) 
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 CNSsolve>end loop nloop2 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = $nfletot + $result) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = $nfletot + 10) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($numtrees=$data.ncomponents) 
 CNSsolve>@RUN:protocols/numtrees.cns(numtrees=$numtrees; Data; Toppar;) 
 ASSFIL: file numtrees.cns opened.
 CNSsolve>! numtrees.cns 
 CNSsolve>!    Define the number of trees for torsion angle MD 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module (numtrees; Data; Toppar;) 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = 1) 
 CNSsolve>evaluate ($ncount = 0) 
 CNSsolve>evaluate ($break=$data.ncomponents) 
 CNSsolve> 
 CNSsolve>while ($ncount < $data.ncomponents) loop nsloop 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = $ncount + 1) 
 CNSsolve> 
 CNSsolve>  for $id1 in id ( name C and bondedto(name CA) and segid $Toppar.prot_segid_$ncount) loop break 
 CNSsolve> 
 CNSsolve>     show (resid) (id $id1) 
 CNSsolve>     evaluate ($resid1=$result) 
 CNSsolve> 
 CNSsolve>     evaluate ($resid2=encode(decode($resid1)+1)) 
 CNSsolve> 
 CNSsolve>     show sum(1) (id $id1 and known) 
 CNSsolve>     if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>       identity (store1) ( name N and bondedto(name CA) and segid $Toppar.prot_segid_$ncount and resid $resid2 ) 
 CNSsolve>       show element (store1) (attribute store1 > 0) 
 CNSsolve>       if ( $result ne 0) then 
 CNSsolve>         evaluate ($id2=$result) 
 CNSsolve> 
 CNSsolve>         show sum(1) (id $id2 and known) 
 CNSsolve> 
 CNSsolve>         if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>           pick bond 
 CNSsolve>             (name c and segid $Toppar.prot_segid_$ncount and resid $resid1) 
 CNSsolve>             (name n and segid $Toppar.prot_segid_$ncount and resid $resid2) 
 CNSsolve>             geometry 
 CNSsolve> 
 CNSsolve>           if ( $result > 2.5 ) then 
 CNSsolve>             evaluate ($break=$break+1) 
 CNSsolve>           end if 
 CNSsolve>         else 
 CNSsolve>           evaluate ($break=$break+1) 
 CNSsolve>         end if 
 CNSsolve>       end if 
 CNSsolve>     end if 
 CNSsolve> 
 CNSsolve>   end loop break 
 CNSsolve> 
 CNSsolve>end loop nsloop 
 CNSsolve> 
 CNSsolve>! check for water molecules 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate (&numtrees = $numtrees + $break + $result) 
 CNSsolve> 
 CNSsolve>if ($data.flags.sani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xrdc eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xpcs eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.dani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = $numtrees + 30) 
 CNSsolve> 
 CNSsolve>DISPLAY NUMTREES set to $numtrees 
 CNSsolve> 
 CNSsolve>dyna tors 
 CNSsolve>   topology 
 CNSsolve>      maxtree $numtrees 
 CNSsolve>      kdihmax = 23. 
 CNSsolve> 
 CNSsolve>      evaluate ($N_atom_id = 0) 
 CNSsolve>      evaluate ($atom_id = 0) 
 CNSsolve> 
 CNSsolve>      for $atom_id in id ( name ca ) loop main 
 CNSsolve>         if ( $N_atom_id > 0 ) then 
 CNSsolve>            fix group 
 CNSsolve>            (( byresidue ( id $N_atom_id ) and 
 CNSsolve>                (name C or name O {or name CA} )) 
 CNSsolve>             or ( byresidue ( id $atom_id ) and 
 CNSsolve>                (((name N or name HN {or name CA}) {and not resn pro}) 
 CNSsolve>                {or (( name N or name CD or name CA ) and resn pro)}))) 
 CNSsolve>         end if 
 CNSsolve>         evaluate ($N_atom_id = $atom_id) 
 CNSsolve>      end loop main 
 CNSsolve>      if ( $atom_id > 0 ) then 
 CNSsolve>        fix group 
 CNSsolve>            ( byresidue ( id $atom_id ) 
 CNSsolve>            and (name c or name ot1 or name ot2 {or name CA} )) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      for $atom_id in id 
 FOR-clause=     ( name ca and (resn phe or resn trp or resn his or resn asp or resn asn or resn nep)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                          name %Z* or name %E* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn tyr)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                 name %Z* or name %E* or name OH  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn gln or resn glu)) 
 FOR-clause=      loop main	 
 CNSsolve>            fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                 and ({name CG or} name %D* or name %E*)) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn arg)) 
 FOR-clause=      loop main	 
 CNSsolve>      fix group 
 CNSsolve>        ( byresidue ( id $atom_id ) 
 CNSsolve>          and ({name CD or} name %E* or name %Z* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve>      fix group ( resn PRO and not (name c or name o) ) 
 CNSsolve> 
 CNSsolve>      !next loop is for all sugars defined in glycans-uu.top 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name c1 and (resn GCP or resn GCF or resn GTP or resn GTF or resn MNP 
 FOR-clause=	  or resn MNF or resn ALP or resn ALF or resn ARP or resn ARF or resn GLP 
 FOR-clause=	  or resn GLF or resn IDP or resn IDF or resn TLP or resn TLF or resn PCP 
 FOR-clause=	  or resn PCF or resn FTP or resn FTF or resn SBP or resn SBF or resn TTP 
 FOR-clause=	  or resn TTF or resn NAA or resn RBP or resn RBF or resn ANF or resn XLF 
 FOR-clause=	  or resn LXF or resn RLF or resn LLF)) 
 FOR-clause=      loop main	 
 CNSsolve>      fix group 
 CNSsolve>        ( byresidue ( id $atom_id ) 
 CNSsolve>          and (name %1 or name %2 or name %3 or name %4 or name %5 or name O5)) 
 CNSsolve>      end loop main 
 CNSsolve> 
 CNSsolve>      for $id in id (name C1') loop freeribose 
 CNSsolve>        free bond (id $id) (byresid (id $id) and name C2') 
 CNSsolve>      end loop freeribose 
 CNSsolve> 
 CNSsolve>      fix group ( resn HEC and (name C1* or name C2* or name C3* or name C4* or name N* or name CH*)) 
 CNSsolve> 
 CNSsolve>      fix group ( resn CYM and not (name CA or name C or name O or name OXT or 
 CNSsolve>                  name N or name HN or name HA or name CB or name HB1 or name HB2 or 
 CNSsolve>                  name SG or name SAL or name CAJ)) 
 CNSsolve> 
 CNSsolve>      fix group ( byresidue (resn WAT)) 
 CNSsolve>      fix group ( byresidue (resn HOH)) 
 CNSsolve>      fix group ( byresidue (resn TIP*)) 
 CNSsolve>      fix group ( byresidue (resn ANI)) 
 CNSsolve>      fix group ( byresidue (resn DAN)) 
 CNSsolve>      fix group ( byresidue (resn XAN)) 
 CNSsolve> 
 CNSsolve>     eval($nchain1 = 0) 
 CNSsolve>     while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>       eval($nchain1 = $nchain1 + 1) 
 CNSsolve>       fix group (segid $Toppar.prot_segid_$nchain1 and 
 CNSsolve>                  not (attribute store5 = $nchain1) 
 CNSsolve>		  and not ((resn WAT or resn HOH or resn TIP*))) 
 CNSsolve>     end loop nloop1 
 CNSsolve>   end 
 CNSsolve>end 
 CNSsolve>      eval ($torsiondone = true) 
 CNSsolve>      flags exclude dihed end 
 CNSsolve>      @RUN:protocols/sa_ltad_hightemp.cns(SaProtocol=$SaProtocol;Data=$Data;Toppar=$Toppar) 
 ASSFIL: file sa_ltad_hightemp.cns opened.
 CNSsolve>! sa_ltad_hightemp.cns 
 CNSsolve>!    Perform the high-temperature rigid-body MD of it1 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>! module sa_ltad_hightemp.cns 
 CNSsolve>! torsion dynamics high temperature phase 
 CNSsolve> 
 CNSsolve>module(SaProtocol;Data;Toppar) 
 CNSsolve> 
 CNSsolve>evaluate ($calcsteps= $SaProtocol.initiosteps) 
 CNSsolve>evaluate ($printsteps= max(int($calcsteps/10),1)) 
 CNSsolve> 
 CNSsolve>noe 
 CNSsolve>    rswitch ambi &Data.Rswi_hot 
 CNSsolve>    rswitch dist &Data.Rswi_hot 
 CNSsolve>    rswitch hbon &Data.Rswi_hot 
 CNSsolve> 
 CNSsolve>    mrswitch ambi &Data.mRswi_hot 
 CNSsolve>    mrswitch dist &Data.mRswi_hot 
 CNSsolve>    mrswitch hbon &Data.mRswi_hot 
 CNSsolve> 
 CNSsolve>    asym ambi &Data.asy_hot 
 CNSsolve>    asym dist &Data.asy_hot 
 CNSsolve>    asym hbon &Data.asy_hot 
 CNSsolve> 
 CNSsolve>    masym ambi &Data.masy_hot 
 CNSsolve>    masym dist &Data.masy_hot 
 CNSsolve>    masym hbon &Data.masy_hot 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($bath = &SaPRotocol.tadhigh_t) 
 CNSsolve>evaluate ($timestep = &SaProtocol.timestep*&SaProtocol.tadfactor) 
 CNSsolve> 
 CNSsolve>do (vx = maxwell($bath)) (all) 
 CNSsolve>do (vy = maxwell($bath)) (all) 
 CNSsolve>do (vz = maxwell($bath)) (all) 
 CNSsolve> 
 CNSsolve>!for the vean statement: 
 CNSsolve>evaluate( $k_cen_1 = &data.ini_cen_hot_1) 
 CNSsolve>evaluate( $k_bor_1 = &data.ini_bor_hot_1) 
 CNSsolve>evaluate( $k_cen_2 = &data.ini_cen_hot_2) 
 CNSsolve>evaluate( $k_bor_2 = &data.ini_bor_hot_2) 
 CNSsolve>evaluate( $k_cen_3 = &data.ini_cen_hot_3) 
 CNSsolve>evaluate( $k_bor_3 = &data.ini_bor_hot_3) 
 CNSsolve>evaluate( $k_cen_4 = &data.ini_cen_hot_4) 
 CNSsolve>evaluate( $k_bor_4 = &data.ini_bor_hot_4) 
 CNSsolve>evaluate( $k_cen_5 = &data.ini_cen_hot_5) 
 CNSsolve>evaluate( $k_bor_5 = &data.ini_bor_hot_5) 
 CNSsolve> 
 CNSsolve>restraints dihedral scale &Data.dihedrals_hot end 
 CNSsolve> 
 CNSsolve>couplings class c1 force $Data.c1_hot end 
 CNSsolve>couplings class c2 force $Data.c2_hot end 
 CNSsolve>couplings class c3 force $Data.c3_hot end 
 CNSsolve>couplings class c4 force $Data.c4_hot end 
 CNSsolve>couplings class c5 force $Data.c5_hot end 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sani eq true) then 
 CNSsolve>  sani class rdc1 force $Data.rdc1_hot end 
 CNSsolve>  sani class rdc2 force $Data.rdc2_hot end 
 CNSsolve>  sani class rdc3 force $Data.rdc3_hot end 
 CNSsolve>  sani class rdc4 force $Data.rdc4_hot end 
 CNSsolve>  sani class rdc5 force $Data.rdc5_hot end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.dani eq true) then 
 CNSsolve>  dani class dan1 force $Data.dan1_hot end 
 CNSsolve>  dani class dan2 force $Data.dan2_hot end 
 CNSsolve>  dani class dan3 force $Data.dan3_hot end 
 CNSsolve>  dani class dan4 force $Data.dan4_hot end 
 CNSsolve>  dani class dan5 force $Data.dan5_hot end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.vean eq true) then 
 CNSsolve>  vean class vea1 force $k_bor_1 $k_cen_1 end 
 CNSsolve>  vean class vea2 force $k_bor_2 $k_cen_2 end 
 CNSsolve>  vean class vea3 force $k_bor_3 $k_cen_3 end 
 CNSsolve>  vean class vea4 force $k_bor_4 $k_cen_4 end 
 CNSsolve>  vean class vea5 force $k_bor_5 $k_cen_5 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.xpcs eq true) then 
 CNSsolve>  xpcs class pcs1 force $Data.pcs1_hot end 
 CNSsolve>  xpcs class pcs2 force $Data.pcs2_hot end 
 CNSsolve>  xpcs class pcs3 force $Data.pcs3_hot end 
 CNSsolve>  xpcs class pcs4 force $Data.pcs4_hot end 
 CNSsolve>  xpcs class pcs5 force $Data.pcs5_hot end 
 CNSsolve>  xpcs class pcs6 force $Data.pcs6_hot end 
 CNSsolve>  xpcs class pcs7 force $Data.pcs7_hot end 
 CNSsolve>  xpcs class pcs8 force $Data.pcs8_hot end 
 CNSsolve>  xpcs class pcs9 force $Data.pcs9_hot end 
 CNSsolve>  xpcs class pcsA force $Data.pcsA_hot end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($reassign = TRUE) 
 CNSsolve> 
 CNSsolve>if ($Data.scaling eq TRUE) then 
 CNSsolve>  inline @RUN:protocols/set_noe_scale.cns 
 ASSFIL: file set_noe_scale.cns opened.
 CNSsolve>! set_noe_scale.cns 
 CNSsolve>!    Set the distance restraint force constant 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($enoe   = 0.0 ) 
 CNSsolve>evaluate ($vdw    = 0.0 ) 
 CNSsolve>evaluate ($elec   = 0.0 ) 
 CNSsolve>evaluate ($einter = 0.0 ) 
 CNSsolve>evaluate ($noescale = 1.0 ) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym ne true) then 
 CNSsolve>  print threshold=0.5 noe 
 CNSsolve>  evaluate ($numnoe=$violations) 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_amb > 0) then 
 CNSsolve>    evaluate ($ambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_amb)))) 
 CNSsolve>    if ($ambcorr = 0) then 
 CNSsolve>      evaluate ($ambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($ambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_unamb > 0) then 
 CNSsolve>    evaluate ($unambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_unamb)))) 
 CNSsolve>    if ($unambcorr = 0) then 
 CNSsolve>      evaluate ($unambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($unambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve>else 
 CNSsolve>  evaluate ($unambcorr = 1) 
 CNSsolve>  evaluate ($ambcorr = 1) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>eval ($nchain1 = 0) 
 CNSsolve>igroup 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction  (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                   (segid $Toppar.prot_segid_$nchain2) weights * 1 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>  end loop nloop1 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>energy end 
 CNSsolve>igroup 
 CNSsolve>    interaction  (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($einter = abs($vdw + $elec)) 
 CNSsolve>evaluate ($enoe   = $noe) 
 CNSsolve> 
 CNSsolve>if ($enoe ne 0) then 
 CNSsolve>  evaluate ($noescale = min(5000, (2 * $einter / $enoe))) 
 CNSsolve>  if ($noescale ne 0) then 
 CNSsolve>    evaluate ($Data.unamb_hot   = $Data.unamb_hot   * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_hot     = $Data.amb_hot     * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool1 = $Data.unamb_cool1 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool1   = $Data.amb_cool1   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool2 = $Data.unamb_cool2 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool2   = $Data.amb_cool2   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool3 = $Data.unamb_cool3 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool3   = $Data.amb_cool3   * $noescale * $ambcorr) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>noe 
 CNSsolve>  scale dist  &Data.unamb_hot 
 CNSsolve>  scale ambi  &Data.amb_hot 
 CNSsolve>  scale hbon  &Data.hbond_hot 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($kinter = &SaProtocol.inter_init_rigid) 
 CNSsolve>inline @RUN:protocols/scale_inter.cns 
 ASSFIL: file scale_inter.cns opened.
 CNSsolve>! scale_inter.cns 
 CNSsolve>!    Scaling of intermolecular interactions 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) weight * $Toppar.int_$nchain1_$nchain1 end 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve> 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> 
 CNSsolve>  interaction ((resn WAT or resn HOH or resn TIP*)) ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>dyna tors 
 CNSsolve>  reassign $reassign 
 CNSsolve>  timestep=$timestep 
 CNSsolve>  nstep=$calcsteps 
 CNSsolve>  nprint=$printsteps 
 CNSsolve>  ntrfrq=0 
 CNSsolve>  tcoupling = true  temperature = $bath 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($reassign = FALSE) 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>{* 2 ======================================= rigid body first slow cooling *} 
 CNSsolve>{* rigid bodies only *} 
 CNSsolve> 
 CNSsolve>    if ($Data.flags.rg eq true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      collapse force $Data.krg_cool1 end 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($SaProtocol.cool1_steps > 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      if ($torsiondone ne true) then 
 CNSsolve>        @RUN:protocols/torsiontop.cns 
 ASSFIL: file torsiontop.cns opened.
 CNSsolve>! torsiontop.cns 
 CNSsolve>!   Create the topology for torsion angle MD first stage 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = 150) 
 CNSsolve>!define flexible segments: 
 CNSsolve>display CALLING flex_segment.cns FOR RIGID BODY SA 
 CNSsolve>inline @RUN:protocols/flex_segment.cns 
 ASSFIL: file flex_segment.cns opened.
 CNSsolve>! flex_segment.cns 
 CNSsolve>!    Define fully flexible segments for docking 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store5 = 0) (all) 
 CNSsolve> 
 CNSsolve>display NO FLEXIBLE SEGMENTS for all molecule at this stage 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>do (store5 = 7) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = 0) 
 CNSsolve>! check number of flexible residues per molecule 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and attr store5 = $nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numfle=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not attr store5 = $nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numrig=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numres=$result) 
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 CNSsolve>end loop nloop2 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = $nfletot + $result) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = $nfletot + 10) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($numtrees=$data.ncomponents) 
 CNSsolve>@RUN:protocols/numtrees.cns(numtrees=$numtrees; Data; Toppar;) 
 ASSFIL: file numtrees.cns opened.
 CNSsolve>! numtrees.cns 
 CNSsolve>!    Define the number of trees for torsion angle MD 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module (numtrees; Data; Toppar;) 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = 1) 
 CNSsolve>evaluate ($ncount = 0) 
 CNSsolve>evaluate ($break=$data.ncomponents) 
 CNSsolve> 
 CNSsolve>while ($ncount < $data.ncomponents) loop nsloop 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = $ncount + 1) 
 CNSsolve> 
 CNSsolve>  for $id1 in id ( name C and bondedto(name CA) and segid $Toppar.prot_segid_$ncount) loop break 
 CNSsolve> 
 CNSsolve>     show (resid) (id $id1) 
 CNSsolve>     evaluate ($resid1=$result) 
 CNSsolve> 
 CNSsolve>     evaluate ($resid2=encode(decode($resid1)+1)) 
 CNSsolve> 
 CNSsolve>     show sum(1) (id $id1 and known) 
 CNSsolve>     if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>       identity (store1) ( name N and bondedto(name CA) and segid $Toppar.prot_segid_$ncount and resid $resid2 ) 
 CNSsolve>       show element (store1) (attribute store1 > 0) 
 CNSsolve>       if ( $result ne 0) then 
 CNSsolve>         evaluate ($id2=$result) 
 CNSsolve> 
 CNSsolve>         show sum(1) (id $id2 and known) 
 CNSsolve> 
 CNSsolve>         if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>           pick bond 
 CNSsolve>             (name c and segid $Toppar.prot_segid_$ncount and resid $resid1) 
 CNSsolve>             (name n and segid $Toppar.prot_segid_$ncount and resid $resid2) 
 CNSsolve>             geometry 
 CNSsolve> 
 CNSsolve>           if ( $result > 2.5 ) then 
 CNSsolve>             evaluate ($break=$break+1) 
 CNSsolve>           end if 
 CNSsolve>         else 
 CNSsolve>           evaluate ($break=$break+1) 
 CNSsolve>         end if 
 CNSsolve>       end if 
 CNSsolve>     end if 
 CNSsolve> 
 CNSsolve>   end loop break 
 CNSsolve> 
 CNSsolve>end loop nsloop 
 CNSsolve> 
 CNSsolve>! check for water molecules 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate (&numtrees = $numtrees + $break + $result) 
 CNSsolve> 
 CNSsolve>if ($data.flags.sani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xrdc eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xpcs eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.dani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = $numtrees + 30) 
 CNSsolve> 
 CNSsolve>DISPLAY NUMTREES set to $numtrees 
 CNSsolve> 
 CNSsolve>dyna tors 
 CNSsolve>   topology 
 CNSsolve>      maxtree $numtrees 
 CNSsolve>      kdihmax = 23. 
 CNSsolve> 
 CNSsolve>      evaluate ($N_atom_id = 0) 
 CNSsolve>      evaluate ($atom_id = 0) 
 CNSsolve> 
 CNSsolve>      for $atom_id in id ( name ca ) loop main 
 CNSsolve>         if ( $N_atom_id > 0 ) then 
 CNSsolve>            fix group 
 CNSsolve>            (( byresidue ( id $N_atom_id ) and 
 CNSsolve>                (name C or name O {or name CA} )) 
 CNSsolve>             or ( byresidue ( id $atom_id ) and 
 CNSsolve>                (((name N or name HN {or name CA}) {and not resn pro}) 
 CNSsolve>                {or (( name N or name CD or name CA ) and resn pro)}))) 
 CNSsolve>         end if 
 CNSsolve>         evaluate ($N_atom_id = $atom_id) 
 CNSsolve>      end loop main 
 CNSsolve>      if ( $atom_id > 0 ) then 
 CNSsolve>        fix group 
 CNSsolve>            ( byresidue ( id $atom_id ) 
 CNSsolve>            and (name c or name ot1 or name ot2 {or name CA} )) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      for $atom_id in id 
 FOR-clause=     ( name ca and (resn phe or resn trp or resn his or resn asp or resn asn or resn nep)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                          name %Z* or name %E* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn tyr)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                 name %Z* or name %E* or name OH  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn gln or resn glu)) 
 FOR-clause=      loop main	 
 CNSsolve>            fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                 and ({name CG or} name %D* or name %E*)) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn arg)) 
 FOR-clause=      loop main	 
 CNSsolve>      fix group 
 CNSsolve>        ( byresidue ( id $atom_id ) 
 CNSsolve>          and ({name CD or} name %E* or name %Z* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve>      fix group ( resn PRO and not (name c or name o) ) 
 CNSsolve> 
 CNSsolve>      !next loop is for all sugars defined in glycans-uu.top 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name c1 and (resn GCP or resn GCF or resn GTP or resn GTF or resn MNP 
 FOR-clause=	  or resn MNF or resn ALP or resn ALF or resn ARP or resn ARF or resn GLP 
 FOR-clause=	  or resn GLF or resn IDP or resn IDF or resn TLP or resn TLF or resn PCP 
 FOR-clause=	  or resn PCF or resn FTP or resn FTF or resn SBP or resn SBF or resn TTP 
 FOR-clause=	  or resn TTF or resn NAA or resn RBP or resn RBF or resn ANF or resn XLF 
 FOR-clause=	  or resn LXF or resn RLF or resn LLF)) 
 FOR-clause=      loop main	 
 CNSsolve>      fix group 
 CNSsolve>        ( byresidue ( id $atom_id ) 
 CNSsolve>          and (name %1 or name %2 or name %3 or name %4 or name %5 or name O5)) 
 CNSsolve>      end loop main 
 CNSsolve> 
 CNSsolve>      for $id in id (name C1') loop freeribose 
 CNSsolve>        free bond (id $id) (byresid (id $id) and name C2') 
 CNSsolve>      end loop freeribose 
 CNSsolve> 
 CNSsolve>      fix group ( resn HEC and (name C1* or name C2* or name C3* or name C4* or name N* or name CH*)) 
 CNSsolve> 
 CNSsolve>      fix group ( resn CYM and not (name CA or name C or name O or name OXT or 
 CNSsolve>                  name N or name HN or name HA or name CB or name HB1 or name HB2 or 
 CNSsolve>                  name SG or name SAL or name CAJ)) 
 CNSsolve> 
 CNSsolve>      fix group ( byresidue (resn WAT)) 
 CNSsolve>      fix group ( byresidue (resn HOH)) 
 CNSsolve>      fix group ( byresidue (resn TIP*)) 
 CNSsolve>      fix group ( byresidue (resn ANI)) 
 CNSsolve>      fix group ( byresidue (resn DAN)) 
 CNSsolve>      fix group ( byresidue (resn XAN)) 
 CNSsolve> 
 CNSsolve>     eval($nchain1 = 0) 
 CNSsolve>     while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>       eval($nchain1 = $nchain1 + 1) 
 CNSsolve>       fix group (segid $Toppar.prot_segid_$nchain1 and 
 CNSsolve>                  not (attribute store5 = $nchain1) 
 CNSsolve>		  and not ((resn WAT or resn HOH or resn TIP*))) 
 CNSsolve>     end loop nloop1 
 CNSsolve>   end 
 CNSsolve>end 
 CNSsolve>        eval ($torsiondone = true) 
 CNSsolve>      end if 
 CNSsolve>      evaluate ($SaProtocol.tadfactor = 4) 
 CNSsolve>      @RUN:protocols/sa_ltad_cool1.cns(SaProtocol=$SaProtocol;Data=$Data;Toppar=$Toppar) 
 ASSFIL: file sa_ltad_cool1.cns opened.
 CNSsolve>! sa_ltad_cool1.cns 
 CNSsolve>!    Perform the first simulated annealing stage of it1 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module(SaProtocol;Data;Toppar) 
 CNSsolve> 
 CNSsolve>! module sa_ltad_cool1.cns 
 CNSsolve>! torsion dynamics cooling 
 CNSsolve> 
 CNSsolve>evaluate ($ncycle = 10) 
 CNSsolve> 
 CNSsolve>evaluate ($interstep = (&SaProtocol.inter_fin_rigid - &SaProtocol.inter_init_rigid)/($ncycle-1)) 
 CNSsolve>evaluate ($kinter = &SaProtocol.inter_init_rigid) 
 CNSsolve> 
 CNSsolve>evaluate ($asy_add = (&Data.asy_cool1-&Data.asy_hot)/$ncycle) 
 CNSsolve>evaluate ($masy_add = (&Data.masy_cool1-&Data.masy_hot)/$ncycle) 
 CNSsolve> 
 CNSsolve>evaluate ($asy=&Data.asy_hot) 
 CNSsolve>evaluate ($masy=&Data.masy_hot) 
 CNSsolve>noe 
 CNSsolve>    rswitch ambi &Data.Rswi_hot 
 CNSsolve>    rswitch dist &Data.Rswi_hot 
 CNSsolve>    rswitch hbon &Data.Rswi_hot 
 CNSsolve> 
 CNSsolve>    mrswitch ambi &Data.mRswi_hot 
 CNSsolve>    mrswitch dist &Data.mRswi_hot 
 CNSsolve>    mrswitch hbon &Data.mRswi_hot 
 CNSsolve> 
 CNSsolve>    asym ambi &Data.asy_hot 
 CNSsolve>    asym dist &Data.asy_hot 
 CNSsolve>    asym hbon &Data.asy_hot 
 CNSsolve> 
 CNSsolve>    masym ambi &Data.masy_hot 
 CNSsolve>    masym dist &Data.masy_hot 
 CNSsolve>    masym hbon &Data.masy_hot 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>restraints dihedral   scale=&Data.dihedrals_cool1   end 
 CNSsolve>couplings class c1 force &Data.c1_cool1 end 
 CNSsolve>couplings class c2 force &Data.c2_cool1 end 
 CNSsolve>couplings class c3 force &Data.c3_cool1 end 
 CNSsolve>couplings class c4 force &Data.c4_cool1 end 
 CNSsolve>couplings class c5 force &Data.c5_cool1 end 
 CNSsolve> 
 CNSsolve>evaluate( $k_sani_1  = &Data.rdc1_hot) 
 CNSsolve>if (&Data.rdc1_hot > 0) then 
 CNSsolve>  evaluate( $sani_fac_1 = ( &Data.rdc1_cool1 / &Data.rdc1_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_2  = &Data.rdc2_hot) 
 CNSsolve>if (&Data.rdc2_hot > 0) then 
 CNSsolve>  evaluate( $sani_fac_2 = ( &Data.rdc2_cool1 / &Data.rdc2_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_3  = &Data.rdc3_hot) 
 CNSsolve>if (&Data.rdc3_hot > 0) then 
 CNSsolve>  evaluate( $sani_fac_3 = ( &Data.rdc3_cool1 / &Data.rdc3_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_4  = &Data.rdc4_hot) 
 CNSsolve>if (&Data.rdc4_hot > 0) then 
 CNSsolve>  evaluate( $sani_fac_4 = ( &Data.rdc4_cool1 / &Data.rdc4_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_5  = &Data.rdc5_hot) 
 CNSsolve>if (&Data.rdc5_hot > 0) then 
 CNSsolve>  evaluate( $sani_fac_5 = ( &Data.rdc5_cool1 / &Data.rdc5_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sani eq true) then 
 CNSsolve>  sani class rdc1 force $k_sani_1 end 
 CNSsolve>  sani class rdc2 force $k_sani_2 end 
 CNSsolve>  sani class rdc3 force $k_sani_3 end 
 CNSsolve>  sani class rdc4 force $k_sani_4 end 
 CNSsolve>  sani class rdc5 force $k_sani_5 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate( $k_dani_1  = &Data.dan1_hot) 
 CNSsolve>if (&Data.dan1_hot > 0) then 
 CNSsolve>  evaluate( $dani_fac_1 = ( &Data.dan1_cool1 / &Data.dan1_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_2  = &Data.dan2_hot) 
 CNSsolve>if (&Data.dan2_hot > 0) then 
 CNSsolve>  evaluate( $dani_fac_2 = ( &Data.dan2_cool1 / &Data.dan2_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_3  = &Data.dan3_hot) 
 CNSsolve>if (&Data.dan3_hot > 0) then 
 CNSsolve>  evaluate( $dani_fac_3 = ( &Data.dan3_cool1 / &Data.dan3_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_4  = &Data.dan4_hot) 
 CNSsolve>if (&Data.dan4_hot > 0) then 
 CNSsolve>  evaluate( $dani_fac_4 = ( &Data.dan4_cool1 / &Data.dan4_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_5  = &Data.dan5_hot) 
 CNSsolve>if (&Data.dan5_hot > 0) then 
 CNSsolve>  evaluate( $dani_fac_5 = ( &Data.dan5_cool1 / &Data.dan5_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.dani eq true) then 
 CNSsolve>  dani class dan1 force $k_dani_1 end 
 CNSsolve>  dani class dan2 force $k_dani_2 end 
 CNSsolve>  dani class dan3 force $k_dani_3 end 
 CNSsolve>  dani class dan4 force $k_dani_4 end 
 CNSsolve>  dani class dan5 force $k_dani_5 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate( $k_xpcs_1  = &Data.pcs1_hot) 
 CNSsolve>if (&Data.pcs1_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_1 = ( &Data.pcs1_cool1 / &Data.pcs1_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_2  = &Data.pcs2_hot) 
 CNSsolve>if (&Data.pcs2_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_2 = ( &Data.pcs2_cool1 / &Data.pcs2_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_3  = &Data.pcs3_hot) 
 CNSsolve>if (&Data.pcs3_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_3 = ( &Data.pcs3_cool1 / &Data.pcs3_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_4  = &Data.pcs4_hot) 
 CNSsolve>if (&Data.pcs4_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_4 = ( &Data.pcs4_cool1 / &Data.pcs4_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_5  = &Data.pcs5_hot) 
 CNSsolve>if (&Data.pcs5_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_5 = ( &Data.pcs5_cool1 / &Data.pcs5_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_6  = &Data.pcs6_hot) 
 CNSsolve>if (&Data.pcs6_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_6 = ( &Data.pcs6_cool1 / &Data.pcs6_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_6 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_7  = &Data.pcs7_hot) 
 CNSsolve>if (&Data.pcs7_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_7 = ( &Data.pcs7_cool1 / &Data.pcs7_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_7 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_8  = &Data.pcs8_hot) 
 CNSsolve>if (&Data.pcs8_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_8 = ( &Data.pcs8_cool1 / &Data.pcs8_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_8 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_9  = &Data.pcs9_hot) 
 CNSsolve>if (&Data.pcs9_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_9 = ( &Data.pcs9_cool1 / &Data.pcs9_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_9 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_A  = &Data.pcsA_hot) 
 CNSsolve>if (&Data.pcsA_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_A = ( &Data.pcsA_cool1 / &Data.pcsA_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_A = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($Data.flags.xpcs eq true) then 
 CNSsolve>  xpcs class pcs1 force $k_xpcs_1 end 
 CNSsolve>  xpcs class pcs2 force $k_xpcs_2 end 
 CNSsolve>  xpcs class pcs3 force $k_xpcs_3 end 
 CNSsolve>  xpcs class pcs4 force $k_xpcs_4 end 
 CNSsolve>  xpcs class pcs5 force $k_xpcs_5 end 
 CNSsolve>  xpcs class pcs6 force $k_xpcs_6 end 
 CNSsolve>  xpcs class pcs7 force $k_xpcs_7 end 
 CNSsolve>  xpcs class pcs8 force $k_xpcs_8 end 
 CNSsolve>  xpcs class pcs9 force $k_xpcs_9 end 
 CNSsolve>  xpcs class pcsA force $k_xpcs_A end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($tempstep = (&SaProtocol.t1_init - &SaProtocol.t1_final)/$ncycle) 
 CNSsolve>evaluate ($calcsteps = int(&SaProtocol.cool1_steps/$ncycle)) 
 CNSsolve>evaluate ($printsteps = int($calcsteps / 4)) 
 CNSsolve>evaluate ($timestep = &SaProtocol.timestep*&SaProtocol.tadfactor) 
 CNSsolve> 
 CNSsolve>if (&Data.unamb_hot = 0) then 
 CNSsolve>  evaluate (&Data.unamb_hot = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.unamb_cool1 = 0) then 
 CNSsolve>  evaluate (&Data.unamb_cool1 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.amb_hot = 0)then 
 CNSsolve>  evaluate (&Data.amb_hot = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.amb_cool1 = 0) then 
 CNSsolve>  evaluate (&Data.amb_cool1 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.hbond_hot = 0) then 
 CNSsolve>  evaluate (&Data.hbond_hot = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.hbond_cool1 = 0) then 
 CNSsolve>  evaluate (&Data.hbond_cool1 = 0.000001) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($k_unamb= &Data.unamb_hot) 
 CNSsolve>evaluate ($unamb_fac = (&Data.unamb_cool1/&Data.unamb_hot)^(1/$ncycle)) 
 CNSsolve>evaluate ($k_amb= &Data.amb_hot) 
 CNSsolve>evaluate ($amb_fac = (&Data.amb_cool1/&Data.amb_hot)^(1/$ncycle)) 
 CNSsolve>evaluate ($k_hbond= &Data.hbond_hot) 
 CNSsolve>evaluate ($hbond_fac = (&Data.hbond_cool1/&Data.hbond_hot)^(1/$ncycle)) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!for the vean statement: 
 CNSsolve>evaluate( $k_cen_1 = &Data.ini_cen_cool1_1) 
 CNSsolve>evaluate( $cen_fac_1 = ( &Data.fin_cen_cool1_1 / &Data.ini_cen_cool1_1)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_1 = &Data.ini_bor_cool1_1) 
 CNSsolve>evaluate( $bor_fac_1 = ( &Data.fin_bor_cool1_1 / &Data.ini_bor_cool1_1)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_2 = &Data.ini_cen_cool1_2) 
 CNSsolve>evaluate( $cen_fac_2 = ( &Data.fin_cen_cool1_2 / &Data.ini_cen_cool1_2)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_2 = &Data.ini_bor_cool1_2) 
 CNSsolve>evaluate( $bor_fac_2 = ( &Data.fin_bor_cool1_2 / &Data.ini_bor_cool1_2)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_3 = &Data.ini_cen_cool1_3) 
 CNSsolve>evaluate( $cen_fac_3 = ( &Data.fin_cen_cool1_3 / &Data.ini_cen_cool1_3)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_3 = &Data.ini_bor_cool1_3) 
 CNSsolve>evaluate( $bor_fac_3 = ( &Data.fin_bor_cool1_3 / &Data.ini_bor_cool1_3)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_4 = &Data.ini_cen_cool1_4) 
 CNSsolve>evaluate( $cen_fac_4 = ( &Data.fin_cen_cool1_4 / &Data.ini_cen_cool1_4)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_4 = &Data.ini_bor_cool1_4) 
 CNSsolve>evaluate( $bor_fac_4 = ( &Data.fin_bor_cool1_4 / &Data.ini_bor_cool1_4)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_5 = &Data.ini_cen_cool1_5) 
 CNSsolve>evaluate( $cen_fac_5 = ( &Data.fin_cen_cool1_5 / &Data.ini_cen_cool1_5)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_5 = &Data.ini_bor_cool1_5) 
 CNSsolve>evaluate( $bor_fac_5 = ( &Data.fin_bor_cool1_5 / &Data.ini_bor_cool1_5)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate ($bath  = &SaProtocol.t1_init) 
 CNSsolve>do (vx=maxwell($bath)) ( all ) 
 CNSsolve>do (vy=maxwell($bath)) ( all ) 
 CNSsolve>do (vz=maxwell($bath)) ( all ) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($reassign = TRUE) 
 CNSsolve>evaluate ($i_cool = 0) 
 CNSsolve>while ($i_cool < $ncycle) loop cool 
 CNSsolve> 
 CNSsolve>      evaluate ($i_cool=$i_cool+1) 
 CNSsolve> 
 CNSsolve>      evaluate ($bath  = $bath  - $tempstep) 
 CNSsolve>      evaluate ($k_unamb = $k_unamb*$unamb_fac) 
 CNSsolve>      evaluate ($k_amb = $k_amb*$amb_fac) 
 CNSsolve>      evaluate ($k_hbond = $k_hbond*$hbond_fac) 
 CNSsolve>      evaluate ($asy=$asy+$asy_add) 
 CNSsolve>      evaluate ($masy=$masy+$masy_add) 
 CNSsolve> 
 CNSsolve>      evaluate ($k_bor_1 = $k_bor_1 * $bor_fac_1) 
 CNSsolve>      evaluate ($k_bor_2 = $k_bor_2 * $bor_fac_2) 
 CNSsolve>      evaluate ($k_bor_3 = $k_bor_3 * $bor_fac_3) 
 CNSsolve>      evaluate ($k_bor_4 = $k_bor_4 * $bor_fac_4) 
 CNSsolve>      evaluate ($k_bor_5 = $k_bor_5 * $bor_fac_5) 
 CNSsolve> 
 CNSsolve>      evaluate ($k_cen_1 = $k_cen_1 * $cen_fac_1) 
 CNSsolve>      evaluate ($k_cen_2 = $k_cen_2 * $cen_fac_2) 
 CNSsolve>      evaluate ($k_cen_3 = $k_cen_3 * $cen_fac_3) 
 CNSsolve>      evaluate ($k_cen_4 = $k_cen_4 * $cen_fac_4) 
 CNSsolve>      evaluate ($k_cen_5 = $k_cen_5 * $cen_fac_5) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.vean eq true) then 
 CNSsolve>        vean class vea1 force $k_bor_1 $k_cen_1 end 
 CNSsolve>        vean class vea2 force $k_bor_2 $k_cen_2 end 
 CNSsolve>        vean class vea3 force $k_bor_3 $k_cen_3 end 
 CNSsolve>        vean class vea4 force $k_bor_4 $k_cen_4 end 
 CNSsolve>        vean class vea5 force $k_bor_5 $k_cen_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_sani_1 = $k_sani_1 * $sani_fac_1) 
 CNSsolve>      evaluate ($k_sani_2 = $k_sani_2 * $sani_fac_2) 
 CNSsolve>      evaluate ($k_sani_3 = $k_sani_3 * $sani_fac_3) 
 CNSsolve>      evaluate ($k_sani_4 = $k_sani_4 * $sani_fac_4) 
 CNSsolve>      evaluate ($k_sani_5 = $k_sani_5 * $sani_fac_5) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.sani eq true) then 
 CNSsolve>        sani class rdc1 force $k_sani_1 end 
 CNSsolve>        sani class rdc2 force $k_sani_2 end 
 CNSsolve>        sani class rdc3 force $k_sani_3 end 
 CNSsolve>        sani class rdc4 force $k_sani_4 end 
 CNSsolve>        sani class rdc5 force $k_sani_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_xpcs_1 = $k_xpcs_1 * $xpcs_fac_1) 
 CNSsolve>      evaluate ($k_xpcs_2 = $k_xpcs_2 * $xpcs_fac_2) 
 CNSsolve>      evaluate ($k_xpcs_3 = $k_xpcs_3 * $xpcs_fac_3) 
 CNSsolve>      evaluate ($k_xpcs_4 = $k_xpcs_4 * $xpcs_fac_4) 
 CNSsolve>      evaluate ($k_xpcs_5 = $k_xpcs_5 * $xpcs_fac_5) 
 CNSsolve>      evaluate ($k_xpcs_6 = $k_xpcs_6 * $xpcs_fac_6) 
 CNSsolve>      evaluate ($k_xpcs_7 = $k_xpcs_7 * $xpcs_fac_7) 
 CNSsolve>      evaluate ($k_xpcs_8 = $k_xpcs_8 * $xpcs_fac_8) 
 CNSsolve>      evaluate ($k_xpcs_9 = $k_xpcs_9 * $xpcs_fac_9) 
 CNSsolve>      evaluate ($k_xpcs_A = $k_xpcs_A * $xpcs_fac_A) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.xpcs eq true) then 
 CNSsolve>        xpcs class pcs1 force $k_xpcs_1 end 
 CNSsolve>        xpcs class pcs2 force $k_xpcs_2 end 
 CNSsolve>        xpcs class pcs3 force $k_xpcs_3 end 
 CNSsolve>        xpcs class pcs4 force $k_xpcs_4 end 
 CNSsolve>        xpcs class pcs5 force $k_xpcs_5 end 
 CNSsolve>        xpcs class pcs6 force $k_xpcs_6 end 
 CNSsolve>        xpcs class pcs7 force $k_xpcs_7 end 
 CNSsolve>        xpcs class pcs8 force $k_xpcs_8 end 
 CNSsolve>        xpcs class pcs9 force $k_xpcs_9 end 
 CNSsolve>        xpcs class pcsA force $k_xpcs_A end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_dani_1 = $k_dani_1 * $dani_fac_1) 
 CNSsolve>      evaluate ($k_dani_2 = $k_dani_2 * $dani_fac_2) 
 CNSsolve>      evaluate ($k_dani_3 = $k_dani_3 * $dani_fac_3) 
 CNSsolve>      evaluate ($k_dani_4 = $k_dani_4 * $dani_fac_4) 
 CNSsolve>      evaluate ($k_dani_5 = $k_dani_5 * $dani_fac_5) 
 CNSsolve>      if ($Data.flags.dani eq true) then 
 CNSsolve>        dani class dan1 force $k_dani_1 end 
 CNSsolve>        dani class dan2 force $k_dani_2 end 
 CNSsolve>        dani class dan3 force $k_dani_3 end 
 CNSsolve>        dani class dan4 force $k_dani_4 end 
 CNSsolve>        dani class dan5 force $k_dani_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      if ($Data.scaling eq TRUE) then 
 CNSsolve>        inline @RUN:protocols/set_noe_scale.cns 
 ASSFIL: file set_noe_scale.cns opened.
 CNSsolve>! set_noe_scale.cns 
 CNSsolve>!    Set the distance restraint force constant 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($enoe   = 0.0 ) 
 CNSsolve>evaluate ($vdw    = 0.0 ) 
 CNSsolve>evaluate ($elec   = 0.0 ) 
 CNSsolve>evaluate ($einter = 0.0 ) 
 CNSsolve>evaluate ($noescale = 1.0 ) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym ne true) then 
 CNSsolve>  print threshold=0.5 noe 
 CNSsolve>  evaluate ($numnoe=$violations) 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_amb > 0) then 
 CNSsolve>    evaluate ($ambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_amb)))) 
 CNSsolve>    if ($ambcorr = 0) then 
 CNSsolve>      evaluate ($ambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($ambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_unamb > 0) then 
 CNSsolve>    evaluate ($unambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_unamb)))) 
 CNSsolve>    if ($unambcorr = 0) then 
 CNSsolve>      evaluate ($unambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($unambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve>else 
 CNSsolve>  evaluate ($unambcorr = 1) 
 CNSsolve>  evaluate ($ambcorr = 1) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>eval ($nchain1 = 0) 
 CNSsolve>igroup 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction  (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                   (segid $Toppar.prot_segid_$nchain2) weights * 1 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>  end loop nloop1 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>energy end 
 CNSsolve>igroup 
 CNSsolve>    interaction  (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($einter = abs($vdw + $elec)) 
 CNSsolve>evaluate ($enoe   = $noe) 
 CNSsolve> 
 CNSsolve>if ($enoe ne 0) then 
 CNSsolve>  evaluate ($noescale = min(5000, (2 * $einter / $enoe))) 
 CNSsolve>  if ($noescale ne 0) then 
 CNSsolve>    evaluate ($Data.unamb_hot   = $Data.unamb_hot   * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_hot     = $Data.amb_hot     * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool1 = $Data.unamb_cool1 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool1   = $Data.amb_cool1   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool2 = $Data.unamb_cool2 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool2   = $Data.amb_cool2   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool3 = $Data.unamb_cool3 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool3   = $Data.amb_cool3   * $noescale * $ambcorr) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>        noe 
 CNSsolve>           scale dist $Data.unamb_cool1 
 CNSsolve>           scale ambi $Data.amb_cool1 
 CNSsolve>           scale hbon $Data.hbond_cool1 
 CNSsolve>           asym ambi $asy 
 CNSsolve>           asym dist $asy 
 CNSsolve>           asym hbon $asy 
 CNSsolve>           masym ambi $masy 
 CNSsolve>           masym dist $masy 
 CNSsolve>           masym hbon $masy 
 CNSsolve>        end 
 CNSsolve>      else 
 CNSsolve>        noe 
 CNSsolve>           scale dist $k_unamb 
 CNSsolve>           scale ambi $k_amb 
 CNSsolve>           scale hbon $k_hbond 
 CNSsolve>           asym ambi $asy 
 CNSsolve>           asym dist $asy 
 CNSsolve>           asym hbon $asy 
 CNSsolve>           masym ambi $masy 
 CNSsolve>           masym dist $masy 
 CNSsolve>           masym hbon $masy 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      !scale intermolecular interactions 
 CNSsolve>      inline @RUN:protocols/scale_inter.cns 
 ASSFIL: file scale_inter.cns opened.
 CNSsolve>! scale_inter.cns 
 CNSsolve>!    Scaling of intermolecular interactions 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) weight * $Toppar.int_$nchain1_$nchain1 end 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve> 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> 
 CNSsolve>  interaction ((resn WAT or resn HOH or resn TIP*)) ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve>      evaluate ($kinter = $kinter + $interstep) 
 CNSsolve> 
 CNSsolve>      dyna tors 
 CNSsolve>         reassign $reassign 
 CNSsolve>         timestep=$timestep 
 CNSsolve>         nstep=$calcsteps 
 CNSsolve>         nprint=$printsteps 
 CNSsolve>         ntrfrq=0 
 CNSsolve>         tcoupling = true  temperature = $bath 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      energy end 
 CNSsolve>      if ($ener > 99999999) then 
 CNSsolve>        display ENERGY PROBLEM, THE SYSTEM IS BLOWING UP: ==> STOPPING 
 CNSsolve>	stop 
 CNSsolve>      end if 
 CNSsolve>      evaluate ($reassign = FALSE) 
 CNSsolve>end loop cool 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>{* 3 ======================================= second slow cooling *} 
 CNSsolve>{* flexible side-chains and reduced time step *} 
 CNSsolve> 
 CNSsolve>    if ($Data.flags.rg eq true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      collapse force $Data.krg_cool2 end 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($Data.flags.dihed eq true) then flags include dihed end end if 
 NEXTCD: condition evaluated as true
 CNSsolve> 
 CNSsolve>    if ($SaProtocol.cool2_steps > 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      if ($torsiondone eq true) then 
 CNSsolve>        dyna tors topo reset end end 
 CNSsolve>      end if 
 CNSsolve>      @RUN:protocols/torsiontop_flex.cns 
 ASSFIL: file torsiontop_flex.cns opened.
 CNSsolve>! torsiontop_flex.cns 
 CNSsolve>!    Set the topology for torsion angle MD with semi-flexible side-chains 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($nfletot = 150) 
 CNSsolve>!define flexible segments: 
 CNSsolve>display CALLING flex_segment_side.cns FOR SEMI-FLEXIBLE SA WITH SIDE-CHAINS 
 CNSsolve>inline @RUN:protocols/flex_segment_side.cns 
 ASSFIL: file flex_segment_side.cns opened.
 CNSsolve>! flex_segment_side.cns 
 CNSsolve>!     Define semi-flexible segments (side-chains only) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store5 = 0) (all) 
 CNSsolve>do (store6 = 0) (all) 
 CNSsolve>do (store7 = 0) (all) 
 CNSsolve> 
 CNSsolve>!first flexible segments for docking 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  evaluate($fcounter=0) 
 CNSsolve>  if ($Toppar.nseg_$nchain1 = 0) then 
 CNSsolve>    display NO FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    if ($Toppar.nseg_$nchain1 < 0) then 
 CNSsolve>      display AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE $nchain1 
 CNSsolve>      inline @RUN:protocols/flexauto-neighbors.cns 
 ASSFIL: file flexauto-neighbors.cns opened.
 CNSsolve>! flexauto-neighbors.cns 
 CNSsolve>!    Automatic definition of flexible segments for docking for contacting residues 
 CNSsolve>!    including neighboring residues of residues making contacts 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($flcut = 5.0) 
 CNSsolve> 
 CNSsolve>do (store5 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve>do (store7 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve> 
 CNSsolve>do (store6 = 0) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = decode($result)) 
 CNSsolve>    evaluate ($preres = $inres) 
 CNSsolve>    evaluate ($nexres = $inres) 
 CNSsolve>    if ($iteration = 1) then 
 CNSsolve>      evaluate ($preres = $preres - 1) 
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>end loop flexres1 
 CNSsolve> 
 CNSsolve>do (store5 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>do (store7 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve> 
 CNSsolve>display THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule $nchain1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = $result) 
 CNSsolve>    show (resn) (id $id) 
 CNSsolve>    evaluate ($nares = $result) 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($seres = $result) 
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
 CNSsolve>end loop flexres2 
 CNSsolve> 
 CNSsolve>      do (store5 = 0) (name CA or name C or name N or name O) 
 CNSsolve>    else 
 CNSsolve>      display FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>      while ($fcounter < $Toppar.nseg_$nchain1) loop Xflex 
 CNSsolve>        evaluate($fcounter=$fcounter + 1) 
 CNSsolve>        do (store5 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                                 and not(name CA or name C or name N or name O) ) 
 CNSsolve>        do (store7 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>        display FLEXIBLE SIDE-CHAINS SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>      end loop Xflex 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>!then fully flexible segments for all stages 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>      do (store7 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop2 
 CNSsolve> 
 CNSsolve>do (store5 = 7) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = 0) 
 CNSsolve>! check number of flexible residues per molecule 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop3 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and (attr store7 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numfle=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not (attr store7 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numrig=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numres=$result) 
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 CNSsolve>end loop nloop3 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = $nfletot + $result) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = $nfletot + 10) 
 CNSsolve> 
 CNSsolve>evaluate ($numtrees=$data.ncomponents) 
 CNSsolve>@RUN:protocols/numtrees.cns(numtrees=$numtrees; Data; Toppar;) 
 ASSFIL: file numtrees.cns opened.
 CNSsolve>! numtrees.cns 
 CNSsolve>!    Define the number of trees for torsion angle MD 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module (numtrees; Data; Toppar;) 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = 1) 
 CNSsolve>evaluate ($ncount = 0) 
 CNSsolve>evaluate ($break=$data.ncomponents) 
 CNSsolve> 
 CNSsolve>while ($ncount < $data.ncomponents) loop nsloop 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = $ncount + 1) 
 CNSsolve> 
 CNSsolve>  for $id1 in id ( name C and bondedto(name CA) and segid $Toppar.prot_segid_$ncount) loop break 
 CNSsolve> 
 CNSsolve>     show (resid) (id $id1) 
 CNSsolve>     evaluate ($resid1=$result) 
 CNSsolve> 
 CNSsolve>     evaluate ($resid2=encode(decode($resid1)+1)) 
 CNSsolve> 
 CNSsolve>     show sum(1) (id $id1 and known) 
 CNSsolve>     if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>       identity (store1) ( name N and bondedto(name CA) and segid $Toppar.prot_segid_$ncount and resid $resid2 ) 
 CNSsolve>       show element (store1) (attribute store1 > 0) 
 CNSsolve>       if ( $result ne 0) then 
 CNSsolve>         evaluate ($id2=$result) 
 CNSsolve> 
 CNSsolve>         show sum(1) (id $id2 and known) 
 CNSsolve> 
 CNSsolve>         if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>           pick bond 
 CNSsolve>             (name c and segid $Toppar.prot_segid_$ncount and resid $resid1) 
 CNSsolve>             (name n and segid $Toppar.prot_segid_$ncount and resid $resid2) 
 CNSsolve>             geometry 
 CNSsolve> 
 CNSsolve>           if ( $result > 2.5 ) then 
 CNSsolve>             evaluate ($break=$break+1) 
 CNSsolve>           end if 
 CNSsolve>         else 
 CNSsolve>           evaluate ($break=$break+1) 
 CNSsolve>         end if 
 CNSsolve>       end if 
 CNSsolve>     end if 
 CNSsolve> 
 CNSsolve>   end loop break 
 CNSsolve> 
 CNSsolve>end loop nsloop 
 CNSsolve> 
 CNSsolve>! check for water molecules 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate (&numtrees = $numtrees + $break + $result) 
 CNSsolve> 
 CNSsolve>if ($data.flags.sani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xrdc eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xpcs eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.dani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = $numtrees + 30) 
 CNSsolve> 
 CNSsolve>DISPLAY NUMTREES set to $numtrees 
 CNSsolve> 
 CNSsolve>dyna tors 
 CNSsolve>   topology 
 CNSsolve>      maxtree $numtrees 
 CNSsolve>      kdihmax = 23. 
 CNSsolve>      evaluate ($N_atom_id = 0) 
 CNSsolve>      evaluate ($atom_id = 0) 
 CNSsolve> 
 CNSsolve>      for $atom_id in id ( name ca ) loop main 
 CNSsolve>         if ( $N_atom_id > 0 ) then 
 CNSsolve>            fix group 
 CNSsolve>            (( byresidue ( id $N_atom_id ) and 
 CNSsolve>                (name C or name O {or name CA} )) 
 CNSsolve>             or ( byresidue ( id $atom_id ) and 
 CNSsolve>                (((name N or name HN {or name CA}) {and not resn pro}) 
 CNSsolve>                {or (( name N or name CD or name CA ) and resn pro)}))) 
 CNSsolve>         end if 
 CNSsolve>         evaluate ($N_atom_id = $atom_id) 
 CNSsolve>      end loop main 
 CNSsolve>      if ( $atom_id > 0 ) then 
 CNSsolve>        fix group 
 CNSsolve>         ( byresidue ( id $atom_id ) 
 CNSsolve>            and (name c or name ot1 or name ot2 {or name CA} )) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      for $atom_id in id 
 FOR-clause=     ( name ca and (resn phe or resn trp or resn his or resn asp or resn asn or resn nep)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                          name %Z* or name %E* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn tyr)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                 name %Z* or name %E* or name OH  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn gln or resn glu)) 
 FOR-clause=      loop main	 
 CNSsolve>            fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                 and ({name CG or} name %D* or name %E*)) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn arg)) 
 FOR-clause=      loop main	 
 CNSsolve>        fix group 
 CNSsolve>          ( byresidue ( id $atom_id ) 
 CNSsolve>          and ({name CD or} name %E* or name %Z* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve>      fix group ( resn PRO and not (name c or name o) ) 
 CNSsolve> 
 CNSsolve>      !next loop is for all sugars defined in glycans-uu.top 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name c1 and (resn GCP or resn GCF or resn GTP or resn GTF or resn MNP 
 FOR-clause=	  or resn MNF or resn ALP or resn ALF or resn ARP or resn ARF or resn GLP 
 FOR-clause=	  or resn GLF or resn IDP or resn IDF or resn TLP or resn TLF or resn PCP 
 FOR-clause=	  or resn PCF or resn FTP or resn FTF or resn SBP or resn SBF or resn TTP 
 FOR-clause=	  or resn TTF or resn NAA or resn RBP or resn RBF or resn ANF or resn XLF 
 FOR-clause=	  or resn LXF or resn RLF or resn LLF)) 
 FOR-clause=      loop main	 
 CNSsolve>        fix group 
 CNSsolve>          ( byresidue ( id $atom_id ) 
 CNSsolve>          and (name %1 or name %2 or name %3 or name %4 or name %5 or name O5)) 
 CNSsolve>      end loop main 
 CNSsolve> 
 CNSsolve>      for $id in id (name C1') loop freeribose 
 CNSsolve>        free bond (id $id) (byresid (id $id) and name C2') 
 CNSsolve>      end loop freeribose 
 CNSsolve> 
 CNSsolve>      fix group ( resn HEC and (name C1* or name C2* or name C3* or name C4* or name N* or name CH*)) 
 CNSsolve> 
 CNSsolve>      fix group ( resn CYM and not (name CA or name C or name O or name OXT or 
 CNSsolve>                  name N or name HN or name HA or name CB or name HB1 or name HB2 or 
 CNSsolve>                  name SG or name SAL or name CAJ)) 
 CNSsolve> 
 CNSsolve>      fix group ( byresidue (resn WAT)) 
 CNSsolve>      fix group ( byresidue (resn HOH)) 
 CNSsolve>      fix group ( byresidue (resn TIP*)) 
 CNSsolve>      fix group ( byresidue (resn ANI)) 
 CNSsolve>      fix group ( byresidue (resn DAN)) 
 CNSsolve>      fix group ( byresidue (resn XAN)) 
 CNSsolve> 
 CNSsolve>      eval($nchain1=0) 
 CNSsolve>      while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>        eval($nchain1 = $nchain1 + 1) 
 CNSsolve>        fix group (segid $Toppar.prot_segid_$nchain1 and 
 CNSsolve>                   not (attribute store5 = $nchain1) 
 CNSsolve>		   and not ((resn WAT or resn HOH or resn TIP*))) 
 CNSsolve>      end loop nloop1 
 CNSsolve>   end 
 CNSsolve>end 
 CNSsolve>      eval ($torsiondone = true) 
 CNSsolve>      evaluate ($SaProtocol.tadfactor = 1) 
 CNSsolve>      @RUN:protocols/sa_ltad_cool2.cns(SaProtocol=$SaProtocol;Data=$Data;Toppar=$Toppar) 
 ASSFIL: file sa_ltad_cool2.cns opened.
 CNSsolve>! sa_ltad_cool2.cns 
 CNSsolve>!   Perform the second simulation annealing stage of it1 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module(SaProtocol;Data;Toppar) 
 CNSsolve> 
 CNSsolve>! module sa_ltad_cool2.cns 
 CNSsolve>! torsion dynamics cooling 
 CNSsolve> 
 CNSsolve>evaluate ($ncycle = 10) 
 CNSsolve> 
 CNSsolve>evaluate ($asy_add = (&Data.asy_cool2-&Data.asy_cool1)/$ncycle) 
 CNSsolve>evaluate ($masy_add = (&Data.masy_cool2-&Data.masy_cool1)/$ncycle) 
 CNSsolve> 
 CNSsolve>evaluate ($asy=&Data.asy_cool1) 
 CNSsolve>evaluate ($masy=&Data.masy_cool1) 
 CNSsolve> 
 CNSsolve>noe 
 CNSsolve>    rswitch ambi &Data.Rswi_cool1 
 CNSsolve>    rswitch dist &Data.Rswi_cool1 
 CNSsolve>    rswitch hbon &Data.Rswi_cool1 
 CNSsolve> 
 CNSsolve>    mrswitch ambi &Data.mRswi_cool1 
 CNSsolve>    mrswitch dist &Data.mRswi_cool1 
 CNSsolve>    mrswitch hbon &Data.mRswi_cool1 
 CNSsolve> 
 CNSsolve>    asym ambi &Data.asy_cool1 
 CNSsolve>    asym dist &Data.asy_cool1 
 CNSsolve>    asym hbon &Data.asy_cool1 
 CNSsolve> 
 CNSsolve>    masym ambi &Data.masy_cool1 
 CNSsolve>    masym dist &Data.masy_cool1 
 CNSsolve>    masym hbon &Data.masy_cool1 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>restraints dihedral   scale=&Data.dihedrals_cool2   end 
 CNSsolve>couplings class c1 force &Data.c1_cool2 end 
 CNSsolve>couplings class c2 force &Data.c2_cool2 end 
 CNSsolve>couplings class c3 force &Data.c3_cool2 end 
 CNSsolve>couplings class c4 force &Data.c4_cool2 end 
 CNSsolve>couplings class c5 force &Data.c5_cool2 end 
 CNSsolve> 
 CNSsolve>evaluate( $k_sani_1  = &Data.rdc1_cool1) 
 CNSsolve>if (&Data.rdc1_cool1 > 0) then 
 CNSsolve>  evaluate( $sani_fac_1 = ( &Data.rdc1_cool2 / &Data.rdc1_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_2  = &Data.rdc2_cool1) 
 CNSsolve>if (&Data.rdc2_cool1 > 0) then 
 CNSsolve>  evaluate( $sani_fac_2 = ( &Data.rdc2_cool2 / &Data.rdc2_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_3  = &Data.rdc3_cool1) 
 CNSsolve>if (&Data.rdc3_cool1 > 0) then 
 CNSsolve>  evaluate( $sani_fac_3 = ( &Data.rdc3_cool2 / &Data.rdc3_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_4  = &Data.rdc4_cool1) 
 CNSsolve>if (&Data.rdc4_cool1 > 0) then 
 CNSsolve>  evaluate( $sani_fac_4 = ( &Data.rdc4_cool2 / &Data.rdc4_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_5  = &Data.rdc5_cool1) 
 CNSsolve>if (&Data.rdc5_cool1 > 0) then 
 CNSsolve>  evaluate( $sani_fac_5 = ( &Data.rdc5_cool2 / &Data.rdc5_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sani eq true) then 
 CNSsolve>  sani class rdc1 force $k_sani_1 end 
 CNSsolve>  sani class rdc2 force $k_sani_2 end 
 CNSsolve>  sani class rdc3 force $k_sani_3 end 
 CNSsolve>  sani class rdc4 force $k_sani_4 end 
 CNSsolve>  sani class rdc5 force $k_sani_5 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate( $k_dani_1  = &Data.dan1_cool1) 
 CNSsolve>if (&Data.dan1_cool1 > 0) then 
 CNSsolve>  evaluate( $dani_fac_1 = ( &Data.dan1_cool2 / &Data.dan1_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_2  = &Data.dan2_cool1) 
 CNSsolve>if (&Data.dan2_cool1 > 0) then 
 CNSsolve>  evaluate( $dani_fac_2 = ( &Data.dan2_cool2 / &Data.dan2_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_3  = &Data.dan3_cool1) 
 CNSsolve>if (&Data.dan3_cool1 > 0) then 
 CNSsolve>  evaluate( $dani_fac_3 = ( &Data.dan3_cool2 / &Data.dan3_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_4  = &Data.dan4_cool1) 
 CNSsolve>if (&Data.dan4_cool1 > 0) then 
 CNSsolve>  evaluate( $dani_fac_4 = ( &Data.dan4_cool2 / &Data.dan4_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_5  = &Data.dan5_cool1) 
 CNSsolve>if (&Data.dan5_cool1 > 0) then 
 CNSsolve>  evaluate( $dani_fac_5 = ( &Data.dan5_cool2 / &Data.dan5_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.dani eq true) then 
 CNSsolve>  dani class dan1 force $k_dani_1 end 
 CNSsolve>  dani class dan2 force $k_dani_2 end 
 CNSsolve>  dani class dan3 force $k_dani_3 end 
 CNSsolve>  dani class dan4 force $k_dani_4 end 
 CNSsolve>  dani class dan5 force $k_dani_5 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate( $k_xpcs_1  = &Data.pcs1_cool1) 
 CNSsolve>if (&Data.pcs1_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_1 = ( &Data.pcs1_cool2 / &Data.pcs1_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_2  = &Data.pcs2_cool1) 
 CNSsolve>if (&Data.pcs2_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_2 = ( &Data.pcs2_cool2 / &Data.pcs2_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_3  = &Data.pcs3_cool1) 
 CNSsolve>if (&Data.pcs3_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_3 = ( &Data.pcs3_cool2 / &Data.pcs3_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_4  = &Data.pcs4_cool1) 
 CNSsolve>if (&Data.pcs4_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_4 = ( &Data.pcs4_cool2 / &Data.pcs4_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_5  = &Data.pcs5_cool1) 
 CNSsolve>if (&Data.pcs5_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_5 = ( &Data.pcs5_cool2 / &Data.pcs5_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_6  = &Data.pcs6_cool1) 
 CNSsolve>if (&Data.pcs6_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_6 = ( &Data.pcs6_cool2 / &Data.pcs6_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_6 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_7  = &Data.pcs7_cool1) 
 CNSsolve>if (&Data.pcs7_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_7 = ( &Data.pcs7_cool2 / &Data.pcs7_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_7 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_8  = &Data.pcs8_cool1) 
 CNSsolve>if (&Data.pcs8_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_8 = ( &Data.pcs8_cool2 / &Data.pcs8_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_8 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_9  = &Data.pcs9_cool1) 
 CNSsolve>if (&Data.pcs9_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_9 = ( &Data.pcs9_cool2 / &Data.pcs9_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_9 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_A  = &Data.pcsA_cool1) 
 CNSsolve>if (&Data.pcsA_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_A = ( &Data.pcsA_cool2 / &Data.pcsA_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_A = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($Data.flags.xpcs eq true) then 
 CNSsolve>  xpcs class pcs1 force $k_xpcs_1 end 
 CNSsolve>  xpcs class pcs2 force $k_xpcs_2 end 
 CNSsolve>  xpcs class pcs3 force $k_xpcs_3 end 
 CNSsolve>  xpcs class pcs4 force $k_xpcs_4 end 
 CNSsolve>  xpcs class pcs5 force $k_xpcs_5 end 
 CNSsolve>  xpcs class pcs6 force $k_xpcs_6 end 
 CNSsolve>  xpcs class pcs7 force $k_xpcs_7 end 
 CNSsolve>  xpcs class pcs8 force $k_xpcs_8 end 
 CNSsolve>  xpcs class pcs9 force $k_xpcs_9 end 
 CNSsolve>  xpcs class pcsA force $k_xpcs_A end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($interstep = (&SaProtocol.inter_fin_cool2 - &SaProtocol.inter_init_cool2)/($ncycle-1)) 
 CNSsolve>evaluate ($kinter = &SaProtocol.inter_init_cool2) 
 CNSsolve> 
 CNSsolve>evaluate ($tempstep = (&SaProtocol.t2_init - &SaProtocol.t2_final)/$ncycle) 
 CNSsolve>evaluate ($calcsteps = int(&SaProtocol.cool2_steps/$ncycle)) 
 CNSsolve>evaluate ($printsteps = int($calcsteps / 4)) 
 CNSsolve>evaluate ($timestep = &SaProtocol.timestep*&SaProtocol.tadfactor) 
 CNSsolve> 
 CNSsolve>if (&Data.unamb_cool1 = 0) then 
 CNSsolve>  evaluate (&Data.unamb_cool1 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.unamb_cool2 = 0) then 
 CNSsolve>  evaluate (&Data.unamb_cool2 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.amb_cool1 = 0) then 
 CNSsolve>  evaluate (&Data.amb_cool1 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.amb_cool2 = 0) then 
 CNSsolve>  evaluate (&Data.amb_cool2 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.hbond_cool1 = 0) then 
 CNSsolve>  evaluate (&Data.hbond_cool1 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.hbond_cool2 = 0) then 
 CNSsolve>  evaluate (&Data.hbond_cool2 = 0.000001) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($k_unamb= &Data.unamb_cool1) 
 CNSsolve>evaluate ($unamb_fac = (&Data.unamb_cool2/&Data.unamb_cool1)^(1/$ncycle)) 
 CNSsolve>evaluate ($k_amb= &Data.amb_cool1) 
 CNSsolve>evaluate ($amb_fac = (&Data.amb_cool2/&Data.amb_cool1)^(1/$ncycle)) 
 CNSsolve>evaluate ($k_hbond= &Data.hbond_cool1) 
 CNSsolve>evaluate ($hbond_fac = (&Data.hbond_cool2/&Data.hbond_cool1)^(1/$ncycle)) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!for the vean statement: 
 CNSsolve>evaluate( $k_cen_1 = &Data.ini_cen_cool2_1) 
 CNSsolve>evaluate( $cen_fac_1 = ( &Data.fin_cen_cool2_1 / &Data.ini_cen_cool2_1)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_1 = &Data.ini_bor_cool2_1) 
 CNSsolve>evaluate( $bor_fac_1 = ( &Data.fin_bor_cool2_1 / &Data.ini_bor_cool2_1)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_2 = &Data.ini_cen_cool2_2) 
 CNSsolve>evaluate( $cen_fac_2 = ( &Data.fin_cen_cool2_2 / &Data.ini_cen_cool2_2)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_2 = &Data.ini_bor_cool2_2) 
 CNSsolve>evaluate( $bor_fac_2 = ( &Data.fin_bor_cool2_2 / &Data.ini_bor_cool2_2)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_3 = &Data.ini_cen_cool2_3) 
 CNSsolve>evaluate( $cen_fac_3 = ( &Data.fin_cen_cool2_3 / &Data.ini_cen_cool2_3)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_3 = &Data.ini_bor_cool2_3) 
 CNSsolve>evaluate( $bor_fac_3 = ( &Data.fin_bor_cool2_3 / &Data.ini_bor_cool2_3)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_4 = &Data.ini_cen_cool2_4) 
 CNSsolve>evaluate( $cen_fac_4 = ( &Data.fin_cen_cool2_4 / &Data.ini_cen_cool2_4)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_4 = &Data.ini_bor_cool2_4) 
 CNSsolve>evaluate( $bor_fac_4 = ( &Data.fin_bor_cool2_4 / &Data.ini_bor_cool2_4)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_5 = &Data.ini_cen_cool2_5) 
 CNSsolve>evaluate( $cen_fac_5 = ( &Data.fin_cen_cool2_5 / &Data.ini_cen_cool2_5)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_5 = &Data.ini_bor_cool2_5) 
 CNSsolve>evaluate( $bor_fac_5 = ( &Data.fin_bor_cool2_5 / &Data.ini_bor_cool2_5)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate ($bath  = &SaProtocol.t2_init) 
 CNSsolve>do (vx=maxwell($bath)) ( all ) 
 CNSsolve>do (vy=maxwell($bath)) ( all ) 
 CNSsolve>do (vz=maxwell($bath)) ( all ) 
 CNSsolve> 
 CNSsolve>evaluate ($reassign = TRUE) 
 CNSsolve>evaluate ($i_cool = 0) 
 CNSsolve>while ($i_cool < $ncycle) loop cool 
 CNSsolve> 
 CNSsolve>      evaluate ($i_cool=$i_cool+1) 
 CNSsolve> 
 CNSsolve>      evaluate ($bath  = $bath  - $tempstep) 
 CNSsolve>      evaluate ($k_unamb = $k_unamb*$unamb_fac) 
 CNSsolve>      evaluate ($k_amb = $k_amb*$amb_fac) 
 CNSsolve>      evaluate ($k_hbond = $k_hbond*$hbond_fac) 
 CNSsolve>      evaluate ($asy=$asy+$asy_add) 
 CNSsolve>      evaluate ($masy=$masy+$masy_add) 
 CNSsolve> 
 CNSsolve>      evaluate ($k_bor_1 = $k_bor_1 * $bor_fac_1) 
 CNSsolve>      evaluate ($k_bor_2 = $k_bor_2 * $bor_fac_2) 
 CNSsolve>      evaluate ($k_bor_3 = $k_bor_3 * $bor_fac_3) 
 CNSsolve>      evaluate ($k_bor_4 = $k_bor_4 * $bor_fac_4) 
 CNSsolve>      evaluate ($k_bor_5 = $k_bor_5 * $bor_fac_5) 
 CNSsolve> 
 CNSsolve>      evaluate ($k_cen_1 = $k_cen_1 * $cen_fac_1) 
 CNSsolve>      evaluate ($k_cen_2 = $k_cen_2 * $cen_fac_2) 
 CNSsolve>      evaluate ($k_cen_3 = $k_cen_3 * $cen_fac_3) 
 CNSsolve>      evaluate ($k_cen_4 = $k_cen_4 * $cen_fac_4) 
 CNSsolve>      evaluate ($k_cen_5 = $k_cen_5 * $cen_fac_5) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.vean eq true) then 
 CNSsolve>        vean class vea1 force $k_bor_1 $k_cen_1 end 
 CNSsolve>        vean class vea2 force $k_bor_2 $k_cen_2 end 
 CNSsolve>        vean class vea3 force $k_bor_3 $k_cen_3 end 
 CNSsolve>        vean class vea4 force $k_bor_4 $k_cen_4 end 
 CNSsolve>        vean class vea5 force $k_bor_5 $k_cen_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_sani_1 = $k_sani_1 * $sani_fac_1) 
 CNSsolve>      evaluate ($k_sani_2 = $k_sani_2 * $sani_fac_2) 
 CNSsolve>      evaluate ($k_sani_3 = $k_sani_3 * $sani_fac_3) 
 CNSsolve>      evaluate ($k_sani_4 = $k_sani_4 * $sani_fac_4) 
 CNSsolve>      evaluate ($k_sani_5 = $k_sani_5 * $sani_fac_5) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.sani eq true) then 
 CNSsolve>        sani class rdc1 force $k_sani_1 end 
 CNSsolve>        sani class rdc2 force $k_sani_2 end 
 CNSsolve>        sani class rdc3 force $k_sani_3 end 
 CNSsolve>        sani class rdc4 force $k_sani_4 end 
 CNSsolve>        sani class rdc5 force $k_sani_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_xpcs_1 = $k_xpcs_1 * $xpcs_fac_1) 
 CNSsolve>      evaluate ($k_xpcs_2 = $k_xpcs_2 * $xpcs_fac_2) 
 CNSsolve>      evaluate ($k_xpcs_3 = $k_xpcs_3 * $xpcs_fac_3) 
 CNSsolve>      evaluate ($k_xpcs_4 = $k_xpcs_4 * $xpcs_fac_4) 
 CNSsolve>      evaluate ($k_xpcs_5 = $k_xpcs_5 * $xpcs_fac_5) 
 CNSsolve>      evaluate ($k_xpcs_6 = $k_xpcs_6 * $xpcs_fac_6) 
 CNSsolve>      evaluate ($k_xpcs_7 = $k_xpcs_7 * $xpcs_fac_7) 
 CNSsolve>      evaluate ($k_xpcs_8 = $k_xpcs_8 * $xpcs_fac_8) 
 CNSsolve>      evaluate ($k_xpcs_9 = $k_xpcs_9 * $xpcs_fac_9) 
 CNSsolve>      evaluate ($k_xpcs_A = $k_xpcs_A * $xpcs_fac_A) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.xpcs eq true) then 
 CNSsolve>        xpcs class pcs1 force $k_xpcs_1 end 
 CNSsolve>        xpcs class pcs2 force $k_xpcs_2 end 
 CNSsolve>        xpcs class pcs3 force $k_xpcs_3 end 
 CNSsolve>        xpcs class pcs4 force $k_xpcs_4 end 
 CNSsolve>        xpcs class pcs5 force $k_xpcs_5 end 
 CNSsolve>        xpcs class pcs6 force $k_xpcs_6 end 
 CNSsolve>        xpcs class pcs7 force $k_xpcs_7 end 
 CNSsolve>        xpcs class pcs8 force $k_xpcs_8 end 
 CNSsolve>        xpcs class pcs9 force $k_xpcs_9 end 
 CNSsolve>        xpcs class pcsA force $k_xpcs_A end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_dani_1 = $k_dani_1 * $dani_fac_1) 
 CNSsolve>      evaluate ($k_dani_2 = $k_dani_2 * $dani_fac_2) 
 CNSsolve>      evaluate ($k_dani_3 = $k_dani_3 * $dani_fac_3) 
 CNSsolve>      evaluate ($k_dani_4 = $k_dani_4 * $dani_fac_4) 
 CNSsolve>      evaluate ($k_dani_5 = $k_dani_5 * $dani_fac_5) 
 CNSsolve>      if ($Data.flags.dani eq true) then 
 CNSsolve>        dani class dan1 force $k_dani_1 end 
 CNSsolve>        dani class dan2 force $k_dani_2 end 
 CNSsolve>        dani class dan3 force $k_dani_3 end 
 CNSsolve>        dani class dan4 force $k_dani_4 end 
 CNSsolve>        dani class dan5 force $k_dani_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      if ($Data.scaling eq TRUE) then 
 CNSsolve>        inline @RUN:protocols/set_noe_scale.cns 
 ASSFIL: file set_noe_scale.cns opened.
 CNSsolve>! set_noe_scale.cns 
 CNSsolve>!    Set the distance restraint force constant 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($enoe   = 0.0 ) 
 CNSsolve>evaluate ($vdw    = 0.0 ) 
 CNSsolve>evaluate ($elec   = 0.0 ) 
 CNSsolve>evaluate ($einter = 0.0 ) 
 CNSsolve>evaluate ($noescale = 1.0 ) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym ne true) then 
 CNSsolve>  print threshold=0.5 noe 
 CNSsolve>  evaluate ($numnoe=$violations) 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_amb > 0) then 
 CNSsolve>    evaluate ($ambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_amb)))) 
 CNSsolve>    if ($ambcorr = 0) then 
 CNSsolve>      evaluate ($ambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($ambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_unamb > 0) then 
 CNSsolve>    evaluate ($unambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_unamb)))) 
 CNSsolve>    if ($unambcorr = 0) then 
 CNSsolve>      evaluate ($unambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($unambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve>else 
 CNSsolve>  evaluate ($unambcorr = 1) 
 CNSsolve>  evaluate ($ambcorr = 1) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>eval ($nchain1 = 0) 
 CNSsolve>igroup 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction  (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                   (segid $Toppar.prot_segid_$nchain2) weights * 1 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>  end loop nloop1 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>energy end 
 CNSsolve>igroup 
 CNSsolve>    interaction  (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($einter = abs($vdw + $elec)) 
 CNSsolve>evaluate ($enoe   = $noe) 
 CNSsolve> 
 CNSsolve>if ($enoe ne 0) then 
 CNSsolve>  evaluate ($noescale = min(5000, (2 * $einter / $enoe))) 
 CNSsolve>  if ($noescale ne 0) then 
 CNSsolve>    evaluate ($Data.unamb_hot   = $Data.unamb_hot   * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_hot     = $Data.amb_hot     * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool1 = $Data.unamb_cool1 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool1   = $Data.amb_cool1   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool2 = $Data.unamb_cool2 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool2   = $Data.amb_cool2   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool3 = $Data.unamb_cool3 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool3   = $Data.amb_cool3   * $noescale * $ambcorr) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>        noe 
 CNSsolve>           scale dist $Data.unamb_cool2 
 CNSsolve>           scale ambi $Data.amb_cool2 
 CNSsolve>           scale hbon $Data.hbond_cool2 
 CNSsolve>           asym ambi $asy 
 CNSsolve>           asym dist $asy 
 CNSsolve>           asym hbon $asy 
 CNSsolve>           masym ambi $masy 
 CNSsolve>           masym dist $masy 
 CNSsolve>           masym hbon $masy 
 CNSsolve>        end 
 CNSsolve>      else 
 CNSsolve>        noe 
 CNSsolve>           scale dist $k_unamb 
 CNSsolve>           scale ambi $k_amb 
 CNSsolve>           scale hbon $k_hbond 
 CNSsolve>           asym ambi $asy 
 CNSsolve>           asym dist $asy 
 CNSsolve>           asym hbon $asy 
 CNSsolve>           masym ambi $masy 
 CNSsolve>           masym dist $masy 
 CNSsolve>           masym hbon $masy 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      !scale intermolecular interactions: 
 CNSsolve>      inline @RUN:protocols/scale_inter.cns 
 ASSFIL: file scale_inter.cns opened.
 CNSsolve>! scale_inter.cns 
 CNSsolve>!    Scaling of intermolecular interactions 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) weight * $Toppar.int_$nchain1_$nchain1 end 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve> 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> 
 CNSsolve>  interaction ((resn WAT or resn HOH or resn TIP*)) ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve>      evaluate ($kinter = $kinter + $interstep) 
 CNSsolve> 
 CNSsolve>      dyna tors 
 CNSsolve>         reassign $reassign 
 CNSsolve>         timestep=$timestep 
 CNSsolve>         nstep=$calcsteps 
 CNSsolve>         nprint=$printsteps 
 CNSsolve>         ntrfrq=0 
 CNSsolve>         tcoupling = true  temperature = $bath 
 CNSsolve>      end 
 CNSsolve>      evaluate ($reassign = FALSE) 
 CNSsolve> 
 CNSsolve>      energy end 
 CNSsolve>      if ($ener > 99999999) then 
 CNSsolve>        display ENERGY PROBLEM, THE SYSTEM IS BLOWING UP: ==> STOPPING 
 CNSsolve>        stop 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>end loop cool 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>{* 4 ============================================ third slow cooling *} 
 CNSsolve>{* flexible side-chains and backbone at interface and reduced time step *} 
 CNSsolve> 
 CNSsolve>    if ($Data.flags.rg eq true ) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      collapse force $Data.krg_cool3 end 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($SaProtocol.cool3_steps > 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      if ($torsiondone eq true) then 
 CNSsolve>        dyna tors topo reset end end 
 CNSsolve>      end if 
 CNSsolve>      @RUN:protocols/torsiontop_flex_back.cns 
 ASSFIL: file torsiontop_flex_back.cns opened.
 CNSsolve>! torsiontop_flex_back.cns 
 CNSsolve>!    Set the topology for torsion angle MD with semi-flexible side-chains 
 CNSsolve>!    and backbone at the interface 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($nfletot = 150) 
 CNSsolve>!define flexible segments: 
 CNSsolve>display CALLING flex_segment_back.cns FOR SEMI-FLEXIBLE SA WITH BACKBONE 
 CNSsolve>inline @RUN:protocols/flex_segment_back.cns 
 ASSFIL: file flex_segment_back.cns opened.
 CNSsolve>! flex_segment_back.cns 
 CNSsolve>!    Define the semi-flexible segments (both side-chains and backbone) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store5 = 0) (all) 
 CNSsolve>do (store6 = 0) (all) 
 CNSsolve>do (store7 = 0) (all) 
 CNSsolve> 
 CNSsolve>!first flexible segments for docking 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  evaluate($fcounter=0) 
 CNSsolve> 
 CNSsolve>  if ($Toppar.nseg_$nchain1 = 0) then 
 CNSsolve>    display NO FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    if ($Toppar.nseg_$nchain1 < 0) then 
 CNSsolve>      display AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE $nchain1 
 CNSsolve>      inline @RUN:protocols/flexauto-neighbors.cns 
 ASSFIL: file flexauto-neighbors.cns opened.
 CNSsolve>! flexauto-neighbors.cns 
 CNSsolve>!    Automatic definition of flexible segments for docking for contacting residues 
 CNSsolve>!    including neighboring residues of residues making contacts 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($flcut = 5.0) 
 CNSsolve> 
 CNSsolve>do (store5 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve>do (store7 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve> 
 CNSsolve>do (store6 = 0) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = decode($result)) 
 CNSsolve>    evaluate ($preres = $inres) 
 CNSsolve>    evaluate ($nexres = $inres) 
 CNSsolve>    if ($iteration = 1) then 
 CNSsolve>      evaluate ($preres = $preres - 1) 
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>end loop flexres1 
 CNSsolve> 
 CNSsolve>do (store5 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>do (store7 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve> 
 CNSsolve>display THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule $nchain1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = $result) 
 CNSsolve>    show (resn) (id $id) 
 CNSsolve>    evaluate ($nares = $result) 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($seres = $result) 
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
 CNSsolve>end loop flexres2 
 CNSsolve> 
 CNSsolve>    else 
 CNSsolve>      display FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>      while ($fcounter < $Toppar.nseg_$nchain1) loop Xflex 
 CNSsolve>        evaluate($fcounter=$fcounter + 1) 
 CNSsolve>        do (store5 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>        display FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>      end loop Xflex 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>!then fully flexible segments for all stages 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop2 
 CNSsolve> 
 CNSsolve>do (store5 = 7) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = 0) 
 CNSsolve> 
 CNSsolve>! check number of flexible residues per molecule 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop3 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and (attr store5 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numfle=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not (attr store5 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numrig=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numres=$result) 
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 CNSsolve>end loop nloop3 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = $nfletot + $result) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = $nfletot + 10) 
 CNSsolve> 
 CNSsolve>evaluate ($numtrees=$data.ncomponents) 
 CNSsolve>@RUN:protocols/numtrees.cns(numtrees=$numtrees; Data; Toppar;) 
 ASSFIL: file numtrees.cns opened.
 CNSsolve>! numtrees.cns 
 CNSsolve>!    Define the number of trees for torsion angle MD 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module (numtrees; Data; Toppar;) 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = 1) 
 CNSsolve>evaluate ($ncount = 0) 
 CNSsolve>evaluate ($break=$data.ncomponents) 
 CNSsolve> 
 CNSsolve>while ($ncount < $data.ncomponents) loop nsloop 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = $ncount + 1) 
 CNSsolve> 
 CNSsolve>  for $id1 in id ( name C and bondedto(name CA) and segid $Toppar.prot_segid_$ncount) loop break 
 CNSsolve> 
 CNSsolve>     show (resid) (id $id1) 
 CNSsolve>     evaluate ($resid1=$result) 
 CNSsolve> 
 CNSsolve>     evaluate ($resid2=encode(decode($resid1)+1)) 
 CNSsolve> 
 CNSsolve>     show sum(1) (id $id1 and known) 
 CNSsolve>     if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>       identity (store1) ( name N and bondedto(name CA) and segid $Toppar.prot_segid_$ncount and resid $resid2 ) 
 CNSsolve>       show element (store1) (attribute store1 > 0) 
 CNSsolve>       if ( $result ne 0) then 
 CNSsolve>         evaluate ($id2=$result) 
 CNSsolve> 
 CNSsolve>         show sum(1) (id $id2 and known) 
 CNSsolve> 
 CNSsolve>         if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>           pick bond 
 CNSsolve>             (name c and segid $Toppar.prot_segid_$ncount and resid $resid1) 
 CNSsolve>             (name n and segid $Toppar.prot_segid_$ncount and resid $resid2) 
 CNSsolve>             geometry 
 CNSsolve> 
 CNSsolve>           if ( $result > 2.5 ) then 
 CNSsolve>             evaluate ($break=$break+1) 
 CNSsolve>           end if 
 CNSsolve>         else 
 CNSsolve>           evaluate ($break=$break+1) 
 CNSsolve>         end if 
 CNSsolve>       end if 
 CNSsolve>     end if 
 CNSsolve> 
 CNSsolve>   end loop break 
 CNSsolve> 
 CNSsolve>end loop nsloop 
 CNSsolve> 
 CNSsolve>! check for water molecules 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate (&numtrees = $numtrees + $break + $result) 
 CNSsolve> 
 CNSsolve>if ($data.flags.sani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xrdc eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xpcs eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.dani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = $numtrees + 30) 
 CNSsolve> 
 CNSsolve>DISPLAY NUMTREES set to $numtrees 
 CNSsolve> 
 CNSsolve>dyna tors 
 CNSsolve>   topology 
 CNSsolve>      maxtree $numtrees 
 CNSsolve>      kdihmax = 23. 
 CNSsolve>      evaluate ($N_atom_id = 0) 
 CNSsolve>      evaluate ($atom_id = 0) 
 CNSsolve> 
 CNSsolve>      for $atom_id in id ( name ca ) loop main 
 CNSsolve>         if ( $N_atom_id > 0 ) then 
 CNSsolve>            fix group 
 CNSsolve>            (( byresidue ( id $N_atom_id ) and 
 CNSsolve>                (name C or name O {or name CA} )) 
 CNSsolve>             or ( byresidue ( id $atom_id ) and 
 CNSsolve>                (((name N or name HN {or name CA}) {and not resn pro}) 
 CNSsolve>                {or (( name N or name CD or name CA ) and resn pro)}))) 
 CNSsolve>         end if 
 CNSsolve>         evaluate ($N_atom_id = $atom_id) 
 CNSsolve>      end loop main 
 CNSsolve>      if ( $atom_id > 0 ) then 
 CNSsolve>        fix group 
 CNSsolve>           ( byresidue ( id $atom_id ) 
 CNSsolve>            and (name c or name ot1 or name ot2 {or name CA} )) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      for $atom_id in id 
 FOR-clause=     ( name ca and (resn phe or resn trp or resn his or resn asp or resn asn or resn nep)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                          name %Z* or name %E* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn tyr)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                 name %Z* or name %E* or name OH  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn gln or resn glu)) 
 FOR-clause=      loop main	 
 CNSsolve>            fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                 and ({name CG or} name %D* or name %E*)) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn arg)) 
 FOR-clause=      loop main	 
 CNSsolve>        fix group 
 CNSsolve>          ( byresidue ( id $atom_id ) 
 CNSsolve>          and ({name CD or} name %E* or name %Z* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve> 
 CNSsolve>      !next loop is for all sugars defined in glycans-uu.top 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name c1 and (resn GCP or resn GCF or resn GTP or resn GTF or resn MNP 
 FOR-clause=	  or resn MNF or resn ALP or resn ALF or resn ARP or resn ARF or resn GLP 
 FOR-clause=	  or resn GLF or resn IDP or resn IDF or resn TLP or resn TLF or resn PCP 
 FOR-clause=	  or resn PCF or resn FTP or resn FTF or resn SBP or resn SBF or resn TTP 
 FOR-clause=	  or resn TTF or resn NAA or resn RBP or resn RBF or resn ANF or resn XLF 
 FOR-clause=	  or resn LXF or resn RLF or resn LLF)) 
 FOR-clause=      loop main	 
 CNSsolve>        fix group 
 CNSsolve>          ( byresidue ( id $atom_id ) 
 CNSsolve>          and (name %1 or name %2 or name %3 or name %4 or name %5 or name O5)) 
 CNSsolve>      end loop main 
 CNSsolve> 
 CNSsolve>      fix group ( resn HEC and (name C1* or name C2* or name C3* or name C4* or name N* or name CH*)) 
 CNSsolve> 
 CNSsolve>      fix group ( resn PRO and not (name c or name o) ) 
 CNSsolve> 
 CNSsolve>      fix group ( resn CYM and not (name CA or name C or name O or name OXT or 
 CNSsolve>                  name N or name HN or name HA or name CB or name HB1 or name HB2 or 
 CNSsolve>                  name SG or name SAL or name CAJ)) 
 CNSsolve> 
 CNSsolve>      fix group ( byresidue (resn WAT)) 
 CNSsolve>      fix group ( byresidue (resn HOH)) 
 CNSsolve>      fix group ( byresidue (resn TIP*)) 
 CNSsolve>      fix group ( byresidue (resn ANI)) 
 CNSsolve>      fix group ( byresidue (resn DAN)) 
 CNSsolve>      fix group ( byresidue (resn XAN)) 
 CNSsolve> 
 CNSsolve>      for $id in id (name C1') loop freeribose 
 CNSsolve>        free bond (id $id) (byresid (id $id) and name C2') 
 CNSsolve>      end loop freeribose 
 CNSsolve>      eval($nchain1 = 0) 
 CNSsolve>      while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>        eval($nchain1 = $nchain1 + 1) 
 CNSsolve>        fix group (segid $Toppar.prot_segid_$nchain1 and 
 CNSsolve>                   not (attribute store5 = $nchain1) 
 CNSsolve>		   and not ((resn WAT or resn HOH or resn TIP*))) 
 CNSsolve>      end loop nloop1 
 CNSsolve>   end 
 CNSsolve>end 
 CNSsolve>      eval ($torsiondone = true) 
 CNSsolve>      evaluate ($SaProtocol.tadfactor = 1) 
 CNSsolve>      @RUN:protocols/sa_ltad_cool3.cns(SaProtocol=$SaProtocol;Data=$Data;Toppar=$Toppar) 
 ASSFIL: file sa_ltad_cool3.cns opened.
 CNSsolve>! sa_ltad_cool3.cns 
 CNSsolve>!    Perfrom the third simulated annealing stage of it1 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module(SaProtocol;Data;Toppar) 
 CNSsolve> 
 CNSsolve>! module sa_ltad_cool3.cns 
 CNSsolve>! torsion dynamics cooling 
 CNSsolve> 
 CNSsolve>evaluate ($ncycle = 20) 
 CNSsolve> 
 CNSsolve>evaluate ($asy_add = (&Data.asy_cool3-&Data.asy_cool2)/$ncycle) 
 CNSsolve>evaluate ($masy_add = (&Data.masy_cool3-&Data.masy_cool2)/$ncycle) 
 CNSsolve> 
 CNSsolve>evaluate ($asy=&Data.asy_cool2) 
 CNSsolve>evaluate ($masy=&Data.masy_cool2) 
 CNSsolve> 
 CNSsolve>noe 
 CNSsolve>    rswitch ambi &Data.Rswi_cool2 
 CNSsolve>    rswitch dist &Data.Rswi_cool2 
 CNSsolve>    rswitch hbon &Data.Rswi_cool2 
 CNSsolve> 
 CNSsolve>    mrswitch ambi &Data.mRswi_cool2 
 CNSsolve>    mrswitch dist &Data.mRswi_cool2 
 CNSsolve>    mrswitch hbon &Data.mRswi_cool2 
 CNSsolve> 
 CNSsolve>    asym ambi &Data.asy_cool2 
 CNSsolve>    asym dist &Data.asy_cool2 
 CNSsolve>    asym hbon &Data.asy_cool2 
 CNSsolve> 
 CNSsolve>    masym ambi &Data.masy_cool2 
 CNSsolve>    masym dist &Data.masy_cool2 
 CNSsolve>    masym hbon &Data.masy_cool2 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>restraints dihedral   scale=&Data.dihedrals_cool3   end 
 CNSsolve>couplings class c1 force &Data.c1_cool3 end 
 CNSsolve>couplings class c2 force &Data.c2_cool3 end 
 CNSsolve>couplings class c3 force &Data.c3_cool3 end 
 CNSsolve>couplings class c4 force &Data.c4_cool3 end 
 CNSsolve>couplings class c5 force &Data.c5_cool3 end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate( $k_sani_1  = &Data.rdc1_cool2) 
 CNSsolve>if (&Data.rdc1_cool2 > 0) then 
 CNSsolve>  evaluate( $sani_fac_1 = ( &Data.rdc1_cool3 / &Data.rdc1_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_2  = &Data.rdc2_cool2) 
 CNSsolve>if (&Data.rdc2_cool2 > 0) then 
 CNSsolve>  evaluate( $sani_fac_2 = ( &Data.rdc2_cool3 / &Data.rdc2_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_3  = &Data.rdc3_cool2) 
 CNSsolve>if (&Data.rdc3_cool2 > 0) then 
 CNSsolve>  evaluate( $sani_fac_3 = ( &Data.rdc3_cool3 / &Data.rdc3_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_4  = &Data.rdc4_cool2) 
 CNSsolve>if (&Data.rdc4_cool2 > 0) then 
 CNSsolve>  evaluate( $sani_fac_4 = ( &Data.rdc4_cool3 / &Data.rdc4_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_5  = &Data.rdc5_cool2) 
 CNSsolve>if (&Data.rdc5_cool2 > 0) then 
 CNSsolve>  evaluate( $sani_fac_5 = ( &Data.rdc5_cool3 / &Data.rdc5_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sani eq true) then 
 CNSsolve>  sani class rdc1 force $k_sani_1 end 
 CNSsolve>  sani class rdc2 force $k_sani_2 end 
 CNSsolve>  sani class rdc3 force $k_sani_3 end 
 CNSsolve>  sani class rdc4 force $k_sani_4 end 
 CNSsolve>  sani class rdc5 force $k_sani_5 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate( $k_dani_1  = &Data.dan1_cool2) 
 CNSsolve>if (&Data.dan1_cool2 > 0) then 
 CNSsolve>  evaluate( $dani_fac_1 = ( &Data.dan1_cool3 / &Data.dan1_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_2  = &Data.dan2_cool2) 
 CNSsolve>if (&Data.dan2_cool2 > 0) then 
 CNSsolve>  evaluate( $dani_fac_2 = ( &Data.dan2_cool3 / &Data.dan2_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_3  = &Data.dan3_cool2) 
 CNSsolve>if (&Data.dan3_cool2 > 0) then 
 CNSsolve>  evaluate( $dani_fac_3 = ( &Data.dan3_cool3 / &Data.dan3_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_4  = &Data.dan4_cool2) 
 CNSsolve>if (&Data.dan4_cool2 > 0) then 
 CNSsolve>  evaluate( $dani_fac_4 = ( &Data.dan4_cool3 / &Data.dan4_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_5  = &Data.dan5_cool2) 
 CNSsolve>if (&Data.dan5_cool2 > 0) then 
 CNSsolve>  evaluate( $dani_fac_5 = ( &Data.dan5_cool3 / &Data.dan5_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.dani eq true) then 
 CNSsolve>  dani class dan1 force $k_dani_1 end 
 CNSsolve>  dani class dan2 force $k_dani_2 end 
 CNSsolve>  dani class dan3 force $k_dani_3 end 
 CNSsolve>  dani class dan4 force $k_dani_4 end 
 CNSsolve>  dani class dan5 force $k_dani_5 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate( $k_xpcs_1  = &Data.pcs1_cool2) 
 CNSsolve>if (&Data.pcs1_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_1 = ( &Data.pcs1_cool3 / &Data.pcs1_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_2  = &Data.pcs2_cool2) 
 CNSsolve>if (&Data.pcs2_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_2 = ( &Data.pcs2_cool3 / &Data.pcs2_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_3  = &Data.pcs3_cool2) 
 CNSsolve>if (&Data.pcs3_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_3 = ( &Data.pcs3_cool3 / &Data.pcs3_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_4  = &Data.pcs4_cool2) 
 CNSsolve>if (&Data.pcs4_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_4 = ( &Data.pcs4_cool3 / &Data.pcs4_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_5  = &Data.pcs5_cool2) 
 CNSsolve>if (&Data.pcs5_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_5 = ( &Data.pcs5_cool3 / &Data.pcs5_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_6  = &Data.pcs6_cool2) 
 CNSsolve>if (&Data.pcs6_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_6 = ( &Data.pcs6_cool3 / &Data.pcs6_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_6 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_7  = &Data.pcs7_cool2) 
 CNSsolve>if (&Data.pcs7_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_7 = ( &Data.pcs7_cool3 / &Data.pcs7_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_7 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_8  = &Data.pcs8_cool2) 
 CNSsolve>if (&Data.pcs8_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_8 = ( &Data.pcs8_cool3 / &Data.pcs8_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_8 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_9  = &Data.pcs9_cool2) 
 CNSsolve>if (&Data.pcs9_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_9 = ( &Data.pcs9_cool3 / &Data.pcs9_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_9 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_A  = &Data.pcsA_cool2) 
 CNSsolve>if (&Data.pcsA_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_A = ( &Data.pcsA_cool3 / &Data.pcsA_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_A = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($Data.flags.xpcs eq true) then 
 CNSsolve>  xpcs class pcs1 force $k_xpcs_1 end 
 CNSsolve>  xpcs class pcs2 force $k_xpcs_2 end 
 CNSsolve>  xpcs class pcs3 force $k_xpcs_3 end 
 CNSsolve>  xpcs class pcs4 force $k_xpcs_4 end 
 CNSsolve>  xpcs class pcs5 force $k_xpcs_5 end 
 CNSsolve>  xpcs class pcs6 force $k_xpcs_6 end 
 CNSsolve>  xpcs class pcs7 force $k_xpcs_7 end 
 CNSsolve>  xpcs class pcs8 force $k_xpcs_8 end 
 CNSsolve>  xpcs class pcs9 force $k_xpcs_9 end 
 CNSsolve>  xpcs class pcsA force $k_xpcs_A end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($interstep = (&SaProtocol.inter_fin_cool3 - &SaProtocol.inter_init_cool3)/($ncycle-1)) 
 CNSsolve>evaluate ($kinter = &SaProtocol.inter_init_cool3) 
 CNSsolve> 
 CNSsolve>evaluate ($tempstep = (&SaProtocol.t3_init - &SaProtocol.t3_final)/$ncycle) 
 CNSsolve>evaluate ($calcsteps = int(&SaProtocol.cool3_steps/$ncycle)) 
 CNSsolve>evaluate ($printsteps = int($calcsteps / 4)) 
 CNSsolve>evaluate ($timestep = &SaProtocol.timestep*&SaProtocol.tadfactor) 
 CNSsolve> 
 CNSsolve>if (&Data.unamb_cool2 = 0) then 
 CNSsolve>  evaluate (&Data.unamb_cool2 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.unamb_cool3 = 0) then 
 CNSsolve>  evaluate (&Data.unamb_cool3 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.amb_cool2 = 0) then 
 CNSsolve>  evaluate (&Data.amb_cool2 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.amb_cool3 = 0) then 
 CNSsolve>  evaluate (&Data.amb_cool3 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.hbond_cool2 = 0) then 
 CNSsolve>  evaluate (&Data.hbond_cool2 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.hbond_cool3 = 0) then 
 CNSsolve>  evaluate (&Data.hbond_cool3 = 0.000001) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($k_unamb= &Data.unamb_cool2) 
 CNSsolve>evaluate ($unamb_fac = (&Data.unamb_cool3/&Data.unamb_cool2)^(1/$ncycle)) 
 CNSsolve>evaluate ($k_amb= &Data.amb_cool2) 
 CNSsolve>evaluate ($amb_fac = (&Data.amb_cool3/&Data.amb_cool2)^(1/$ncycle)) 
 CNSsolve>evaluate ($k_hbond= &Data.hbond_cool2) 
 CNSsolve>evaluate ($hbond_fac = (&Data.hbond_cool3/&Data.hbond_cool2)^(1/$ncycle)) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!for the vean statement: 
 CNSsolve>evaluate( $k_cen_1 = &Data.ini_cen_cool3_1) 
 CNSsolve>evaluate( $cen_fac_1 = ( &Data.fin_cen_cool3_1 / &Data.ini_cen_cool3_1)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_1 = &Data.ini_bor_cool3_1) 
 CNSsolve>evaluate( $bor_fac_1 = ( &Data.fin_bor_cool3_1 / &Data.ini_bor_cool3_1)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_2 = &Data.ini_cen_cool3_2) 
 CNSsolve>evaluate( $cen_fac_2 = ( &Data.fin_cen_cool3_2 / &Data.ini_cen_cool3_2)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_2 = &Data.ini_bor_cool3_2) 
 CNSsolve>evaluate( $bor_fac_2 = ( &Data.fin_bor_cool3_2 / &Data.ini_bor_cool3_2)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_3 = &Data.ini_cen_cool3_3) 
 CNSsolve>evaluate( $cen_fac_3 = ( &Data.fin_cen_cool3_3 / &Data.ini_cen_cool3_3)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_3 = &Data.ini_bor_cool3_3) 
 CNSsolve>evaluate( $bor_fac_3 = ( &Data.fin_bor_cool3_3 / &Data.ini_bor_cool3_3)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_4 = &Data.ini_cen_cool3_4) 
 CNSsolve>evaluate( $cen_fac_4 = ( &Data.fin_cen_cool3_4 / &Data.ini_cen_cool3_4)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_4 = &Data.ini_bor_cool3_4) 
 CNSsolve>evaluate( $bor_fac_4 = ( &Data.fin_bor_cool3_4 / &Data.ini_bor_cool3_4)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_5 = &Data.ini_cen_cool3_5) 
 CNSsolve>evaluate( $cen_fac_5 = ( &Data.fin_cen_cool3_5 / &Data.ini_cen_cool3_5)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_5 = &Data.ini_bor_cool3_5) 
 CNSsolve>evaluate( $bor_fac_5 = ( &Data.fin_bor_cool3_5 / &Data.ini_bor_cool3_5)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate ($bath  = &SaProtocol.t3_init) 
 CNSsolve>do (vx=maxwell($bath)) ( all ) 
 CNSsolve>do (vy=maxwell($bath)) ( all ) 
 CNSsolve>do (vz=maxwell($bath)) ( all ) 
 CNSsolve> 
 CNSsolve>evaluate ($reassign = TRUE) 
 CNSsolve>evaluate ($i_cool = 0) 
 CNSsolve>while ($i_cool < $ncycle) loop cool 
 CNSsolve> 
 CNSsolve>      evaluate ($i_cool=$i_cool+1) 
 CNSsolve> 
 CNSsolve>      evaluate ($bath  = $bath  - $tempstep) 
 CNSsolve>      evaluate ($k_unamb = $k_unamb*$unamb_fac) 
 CNSsolve>      evaluate ($k_amb = $k_amb*$amb_fac) 
 CNSsolve>      evaluate ($k_hbond = $k_hbond*$hbond_fac) 
 CNSsolve>      evaluate ($asy=$asy+$asy_add) 
 CNSsolve>      evaluate ($masy=$masy+$masy_add) 
 CNSsolve> 
 CNSsolve>      evaluate ($k_bor_1 = $k_bor_1 * $bor_fac_1) 
 CNSsolve>      evaluate ($k_bor_2 = $k_bor_2 * $bor_fac_2) 
 CNSsolve>      evaluate ($k_bor_3 = $k_bor_3 * $bor_fac_3) 
 CNSsolve>      evaluate ($k_bor_4 = $k_bor_4 * $bor_fac_4) 
 CNSsolve>      evaluate ($k_bor_5 = $k_bor_5 * $bor_fac_5) 
 CNSsolve> 
 CNSsolve>      evaluate ($k_cen_1 = $k_cen_1 * $cen_fac_1) 
 CNSsolve>      evaluate ($k_cen_2 = $k_cen_2 * $cen_fac_2) 
 CNSsolve>      evaluate ($k_cen_3 = $k_cen_3 * $cen_fac_3) 
 CNSsolve>      evaluate ($k_cen_4 = $k_cen_4 * $cen_fac_4) 
 CNSsolve>      evaluate ($k_cen_5 = $k_cen_5 * $cen_fac_5) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.vean eq true) then 
 CNSsolve>        vean class vea1 force $k_bor_1 $k_cen_1 end 
 CNSsolve>        vean class vea2 force $k_bor_2 $k_cen_2 end 
 CNSsolve>        vean class vea3 force $k_bor_3 $k_cen_3 end 
 CNSsolve>        vean class vea4 force $k_bor_4 $k_cen_4 end 
 CNSsolve>        vean class vea5 force $k_bor_5 $k_cen_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_sani_1 = $k_sani_1 * $sani_fac_1) 
 CNSsolve>      evaluate ($k_sani_2 = $k_sani_2 * $sani_fac_2) 
 CNSsolve>      evaluate ($k_sani_3 = $k_sani_3 * $sani_fac_3) 
 CNSsolve>      evaluate ($k_sani_4 = $k_sani_4 * $sani_fac_4) 
 CNSsolve>      evaluate ($k_sani_5 = $k_sani_5 * $sani_fac_5) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.sani eq true) then 
 CNSsolve>        sani class rdc1 force $k_sani_1 end 
 CNSsolve>        sani class rdc2 force $k_sani_2 end 
 CNSsolve>        sani class rdc3 force $k_sani_3 end 
 CNSsolve>        sani class rdc4 force $k_sani_4 end 
 CNSsolve>        sani class rdc5 force $k_sani_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_xpcs_1 = $k_xpcs_1 * $xpcs_fac_1) 
 CNSsolve>      evaluate ($k_xpcs_2 = $k_xpcs_2 * $xpcs_fac_2) 
 CNSsolve>      evaluate ($k_xpcs_3 = $k_xpcs_3 * $xpcs_fac_3) 
 CNSsolve>      evaluate ($k_xpcs_4 = $k_xpcs_4 * $xpcs_fac_4) 
 CNSsolve>      evaluate ($k_xpcs_5 = $k_xpcs_5 * $xpcs_fac_5) 
 CNSsolve>      evaluate ($k_xpcs_6 = $k_xpcs_6 * $xpcs_fac_6) 
 CNSsolve>      evaluate ($k_xpcs_7 = $k_xpcs_7 * $xpcs_fac_7) 
 CNSsolve>      evaluate ($k_xpcs_8 = $k_xpcs_8 * $xpcs_fac_8) 
 CNSsolve>      evaluate ($k_xpcs_9 = $k_xpcs_9 * $xpcs_fac_9) 
 CNSsolve>      evaluate ($k_xpcs_A = $k_xpcs_A * $xpcs_fac_A) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.xpcs eq true) then 
 CNSsolve>        xpcs class pcs1 force $k_xpcs_1 end 
 CNSsolve>        xpcs class pcs2 force $k_xpcs_2 end 
 CNSsolve>        xpcs class pcs3 force $k_xpcs_3 end 
 CNSsolve>        xpcs class pcs4 force $k_xpcs_4 end 
 CNSsolve>        xpcs class pcs5 force $k_xpcs_5 end 
 CNSsolve>        xpcs class pcs6 force $k_xpcs_6 end 
 CNSsolve>        xpcs class pcs7 force $k_xpcs_7 end 
 CNSsolve>        xpcs class pcs8 force $k_xpcs_8 end 
 CNSsolve>        xpcs class pcs9 force $k_xpcs_9 end 
 CNSsolve>        xpcs class pcsA force $k_xpcs_A end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_dani_1 = $k_dani_1 * $dani_fac_1) 
 CNSsolve>      evaluate ($k_dani_2 = $k_dani_2 * $dani_fac_2) 
 CNSsolve>      evaluate ($k_dani_3 = $k_dani_3 * $dani_fac_3) 
 CNSsolve>      evaluate ($k_dani_4 = $k_dani_4 * $dani_fac_4) 
 CNSsolve>      evaluate ($k_dani_5 = $k_dani_5 * $dani_fac_5) 
 CNSsolve>      if ($Data.flags.dani eq true) then 
 CNSsolve>        dani class dan1 force $k_dani_1 end 
 CNSsolve>        dani class dan2 force $k_dani_2 end 
 CNSsolve>        dani class dan3 force $k_dani_3 end 
 CNSsolve>        dani class dan4 force $k_dani_4 end 
 CNSsolve>        dani class dan5 force $k_dani_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      if ($Data.scaling eq TRUE) then 
 CNSsolve>        inline @RUN:protocols/set_noe_scale.cns 
 ASSFIL: file set_noe_scale.cns opened.
 CNSsolve>! set_noe_scale.cns 
 CNSsolve>!    Set the distance restraint force constant 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($enoe   = 0.0 ) 
 CNSsolve>evaluate ($vdw    = 0.0 ) 
 CNSsolve>evaluate ($elec   = 0.0 ) 
 CNSsolve>evaluate ($einter = 0.0 ) 
 CNSsolve>evaluate ($noescale = 1.0 ) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym ne true) then 
 CNSsolve>  print threshold=0.5 noe 
 CNSsolve>  evaluate ($numnoe=$violations) 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_amb > 0) then 
 CNSsolve>    evaluate ($ambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_amb)))) 
 CNSsolve>    if ($ambcorr = 0) then 
 CNSsolve>      evaluate ($ambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($ambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_unamb > 0) then 
 CNSsolve>    evaluate ($unambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_unamb)))) 
 CNSsolve>    if ($unambcorr = 0) then 
 CNSsolve>      evaluate ($unambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($unambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve>else 
 CNSsolve>  evaluate ($unambcorr = 1) 
 CNSsolve>  evaluate ($ambcorr = 1) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>eval ($nchain1 = 0) 
 CNSsolve>igroup 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction  (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                   (segid $Toppar.prot_segid_$nchain2) weights * 1 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>  end loop nloop1 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>energy end 
 CNSsolve>igroup 
 CNSsolve>    interaction  (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($einter = abs($vdw + $elec)) 
 CNSsolve>evaluate ($enoe   = $noe) 
 CNSsolve> 
 CNSsolve>if ($enoe ne 0) then 
 CNSsolve>  evaluate ($noescale = min(5000, (2 * $einter / $enoe))) 
 CNSsolve>  if ($noescale ne 0) then 
 CNSsolve>    evaluate ($Data.unamb_hot   = $Data.unamb_hot   * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_hot     = $Data.amb_hot     * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool1 = $Data.unamb_cool1 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool1   = $Data.amb_cool1   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool2 = $Data.unamb_cool2 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool2   = $Data.amb_cool2   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool3 = $Data.unamb_cool3 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool3   = $Data.amb_cool3   * $noescale * $ambcorr) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>        noe 
 CNSsolve>           scale dist $Data.unamb_cool3 
 CNSsolve>           scale ambi $Data.amb_cool3 
 CNSsolve>           scale hbon $Data.hbond_cool3 
 CNSsolve>           asym ambi $asy 
 CNSsolve>           asym dist $asy 
 CNSsolve>           asym hbon $asy 
 CNSsolve>           masym ambi $masy 
 CNSsolve>           masym dist $masy 
 CNSsolve>           masym hbon $masy 
 CNSsolve>        end 
 CNSsolve>      else 
 CNSsolve>        noe 
 CNSsolve>           scale dist $k_unamb 
 CNSsolve>           scale ambi $k_amb 
 CNSsolve>           scale hbon $k_hbond 
 CNSsolve>           asym ambi $asy 
 CNSsolve>           asym dist $asy 
 CNSsolve>           asym hbon $asy 
 CNSsolve>           masym ambi $masy 
 CNSsolve>           masym dist $masy 
 CNSsolve>           masym hbon $masy 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      !scale intermolecular interactions: 
 CNSsolve>      inline @RUN:protocols/scale_inter.cns 
 ASSFIL: file scale_inter.cns opened.
 CNSsolve>! scale_inter.cns 
 CNSsolve>!    Scaling of intermolecular interactions 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) weight * $Toppar.int_$nchain1_$nchain1 end 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve> 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> 
 CNSsolve>  interaction ((resn WAT or resn HOH or resn TIP*)) ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve>      evaluate ($kinter = $kinter + $interstep) 
 CNSsolve> 
 CNSsolve>      dyna tors 
 CNSsolve>         reassign $reassign 
 CNSsolve>         timestep=$timestep 
 CNSsolve>         nstep=$calcsteps 
 CNSsolve>         nprint=$printsteps 
 CNSsolve>         ntrfrq=0 
 CNSsolve>         tcoupling = true  temperature = $bath 
 CNSsolve>      end 
 CNSsolve>      evaluate ($reassign = FALSE) 
 CNSsolve> 
 CNSsolve>      energy end 
 CNSsolve>      if ($ener > 99999999) then 
 CNSsolve>        display ENERGY PROBLEM, THE SYSTEM IS BLOWING UP: ==> STOPPING 
 CNSsolve>        stop 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>end loop cool 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>{* 5 =========================== final minimization *} 
 CNSsolve> 
 CNSsolve>  if ($Data.scaling eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    inline @RUN:protocols/set_noe_scale.cns 
 ASSFIL: file set_noe_scale.cns opened.
 CNSsolve>! set_noe_scale.cns 
 CNSsolve>!    Set the distance restraint force constant 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($enoe   = 0.0 ) 
 CNSsolve>evaluate ($vdw    = 0.0 ) 
 CNSsolve>evaluate ($elec   = 0.0 ) 
 CNSsolve>evaluate ($einter = 0.0 ) 
 CNSsolve>evaluate ($noescale = 1.0 ) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym ne true) then 
 CNSsolve>  print threshold=0.5 noe 
 CNSsolve>  evaluate ($numnoe=$violations) 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_amb > 0) then 
 CNSsolve>    evaluate ($ambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_amb)))) 
 CNSsolve>    if ($ambcorr = 0) then 
 CNSsolve>      evaluate ($ambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($ambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_unamb > 0) then 
 CNSsolve>    evaluate ($unambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_unamb)))) 
 CNSsolve>    if ($unambcorr = 0) then 
 CNSsolve>      evaluate ($unambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($unambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve>else 
 CNSsolve>  evaluate ($unambcorr = 1) 
 CNSsolve>  evaluate ($ambcorr = 1) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>eval ($nchain1 = 0) 
 CNSsolve>igroup 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction  (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                   (segid $Toppar.prot_segid_$nchain2) weights * 1 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>  end loop nloop1 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>energy end 
 CNSsolve>igroup 
 CNSsolve>    interaction  (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($einter = abs($vdw + $elec)) 
 CNSsolve>evaluate ($enoe   = $noe) 
 CNSsolve> 
 CNSsolve>if ($enoe ne 0) then 
 CNSsolve>  evaluate ($noescale = min(5000, (2 * $einter / $enoe))) 
 CNSsolve>  if ($noescale ne 0) then 
 CNSsolve>    evaluate ($Data.unamb_hot   = $Data.unamb_hot   * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_hot     = $Data.amb_hot     * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool1 = $Data.unamb_cool1 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool1   = $Data.amb_cool1   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool2 = $Data.unamb_cool2 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool2   = $Data.amb_cool2   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool3 = $Data.unamb_cool3 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool3   = $Data.amb_cool3   * $noescale * $ambcorr) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>    energy end 
 CNSsolve>    noe 
 CNSsolve>      scale dist $Data.unamb_cool3 
 CNSsolve>      scale ambi $Data.amb_cool3 
 CNSsolve>      scale hbon $Data.hbond_cool3 
 CNSsolve>    end 
 CNSsolve>    energy end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  @RUN:protocols/flex_segment_back.cns 
 ASSFIL: file flex_segment_back.cns opened.
 CNSsolve>! flex_segment_back.cns 
 CNSsolve>!    Define the semi-flexible segments (both side-chains and backbone) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store5 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (store7 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>!first flexible segments for docking 
 CNSsolve>evaluate($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>  evaluate($fcounter=0) 
 EVALUATE: symbol $FCOUNTER set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>  if ($Toppar.nseg_$nchain1 = 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    display NO FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    if ($Toppar.nseg_$nchain1 < 0) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      display AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE $nchain1 
AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE 1
 CNSsolve>      inline @RUN:protocols/flexauto-neighbors.cns 
 ASSFIL: file flexauto-neighbors.cns opened.
 CNSsolve>! flexauto-neighbors.cns 
 CNSsolve>!    Automatic definition of flexible segments for docking for contacting residues 
 CNSsolve>!    including neighboring residues of residues making contacts 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($flcut = 5.0) 
 EVALUATE: symbol $FLCUT set to    5.00000     (real)
 CNSsolve> 
 CNSsolve>do (store5 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 SELRPN>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 SELRPN:    207 atoms have been selected out of   3007
 CNSsolve>do (store7 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 SELRPN>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 SELRPN:    207 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>do (store6 = 0) (segid $Toppar.prot_segid_$nchain1) 
 SELRPN:   2970 atoms have been selected out of   3007
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 SELRPN:     23 atoms have been selected out of   3007
 FOR ID LOOP: symbol ID set to    216.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  22   N    )  22  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    22.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    22.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    22.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    21.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      8 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    275.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  30   N    )  30  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    30.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    30.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    30.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    29.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      8 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    439.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ALA  47   N    )  47  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    47.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    47.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    47.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    46.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      8 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      6 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    445.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ILE  48   N    )  48  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    48.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    48.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    48.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    47.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      6 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    454.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LYS  49   N    )  49  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    49.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    49.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    49.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    48.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     13 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    623.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLU  66   N    )  66  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    66.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    66.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    66.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    65.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     10 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    661.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    MET  70   N    )  70  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    70.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    70.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    70.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    69.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      8 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    739.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    CYS  79   N    )  79  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    79.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    79.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    79.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    78.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      8 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      8 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    859.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  92   N    )  92  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    92.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    92.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    92.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    91.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     12 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    868.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ILE  93   N    )  93  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    93.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    93.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    93.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    92.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    877.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    THR  94   N    )  94  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    94.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    94.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    94.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    93.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    886.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLN  95   N    )  95  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    95.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    95.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    95.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    94.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     12 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    898.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  96   N    )  96  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    96.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    96.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    96.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    95.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     12 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    907.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    MET  97   N    )  97  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    97.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    97.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    97.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    96.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    916.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    PRO  98   N    )  98  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    98.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    98.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    98.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    97.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      7 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    923.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    PHE  99   N    )  99  
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    99.0000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    99.0000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    99.0000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    98.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      7 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     12 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    935.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLY  100  N    )  100 
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    100.000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    100.000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    100.000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    99.0000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     12 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      5 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    940.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    CYS  101  N    )  101 
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    101.000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    101.000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    101.000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    100.000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      5 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      8 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    966.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ASP  104  N    )  104 
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    104.000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    104.000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    104.000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    103.000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    1014.00     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLU  108  N    )  108 
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    108.000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    108.000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    108.000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    107.000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     17 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     10 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    1431.00     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  148  N    )  148 
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    148.000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    148.000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    148.000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    147.000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      8 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    1531.00     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    THR  158  N    )  158 
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    158.000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    158.000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    158.000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    157.000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 FOR ID LOOP: symbol ID set to    1540.00     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ASP  159  N    )  159 
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    159.000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    159.000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    159.000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    158.000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      9 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = decode($result)) 
 CNSsolve>    evaluate ($preres = $inres) 
 CNSsolve>    evaluate ($nexres = $inres) 
 CNSsolve>    if ($iteration = 1) then 
 CNSsolve>      evaluate ($preres = $preres - 1) 
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>end loop flexres1 
 CNSsolve> 
 CNSsolve>do (store5 = store6) (segid $Toppar.prot_segid_$nchain1) 
 SELRPN:   2970 atoms have been selected out of   3007
 CNSsolve>do (store7 = store6) (segid $Toppar.prot_segid_$nchain1) 
 SELRPN:   2970 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>display THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule $nchain1 
THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule 1
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 SELRPN:     34 atoms have been selected out of   3007
 FOR ID LOOP: symbol ID set to    208.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  21   N    )  21  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "21" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  21   N    )  VAL 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "VAL" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  21   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: VAL,21,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    216.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  22   N    )  22  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "22" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  22   N    )  LEU 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "LEU" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  22   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: LEU,22,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    266.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    THR  29   N    )  29  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "29" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    THR  29   N    )  THR 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "THR" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    THR  29   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: THR,29,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    275.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  30   N    )  30  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "30" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  30   N    )  VAL 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "VAL" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  30   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: VAL,30,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    431.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  46   N    )  46  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "46" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  46   N    )  VAL 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "VAL" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  46   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: VAL,46,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    439.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ALA  47   N    )  47  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "47" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ALA  47   N    )  ALA 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "ALA" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ALA  47   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: ALA,47,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    445.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ILE  48   N    )  48  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "48" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ILE  48   N    )  ILE 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "ILE" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ILE  48   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: ILE,48,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    454.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LYS  49   N    )  49  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "49" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LYS  49   N    )  LYS 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "LYS" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LYS  49   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: LYS,49,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    614.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ASP  65   N    )  65  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "65" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ASP  65   N    )  ASP 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "ASP" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ASP  65   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: ASP,65,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    623.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLU  66   N    )  66  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "66" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLU  66   N    )  GLU 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "GLU" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLU  66   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: GLU,66,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    653.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  69   N    )  69  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "69" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  69   N    )  VAL 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "VAL" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  69   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: VAL,69,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    661.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    MET  70   N    )  70  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "70" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    MET  70   N    )  MET 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "MET" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    MET  70   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: MET,70,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    731.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  78   N    )  78  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "78" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  78   N    )  VAL 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "VAL" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  78   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: VAL,78,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    739.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    CYS  79   N    )  79  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "79" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    CYS  79   N    )  CYS 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "CYS" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    CYS  79   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: CYS,79,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    847.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLN  91   N    )  91  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "91" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLN  91   N    )  GLN 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "GLN" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLN  91   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: GLN,91,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    859.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  92   N    )  92  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "92" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  92   N    )  LEU 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "LEU" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  92   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: LEU,92,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    868.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ILE  93   N    )  93  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "93" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ILE  93   N    )  ILE 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "ILE" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ILE  93   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: ILE,93,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    877.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    THR  94   N    )  94  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "94" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    THR  94   N    )  THR 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "THR" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    THR  94   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: THR,94,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    886.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLN  95   N    )  95  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "95" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLN  95   N    )  GLN 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "GLN" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLN  95   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: GLN,95,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    898.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  96   N    )  96  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "96" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  96   N    )  LEU 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "LEU" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  96   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: LEU,96,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    907.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    MET  97   N    )  97  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "97" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    MET  97   N    )  MET 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "MET" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    MET  97   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: MET,97,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    916.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    PRO  98   N    )  98  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "98" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    PRO  98   N    )  PRO 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "PRO" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    PRO  98   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: PRO,98,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    923.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    PHE  99   N    )  99  
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "99" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    PHE  99   N    )  PHE 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "PHE" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    PHE  99   N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: PHE,99,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    935.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLY  100  N    )  100 
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "100" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLY  100  N    )  GLY 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "GLY" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLY  100  N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: GLY,100,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    940.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    CYS  101  N    )  101 
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "101" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    CYS  101  N    )  CYS 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "CYS" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    CYS  101  N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: CYS,101,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    957.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  103  N    )  103 
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "103" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  103  N    )  LEU 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "LEU" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  103  N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: LEU,103,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    966.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ASP  104  N    )  104 
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "104" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ASP  104  N    )  ASP 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "ASP" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ASP  104  N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: ASP,104,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    997.000     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ARG  107  N    )  107 
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "107" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ARG  107  N    )  ARG 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "ARG" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ARG  107  N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: ARG,107,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    1014.00     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLU  108  N    )  108 
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "108" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLU  108  N    )  GLU 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "GLU" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    GLU  108  N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: GLU,108,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    1423.00     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  147  N    )  147 
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "147" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  147  N    )  VAL 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "VAL" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    VAL  147  N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: VAL,147,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    1431.00     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  148  N    )  148 
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "148" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  148  N    )  LEU 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "LEU" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    LEU  148  N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: LEU,148,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    1522.00     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ILE  157  N    )  157 
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "157" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ILE  157  N    )  ILE 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "ILE" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ILE  157  N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: ILE,157,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    1531.00     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    THR  158  N    )  158 
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "158" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    THR  158  N    )  THR 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "THR" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    THR  158  N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: THR,158,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 FOR ID LOOP: symbol ID set to    1540.00     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ASP  159  N    )  159 
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "159" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ASP  159  N    )  ASP 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "ASP" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( A    ASP  159  N    )  A   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "A" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: ASP,159,A
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = $result) 
 CNSsolve>    show (resn) (id $id) 
 CNSsolve>    evaluate ($nares = $result) 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($seres = $result) 
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
 CNSsolve>end loop flexres2 
 CNSsolve> 
 CNSsolve>    else 
 CNSsolve>      display FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>      while ($fcounter < $Toppar.nseg_$nchain1) loop Xflex 
 CNSsolve>        evaluate($fcounter=$fcounter + 1) 
 CNSsolve>        do (store5 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>        display FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>      end loop Xflex 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>  evaluate($fcounter=0) 
 EVALUATE: symbol $FCOUNTER set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>  if ($Toppar.nseg_$nchain1 = 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    display NO FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    if ($Toppar.nseg_$nchain1 < 0) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      display AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE $nchain1 
AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE 2
 CNSsolve>      inline  
 CNSsolve>! flexauto-neighbors.cns 
 CNSsolve>!    Automatic definition of flexible segments for docking for contacting residues 
 CNSsolve>!    including neighboring residues of residues making contacts 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($flcut = 5.0) 
 EVALUATE: symbol $FLCUT set to    5.00000     (real)
 CNSsolve> 
 CNSsolve>do (store5 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 SELRPN>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 SELRPN:     37 atoms have been selected out of   3007
 CNSsolve>do (store7 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 SELRPN>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 SELRPN:     37 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>do (store6 = 0) (segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     37 atoms have been selected out of   3007
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 SELRPN:      1 atoms have been selected out of   3007
 FOR ID LOOP: symbol ID set to    2971.00     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( B    AEE  1    CAQ  )  1   
 CNSsolve>    evaluate ($inres = decode($result)) 
 EVALUATE: symbol $INRES set to    1.00000     (real)
 CNSsolve>    evaluate ($preres = $inres) 
 EVALUATE: symbol $PRERES set to    1.00000     (real)
 CNSsolve>    evaluate ($nexres = $inres) 
 EVALUATE: symbol $NEXRES set to    1.00000     (real)
 CNSsolve>    if ($iteration = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>      evaluate ($preres = $preres - 1) 
 EVALUATE: symbol $PRERES set to    0.00000     (real)
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     37 atoms have been selected out of   3007
 CNSsolve>end loop flexres1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = decode($result)) 
 CNSsolve>    evaluate ($preres = $inres) 
 CNSsolve>    evaluate ($nexres = $inres) 
 CNSsolve>    if ($iteration = 1) then 
 CNSsolve>      evaluate ($preres = $preres - 1) 
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>end loop flexres1 
 CNSsolve> 
 CNSsolve>do (store5 = store6) (segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     37 atoms have been selected out of   3007
 CNSsolve>do (store7 = store6) (segid $Toppar.prot_segid_$nchain1) 
 SELRPN:     37 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>display THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule $nchain1 
THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule 2
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 SELRPN:      1 atoms have been selected out of   3007
 FOR ID LOOP: symbol ID set to    2971.00     (real)
 CNSsolve>    show (resid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( B    AEE  1    CAQ  )  1   
 CNSsolve>    evaluate ($inres = $result) 
 EVALUATE: symbol $INRES set to "1" (string)
 CNSsolve>    show (resn) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( B    AEE  1    CAQ  )  AEE 
 CNSsolve>    evaluate ($nares = $result) 
 EVALUATE: symbol $NARES set to "AEE" (string)
 CNSsolve>    show (segid) (id $id) 
 SELRPN:      1 atoms have been selected out of   3007
 ( B    AEE  1    CAQ  )  B   
 CNSsolve>    evaluate ($seres = $result) 
 EVALUATE: symbol $SERES set to "B" (string)
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
AUTOMATICALLY SELECTED SEGMENT: AEE,1,B
 CNSsolve>end loop flexres2 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = $result) 
 CNSsolve>    show (resn) (id $id) 
 CNSsolve>    evaluate ($nares = $result) 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($seres = $result) 
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
 CNSsolve>end loop flexres2 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    else 
 CNSsolve>      display FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>      while ($fcounter < $Toppar.nseg_$nchain1) loop Xflex 
 CNSsolve>        evaluate($fcounter=$fcounter + 1) 
 CNSsolve>        do (store5 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>        display FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>      end loop Xflex 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  evaluate($fcounter=0) 
 CNSsolve> 
 CNSsolve>  if ($Toppar.nseg_$nchain1 = 0) then 
 CNSsolve>    display NO FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    if ($Toppar.nseg_$nchain1 < 0) then 
 CNSsolve>      display AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE $nchain1 
 CNSsolve>      inline  
 CNSsolve>! flexauto-neighbors.cns 
 CNSsolve>!    Automatic definition of flexible segments for docking for contacting residues 
 CNSsolve>!    including neighboring residues of residues making contacts 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($flcut = 5.0) 
 CNSsolve> 
 CNSsolve>do (store5 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve>do (store7 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve> 
 CNSsolve>do (store6 = 0) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = decode($result)) 
 CNSsolve>    evaluate ($preres = $inres) 
 CNSsolve>    evaluate ($nexres = $inres) 
 CNSsolve>    if ($iteration = 1) then 
 CNSsolve>      evaluate ($preres = $preres - 1) 
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>end loop flexres1 
 CNSsolve> 
 CNSsolve>do (store5 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>do (store7 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve> 
 CNSsolve>display THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule $nchain1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = $result) 
 CNSsolve>    show (resn) (id $id) 
 CNSsolve>    evaluate ($nares = $result) 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($seres = $result) 
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
 CNSsolve>end loop flexres2 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    else 
 CNSsolve>      display FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>      while ($fcounter < $Toppar.nseg_$nchain1) loop Xflex 
 CNSsolve>        evaluate($fcounter=$fcounter + 1) 
 CNSsolve>        do (store5 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>        display FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>      end loop Xflex 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>!then fully flexible segments for all stages 
 CNSsolve>evaluate($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
NO FULLY FLEXIBLE SEGMENTS for molecule 1
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop2 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
NO FULLY FLEXIBLE SEGMENTS for molecule 2
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop2 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop2 
 CNSsolve> 
 CNSsolve>do (store5 = 7) ((resn WAT or resn HOH or resn TIP*)) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>evaluate ($nfletot = 0) 
 EVALUATE: symbol $NFLETOT set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>! check number of flexible residues per molecule 
 CNSsolve>evaluate($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop3 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>  do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store6 = 1) (tag and (attr store5 = $nchain1)) 
 SELRPN:     34 atoms have been selected out of   3007
 CNSsolve>  show sum (store6) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =      34.000000
 CNSsolve>  evaluate ($numfle=$result) 
 EVALUATE: symbol $NUMFLE set to    34.0000     (real)
 CNSsolve>  do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not (attr store5 = $nchain1)) 
 SELRPN:    272 atoms have been selected out of   3007
 CNSsolve>  show sum (store6) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =     272.000000
 CNSsolve>  evaluate ($numrig=$result) 
 EVALUATE: symbol $NUMRIG set to    272.000     (real)
 CNSsolve>  do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:    306 atoms have been selected out of   3007
 CNSsolve>  show sum (store6) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =     306.000000
 CNSsolve>  evaluate ($numres=$result) 
 EVALUATE: symbol $NUMRES set to    306.000     (real)
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
FLEXIBILITY STATISTIC FOR MOLECULE 1 : Nres=306 Nrigid=272 Nflex=34
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 EVALUATE: symbol $NFLETOT set to    34.0000     (real)
 CNSsolve>end loop nloop3 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop3 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>  do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store6 = 1) (tag and (attr store5 = $nchain1)) 
 SELRPN:      1 atoms have been selected out of   3007
 CNSsolve>  show sum (store6) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =       1.000000
 CNSsolve>  evaluate ($numfle=$result) 
 EVALUATE: symbol $NUMFLE set to    1.00000     (real)
 CNSsolve>  do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not (attr store5 = $nchain1)) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>  show sum (store6) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =       0.000000
 CNSsolve>  evaluate ($numrig=$result) 
 EVALUATE: symbol $NUMRIG set to    0.00000     (real)
 CNSsolve>  do (store6 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 SELRPN:      1 atoms have been selected out of   3007
 CNSsolve>  show sum (store6) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =       1.000000
 CNSsolve>  evaluate ($numres=$result) 
 EVALUATE: symbol $NUMRES set to    1.00000     (real)
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
FLEXIBILITY STATISTIC FOR MOLECULE 2 : Nres=1 Nrigid=0 Nflex=1
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 EVALUATE: symbol $NFLETOT set to    35.0000     (real)
 CNSsolve>end loop nloop3 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop3 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and (attr store5 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numfle=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not (attr store5 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numrig=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numres=$result) 
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 CNSsolve>end loop nloop3 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 SELRPN:      0 atoms have been selected out of   3007
 SHOW: zero atoms selected
 CNSsolve>evaluate ($nfletot = $nfletot + $result) 
 EVALUATE: symbol $NFLETOT set to    35.0000     (real)
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = $nfletot + 10) 
 EVALUATE: symbol $NFLETOT set to    45.0000     (real)
 CNSsolve> 
 CNSsolve>  fix sele=((attr store5 = 0 or name OO) and not name H* and not (resn WAT or resn HOH or resn TIP* or resn XAN)) end 
 SELRPN:   2186 atoms have been selected out of   3007
 CNSsolve>  minimize powell nstep=200 drop=10.0 nprint=25 end 
 POWELL: number of degrees of freedom=  2463
 --------------- cycle=    25 ------ stepsize=    0.0000 -----------------------
 | Etotal =27772.167  grad(E)=129.985    E(BOND)=305.549    E(ANGL)=1384.297   |
 | E(DIHE)=1756.688   E(IMPR)=25129.165  E(VDW )=261.845    E(ELEC)=-1106.484  |
 | E(HARM)=0.000      E(NOE )=41.106                                           |
 -------------------------------------------------------------------------------
 --------------- cycle=    50 ------ stepsize=    0.0000 -----------------------
 | Etotal =27691.853  grad(E)=129.783    E(BOND)=302.361    E(ANGL)=1357.432   |
 | E(DIHE)=1748.338   E(IMPR)=25128.440  E(VDW )=220.262    E(ELEC)=-1106.119  |
 | E(HARM)=0.000      E(NOE )=41.139                                           |
 -------------------------------------------------------------------------------
 NBONDS: found   210472 intra-atom interactions
 --------------- cycle=    75 ------ stepsize=    0.0000 -----------------------
 | Etotal =27656.283  grad(E)=129.802    E(BOND)=298.037    E(ANGL)=1345.529   |
 | E(DIHE)=1749.262   E(IMPR)=25123.974  E(VDW )=204.226    E(ELEC)=-1105.901  |
 | E(HARM)=0.000      E(NOE )=41.157                                           |
 -------------------------------------------------------------------------------
 --------------- cycle=   100 ------ stepsize=    0.0000 -----------------------
 | Etotal =27632.136  grad(E)=129.757    E(BOND)=295.502    E(ANGL)=1337.069   |
 | E(DIHE)=1749.651   E(IMPR)=25121.075  E(VDW )=193.327    E(ELEC)=-1105.658  |
 | E(HARM)=0.000      E(NOE )=41.170                                           |
 -------------------------------------------------------------------------------
 --------------- cycle=   125 ------ stepsize=    0.0000 -----------------------
 | Etotal =27610.035  grad(E)=129.781    E(BOND)=295.999    E(ANGL)=1330.291   |
 | E(DIHE)=1750.039   E(IMPR)=25118.536  E(VDW )=179.451    E(ELEC)=-1105.464  |
 | E(HARM)=0.000      E(NOE )=41.184                                           |
 -------------------------------------------------------------------------------
 --------------- cycle=   150 ------ stepsize=    0.0000 -----------------------
 | Etotal =27592.407  grad(E)=129.761    E(BOND)=295.514    E(ANGL)=1327.835   |
 | E(DIHE)=1750.355   E(IMPR)=25116.885  E(VDW )=165.739    E(ELEC)=-1105.124  |
 | E(HARM)=0.000      E(NOE )=41.203                                           |
 -------------------------------------------------------------------------------
 NBONDS: found   210462 intra-atom interactions
 --------------- cycle=   175 ------ stepsize=    0.0000 -----------------------
 | Etotal =27579.011  grad(E)=129.760    E(BOND)=294.686    E(ANGL)=1323.319   |
 | E(DIHE)=1749.815   E(IMPR)=25114.594  E(VDW )=160.283    E(ELEC)=-1104.904  |
 | E(HARM)=0.000      E(NOE )=41.219                                           |
 -------------------------------------------------------------------------------
 --------------- cycle=   200 ------ stepsize=    0.0000 -----------------------
 | Etotal =27564.655  grad(E)=129.764    E(BOND)=294.126    E(ANGL)=1319.134   |
 | E(DIHE)=1749.218   E(IMPR)=25112.228  E(VDW )=153.077    E(ELEC)=-1104.377  |
 | E(HARM)=0.000      E(NOE )=41.249                                           |
 -------------------------------------------------------------------------------
 POWELL: STEP number limit. Normal termination
 POWELL: Current coordinates set to last minimum
 CNSsolve>  fix sele=(not all) end 
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve>  energy end 
 --------------- cycle=     5 --------------------------------------------------
 | Etotal =27564.655  grad(E)=129.764    E(BOND)=294.126    E(ANGL)=1319.134   |
 | E(DIHE)=1749.218   E(IMPR)=25112.228  E(VDW )=153.077    E(ELEC)=-1104.377  |
 | E(HARM)=0.000      E(NOE )=41.249                                           |
 -------------------------------------------------------------------------------
 CNSsolve> 
 CNSsolve>  if ($nlcount = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    coor swap end 
 COOR: selected coordinates swaped (main<->comp)
 CNSsolve>    if ($torsiondone eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      if ($failure eq false) then 
 CNSsolve>        dyna tors topo reset end end 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>end loop rotloop1 
 CNSsolve>while ($nlcount < $rotiter) loop rotloop1 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>  evaluate ($nlcount = $nlcount + 1) 
 CNSsolve> 
 CNSsolve>  evaluate ($unamb_scale = $Data.unamb_hot) 
 CNSsolve>  evaluate ($ambig_scale = $Data.amb_hot) 
 CNSsolve>  evaluate ($hbond_scale = $Data.hbond_hot) 
 CNSsolve> 
 CNSsolve>  noe 
 CNSsolve>    scale dist $unamb_scale 
 CNSsolve>    scale ambi $ambig_scale 
 CNSsolve>    scale hbon $hbond_scale 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  if ($Data.flags.dihed eq true) then 
 CNSsolve>    flag include dihed end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.scaling eq TRUE) then 
 CNSsolve>    inline  
 CNSsolve>! set_noe_scale.cns 
 CNSsolve>!    Set the distance restraint force constant 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($enoe   = 0.0 ) 
 CNSsolve>evaluate ($vdw    = 0.0 ) 
 CNSsolve>evaluate ($elec   = 0.0 ) 
 CNSsolve>evaluate ($einter = 0.0 ) 
 CNSsolve>evaluate ($noescale = 1.0 ) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym ne true) then 
 CNSsolve>  print threshold=0.5 noe 
 CNSsolve>  evaluate ($numnoe=$violations) 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_amb > 0) then 
 CNSsolve>    evaluate ($ambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_amb)))) 
 CNSsolve>    if ($ambcorr = 0) then 
 CNSsolve>      evaluate ($ambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($ambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_unamb > 0) then 
 CNSsolve>    evaluate ($unambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_unamb)))) 
 CNSsolve>    if ($unambcorr = 0) then 
 CNSsolve>      evaluate ($unambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($unambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve>else 
 CNSsolve>  evaluate ($unambcorr = 1) 
 CNSsolve>  evaluate ($ambcorr = 1) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>eval ($nchain1 = 0) 
 CNSsolve>igroup 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction  (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                   (segid $Toppar.prot_segid_$nchain2) weights * 1 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>  end loop nloop1 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>energy end 
 CNSsolve>igroup 
 CNSsolve>    interaction  (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($einter = abs($vdw + $elec)) 
 CNSsolve>evaluate ($enoe   = $noe) 
 CNSsolve> 
 CNSsolve>if ($enoe ne 0) then 
 CNSsolve>  evaluate ($noescale = min(5000, (2 * $einter / $enoe))) 
 CNSsolve>  if ($noescale ne 0) then 
 CNSsolve>    evaluate ($Data.unamb_hot   = $Data.unamb_hot   * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_hot     = $Data.amb_hot     * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool1 = $Data.unamb_cool1 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool1   = $Data.amb_cool1   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool2 = $Data.unamb_cool2 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool2   = $Data.amb_cool2   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool3 = $Data.unamb_cool3 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool3   = $Data.amb_cool3   * $noescale * $ambcorr) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    energy end 
 CNSsolve>    noe 
 CNSsolve>      scale dist $Data.unamb_hot 
 CNSsolve>      scale ambi $Data.amb_hot 
 CNSsolve>    end 
 CNSsolve>    energy end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.flags.sani eq true) then 
 CNSsolve>    sani class rdc1 force $Data.rdc1_hot end 
 CNSsolve>    sani class rdc2 force $Data.rdc2_hot end 
 CNSsolve>    sani class rdc3 force $Data.rdc3_hot end 
 CNSsolve>    sani class rdc4 force $Data.rdc4_hot end 
 CNSsolve>    sani class rdc5 force $Data.rdc5_hot end 
 CNSsolve>    if ($rantens eq true) then 
 CNSsolve>       
 CNSsolve>! mini_tensor.cns 
 CNSsolve>!    Optimize the RDC tensor orientation 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{* Optimize tensor orientation *} 
 CNSsolve> 
 CNSsolve>{* first randomize the tensor orientation because of some CNS problems *} 
 CNSsolve>{* possible resulting in infinite gradient and a failure of the EM     *} 
 CNSsolve> 
 CNSsolve>eval ($erdc = 999999999.0) 
 CNSsolve>eval ($ncount = 0) 
 CNSsolve>while ($ncount < 4) loop trial 
 CNSsolve>  eval ($ncount = $ncount + 1) 
 CNSsolve>  do (xcomp = x) (resn ANI) 
 CNSsolve>  do (ycomp = y) (resn ANI) 
 CNSsolve>  do (zcomp = z) (resn ANI) 
 CNSsolve> 
 CNSsolve>  !random rotation of tensor 
 CNSsolve> 
 CNSsolve>  show aver (x) (resn ANI) 
 CNSsolve>  evaluate ($xc = $result) 
 CNSsolve>  show aver (y) (resn ANI) 
 CNSsolve>  evaluate ($yc = $result) 
 CNSsolve>  show aver (z) (resn ANI) 
 CNSsolve>  evaluate ($zc = $result) 
 CNSsolve> 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  {* rotate around z axis *} 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = -sin($xr)) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = sin($xr)) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = 1 ) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn ANI) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  {* rotate around x axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = 1 ) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = -sin($xr)) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = sin($xr)) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn ANI) 
 CNSsolve>  end 
 CNSsolve>  {* rotate around y axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = -sin($xr)) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = 1 ) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = sin($xr)) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn ANI) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  energy end 
 CNSsolve> 
 CNSsolve>  if ($ncount = 1) then 
 CNSsolve>    eval ($erdc=$sani) 
 CNSsolve>  end if 
 CNSsolve>  if ($sani < $erdc) then 
 CNSsolve>    eval ($erdc=$sani) 
 CNSsolve>    do (xcomp = x) (resn ANI) 
 CNSsolve>    do (ycomp = y) (resn ANI) 
 CNSsolve>    do (zcomp = z) (resn ANI) 
 CNSsolve>  else 
 CNSsolve>    do (x = xcomp) (resn ANI) 
 CNSsolve>    do (y = ycomp) (resn ANI) 
 CNSsolve>    do (z = zcomp) (resn ANI) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>end loop trial 
 CNSsolve> 
 CNSsolve>fix sele=(not all) end 
 CNSsolve>fix sele=(name OO) end 
 CNSsolve>minimize rigid 
 CNSsolve>  group (not resn ANI) 
 CNSsolve>  translation=false 
 CNSsolve>  for $id in id (resn ANI and name OO) loop miniani 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop miniani 
 CNSsolve>  translation=false 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve>minimize rigid 
 CNSsolve>  eval($nchain1= 1) 
 CNSsolve>  while ($nchain1 <= $data.ncomponents) loop cloop1 
 CNSsolve>    group (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    translation=false 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>  end loop cloop1 
 CNSsolve>  for $id in id (resn ANI and name OO) loop miniani 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop miniani 
 CNSsolve>  translation=false 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.flags.xrdc eq true) then 
 CNSsolve>    xrdc class rdc1 force $Data.rdc1_hot end 
 CNSsolve>    xrdc class rdc2 force $Data.rdc2_hot end 
 CNSsolve>    xrdc class rdc3 force $Data.rdc3_hot end 
 CNSsolve>    xrdc class rdc4 force $Data.rdc4_hot end 
 CNSsolve>    xrdc class rdc5 force $Data.rdc5_hot end 
 CNSsolve>    if ($rantens_para eq true) then 
 CNSsolve>       
 CNSsolve>! mini_tensor_para.cns 
 CNSsolve>!    Optimize the tensor orientation for PCS restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>!set message on echo on end 
 CNSsolve> 
 CNSsolve>display STARTing mini_tensor_para.cns 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="trial.pdb" end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{* minimize tensor position *} 
 CNSsolve>display STARTing minimization of OO-LA distance 
 CNSsolve> 
 CNSsolve>!flag excl * include noe end 
 CNSsolve>flag excl xpcs include noe end 
 CNSsolve>fix sele=(not resn XAN) end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve>  interaction (not all) (not all) 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>minimize rigid 
 CNSsolve>  group (resname XAN) 
 CNSsolve>  translation=true 
 CNSsolve>  nstep 1000 
 CNSsolve>  tole 0.1 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="position.pdb" end 
 CNSsolve> 
 CNSsolve>display ENDing minimization of OO-LA distance 
 CNSsolve> 
 CNSsolve>display STARTing minimization of orientation 
 CNSsolve> 
 CNSsolve>{* minimize tensor orientation *} 
 CNSsolve> 
 CNSsolve>evaluate ($protocol = 0) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($protocol = 0) then {* powell minimization protocol together *} 
 CNSsolve> 
 CNSsolve>  display protocol 0 
 CNSsolve>!  flag excl * include noe xpcs bond end 
 CNSsolve>  flag  include noe xpcs bond end 
 CNSsolve> 
 CNSsolve>  igroup 
 CNSsolve>    interaction (not all) (not all) 
 CNSsolve>    interaction ( resn XAN ) ( resn XAN ) weight * 0 bond 1.0 end 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  fix sele=(not (resn XAN)) end 
 CNSsolve> 
 CNSsolve>  minimize powell 
 CNSsolve>    nstep=5000 
 CNSsolve>    drop=10 
 CNSsolve>    nprint=10 
 CNSsolve>    tolgradient=0.01 
 CNSsolve>  end 
 CNSsolve>elseif ($protocol = 1) then {* powell minimization protocol *} 
 CNSsolve> 
 CNSsolve>  display protocol 1 
 CNSsolve>  flag excl * include noe xpcs bond end 
 CNSsolve> 
 CNSsolve>  for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>    igroup 
 CNSsolve>      interaction (not all) (not all) 
 CNSsolve>      interaction ( (byres(id $id)) ) ( (byres(id $id)) ) weight * 0 bond 1.0 end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    fix sele=(not ( (byres(id $id)) )) end 
 CNSsolve> 
 CNSsolve>    minimize powell 
 CNSsolve>      nstep=500 
 CNSsolve>      drop=10 
 CNSsolve>      nprint=10 
 CNSsolve>      tolgradient=0.01 
 CNSsolve>    end 
 CNSsolve>  end loop miniani 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 4) then {* powell minimization protocol simultaneously *} 
 CNSsolve> 
 CNSsolve>  display protocol 4 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve> 
 CNSsolve>  fix sele=(not ( resname XAN )) end 
 CNSsolve> 
 CNSsolve>  minimize powell 
 CNSsolve>    nstep=5000 
 CNSsolve>    drop=10 
 CNSsolve>    nprint=10 
 CNSsolve>    tolgradient=0.01 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 2) then  {* rigid body minimization protocol *} 
 CNSsolve> 
 CNSsolve>  display protocol 2 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve>  for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>    minimize rigid 
 CNSsolve>      group (byres(id $id)) 
 CNSsolve>      translation=true 
 CNSsolve>      nstep 500 
 CNSsolve>      nprint 10 
 CNSsolve>      drop=10 
 CNSsolve>    end 
 CNSsolve>  end loop miniani 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 3) then {* original rigid body minimization protocol *} 
 CNSsolve>  display protocol 3 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve>  fix sele=(not resname XAN) end 
 CNSsolve>  minimize rigid 
 CNSsolve>    group (not resname XAN) 
 CNSsolve>    translation=true 
 CNSsolve>    for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>      group (byres(id $id)) 
 CNSsolve>      translation=true 
 CNSsolve>    end loop miniani 
 CNSsolve>    translation=true 
 CNSsolve>    nstep 5000 
 CNSsolve> 
 CNSsolve>    nprint 10 
 CNSsolve>  end 
 CNSsolve>  display XPCS_ENERGY $xpcs 
 CNSsolve>  fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>!xpcs print thresh=0.0 class pcs1 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs2 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs3 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs4 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs5 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs6 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs7 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs8 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs9 end 
 CNSsolve>!xpcs print thresh=0.0 class pcsA end 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="min.pdb" end 
 CNSsolve> 
 CNSsolve>display ENDing minimization of orientation 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.flags.xpcs eq true) then 
 CNSsolve>    xpcs class pcs1 force $Data.pcs1_hot end 
 CNSsolve>    xpcs class pcs2 force $Data.pcs2_hot end 
 CNSsolve>    xpcs class pcs3 force $Data.pcs3_hot end 
 CNSsolve>    xpcs class pcs4 force $Data.pcs4_hot end 
 CNSsolve>    xpcs class pcs5 force $Data.pcs5_hot end 
 CNSsolve>    xpcs class pcs6 force $Data.pcs6_hot end 
 CNSsolve>    xpcs class pcs7 force $Data.pcs7_hot end 
 CNSsolve>    xpcs class pcs8 force $Data.pcs8_hot end 
 CNSsolve>    xpcs class pcs9 force $Data.pcs9_hot end 
 CNSsolve>    xpcs class pcsA force $Data.pcsA_hot end 
 CNSsolve>    !if ($rantens_para eq true) then 
 CNSsolve>       
 CNSsolve>! mini_tensor_para.cns 
 CNSsolve>!    Optimize the tensor orientation for PCS restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>!set message on echo on end 
 CNSsolve> 
 CNSsolve>display STARTing mini_tensor_para.cns 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="trial.pdb" end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{* minimize tensor position *} 
 CNSsolve>display STARTing minimization of OO-LA distance 
 CNSsolve> 
 CNSsolve>!flag excl * include noe end 
 CNSsolve>flag excl xpcs include noe end 
 CNSsolve>fix sele=(not resn XAN) end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve>  interaction (not all) (not all) 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>minimize rigid 
 CNSsolve>  group (resname XAN) 
 CNSsolve>  translation=true 
 CNSsolve>  nstep 1000 
 CNSsolve>  tole 0.1 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="position.pdb" end 
 CNSsolve> 
 CNSsolve>display ENDing minimization of OO-LA distance 
 CNSsolve> 
 CNSsolve>display STARTing minimization of orientation 
 CNSsolve> 
 CNSsolve>{* minimize tensor orientation *} 
 CNSsolve> 
 CNSsolve>evaluate ($protocol = 0) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($protocol = 0) then {* powell minimization protocol together *} 
 CNSsolve> 
 CNSsolve>  display protocol 0 
 CNSsolve>!  flag excl * include noe xpcs bond end 
 CNSsolve>  flag  include noe xpcs bond end 
 CNSsolve> 
 CNSsolve>  igroup 
 CNSsolve>    interaction (not all) (not all) 
 CNSsolve>    interaction ( resn XAN ) ( resn XAN ) weight * 0 bond 1.0 end 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  fix sele=(not (resn XAN)) end 
 CNSsolve> 
 CNSsolve>  minimize powell 
 CNSsolve>    nstep=5000 
 CNSsolve>    drop=10 
 CNSsolve>    nprint=10 
 CNSsolve>    tolgradient=0.01 
 CNSsolve>  end 
 CNSsolve>elseif ($protocol = 1) then {* powell minimization protocol *} 
 CNSsolve> 
 CNSsolve>  display protocol 1 
 CNSsolve>  flag excl * include noe xpcs bond end 
 CNSsolve> 
 CNSsolve>  for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>    igroup 
 CNSsolve>      interaction (not all) (not all) 
 CNSsolve>      interaction ( (byres(id $id)) ) ( (byres(id $id)) ) weight * 0 bond 1.0 end 
 CNSsolve>    end 
 CNSsolve> 
 CNSsolve>    fix sele=(not ( (byres(id $id)) )) end 
 CNSsolve> 
 CNSsolve>    minimize powell 
 CNSsolve>      nstep=500 
 CNSsolve>      drop=10 
 CNSsolve>      nprint=10 
 CNSsolve>      tolgradient=0.01 
 CNSsolve>    end 
 CNSsolve>  end loop miniani 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 4) then {* powell minimization protocol simultaneously *} 
 CNSsolve> 
 CNSsolve>  display protocol 4 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve> 
 CNSsolve>  fix sele=(not ( resname XAN )) end 
 CNSsolve> 
 CNSsolve>  minimize powell 
 CNSsolve>    nstep=5000 
 CNSsolve>    drop=10 
 CNSsolve>    nprint=10 
 CNSsolve>    tolgradient=0.01 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 2) then  {* rigid body minimization protocol *} 
 CNSsolve> 
 CNSsolve>  display protocol 2 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve>  for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>    minimize rigid 
 CNSsolve>      group (byres(id $id)) 
 CNSsolve>      translation=true 
 CNSsolve>      nstep 500 
 CNSsolve>      nprint 10 
 CNSsolve>      drop=10 
 CNSsolve>    end 
 CNSsolve>  end loop miniani 
 CNSsolve> 
 CNSsolve>elseif ($protocol = 3) then {* original rigid body minimization protocol *} 
 CNSsolve>  display protocol 3 
 CNSsolve>  flag excl * include noe xpcs end 
 CNSsolve>  fix sele=(not resname XAN) end 
 CNSsolve>  minimize rigid 
 CNSsolve>    group (not resname XAN) 
 CNSsolve>    translation=true 
 CNSsolve>    for $id in id (resn XAN and name OO) loop miniani 
 CNSsolve>      group (byres(id $id)) 
 CNSsolve>      translation=true 
 CNSsolve>    end loop miniani 
 CNSsolve>    translation=true 
 CNSsolve>    nstep 5000 
 CNSsolve> 
 CNSsolve>    nprint 10 
 CNSsolve>  end 
 CNSsolve>  display XPCS_ENERGY $xpcs 
 CNSsolve>  fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>fix sele=(not all) end 
 CNSsolve> 
 CNSsolve>!xpcs print thresh=0.0 class pcs1 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs2 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs3 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs4 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs5 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs6 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs7 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs8 end 
 CNSsolve>!xpcs print thresh=0.0 class pcs9 end 
 CNSsolve>!xpcs print thresh=0.0 class pcsA end 
 CNSsolve> 
 CNSsolve>!write coordinates sele=(resn XAN) output="min.pdb" end 
 CNSsolve> 
 CNSsolve>display ENDing minimization of orientation 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    !end if 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.flags.dani eq true) then 
 CNSsolve>      dani class dan1 force $Data.dan1_hot end 
 CNSsolve>      dani class dan2 force $Data.dan2_hot end 
 CNSsolve>      dani class dan3 force $Data.dan3_hot end 
 CNSsolve>      dani class dan4 force $Data.dan4_hot end 
 CNSsolve>      dani class dan5 force $Data.dan5_hot end 
 CNSsolve>      if ($rantens_dani eq true) then 
 CNSsolve>        
 CNSsolve>! mini_tensor_dani.cns 
 CNSsolve>!    Optimize the tensor orientation for diffusion anisotropy restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>{* Optimize tensor orientation *} 
 CNSsolve>{* ADJ van Dijk*} 
 CNSsolve>{* copied from mini_tensor.cns *} 
 CNSsolve> 
 CNSsolve>{* first randomize the tensor orientation because of some CNS problems *} 
 CNSsolve>{* possible resulting in infinite gradient and a failure of the EM     *} 
 CNSsolve> 
 CNSsolve>eval ($edani = 999999999.0) 
 CNSsolve>eval ($ncount = 0) 
 CNSsolve>while ($ncount < 4) loop trial 
 CNSsolve>  eval ($ncount = $ncount + 1) 
 CNSsolve>  do (xcomp = x) (resn DAN) 
 CNSsolve>  do (ycomp = y) (resn DAN) 
 CNSsolve>  do (zcomp = z) (resn DAN) 
 CNSsolve> 
 CNSsolve>  !random rotation of tensor 
 CNSsolve> 
 CNSsolve>  show aver (x) (resn DAN) 
 CNSsolve>  evaluate ($xc = $result) 
 CNSsolve>  show aver (y) (resn DAN) 
 CNSsolve>  evaluate ($yc = $result) 
 CNSsolve>  show aver (z) (resn DAN) 
 CNSsolve>  evaluate ($zc = $result) 
 CNSsolve> 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  {* rotate around z axis *} 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = -sin($xr)) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = sin($xr)) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = 1 ) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn DAN) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  {* rotate around x axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = 1 ) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = 0 ) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = cos($xr)) 
 CNSsolve>  evaluate ($y3 = -sin($xr)) 
 CNSsolve>  evaluate ($z1 = 0 ) 
 CNSsolve>  evaluate ($z2 = sin($xr)) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn DAN) 
 CNSsolve>  end 
 CNSsolve>  {* rotate around y axis *} 
 CNSsolve>  evaluate ($xr = ran ()) 
 CNSsolve>  evaluate ($xr = $xr * 360) 
 CNSsolve>  evaluate ($x1 = cos($xr)) 
 CNSsolve>  evaluate ($x2 = 0 ) 
 CNSsolve>  evaluate ($x3 = -sin($xr)) 
 CNSsolve>  evaluate ($y1 = 0 ) 
 CNSsolve>  evaluate ($y2 = 1 ) 
 CNSsolve>  evaluate ($y3 = 0 ) 
 CNSsolve>  evaluate ($z1 = sin($xr)) 
 CNSsolve>  evaluate ($z2 = 0 ) 
 CNSsolve>  evaluate ($z3 = cos($xr)) 
 CNSsolve>  coor 
 CNSsolve>    center=($xc $yc $zc) 
 CNSsolve>    rotate matrix=($x1 $x2 $x3) ($y1 $y2 $y3) ($z1 $z2 $z3) 
 CNSsolve>    sele=(resn DAN) 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  energy end 
 CNSsolve> 
 CNSsolve>  if ($ncount = 1) then 
 CNSsolve>    eval ($edani=$dani) 
 CNSsolve>  end if 
 CNSsolve>  if ($dani < $edani) then 
 CNSsolve>    eval ($edani=$dani) 
 CNSsolve>    do (xcomp = x) (resn DAN) 
 CNSsolve>    do (ycomp = y) (resn DAN) 
 CNSsolve>    do (zcomp = z) (resn DAN) 
 CNSsolve>  else 
 CNSsolve>    do (x = xcomp) (resn DAN) 
 CNSsolve>    do (y = ycomp) (resn DAN) 
 CNSsolve>    do (z = zcomp) (resn DAN) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>end loop trial 
 CNSsolve> 
 CNSsolve>fix sele=(not all) end 
 CNSsolve>fix sele=(name OO) end 
 CNSsolve>minimize rigid 
 CNSsolve>  group (not resn DAN) 
 CNSsolve>  translation=false 
 CNSsolve>  for $id in id (resn DAN and name OO) loop minidan 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop minidan 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve>minimize rigid 
 CNSsolve>  eval($nchain1= 1) 
 CNSsolve>  while ($nchain1 <= $data.ncomponents) loop cloop1 
 CNSsolve>    group (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop cloop1 
 CNSsolve>  for $id in id (resn DAN and name OO) loop minidan 
 CNSsolve>    group (byres(id $id)) 
 CNSsolve>    translation=false 
 CNSsolve>  end loop minidan 
 CNSsolve>  nstep 500 
 CNSsolve>  nprint 10 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      end if 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  if ($nlcount = 2) then 
 CNSsolve> 
 CNSsolve>    flag excl bond angl dihe impr end 
 CNSsolve> 
 CNSsolve>    evaluate ($kinter = $SaProtocol.inter_rigid) 
 CNSsolve>     
 CNSsolve>! scale_inter_only.cns 
 CNSsolve>!   Scaling of intermolecular interaction (not internal energies) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction ((resn WAT or resn HOH or resn TIP*)) ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 end 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    eval($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < $data.ncomponents) loop nloop4 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>      eval($nchain2 = $nchain1 ) 
 CNSsolve>      while ($nchain2 < $data.ncomponents) loop nloop3 
 CNSsolve>        eval($nchain2 = $nchain2 + 1) 
 CNSsolve>         
 CNSsolve>! rotation180.cns 
 CNSsolve>!    Perform a 180 degree rotation around a vector perpendicular to 
 CNSsolve>!    the interface of the complex 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>	eval($distcu = 5.0) 
 CNSsolve>        eval($rotate180 = 180.0) 
 CNSsolve>	eval($xa = 0.0) 
 CNSsolve>	eval($ya = 0.0) 
 CNSsolve>	eval($za = 0.0) 
 CNSsolve>	eval($xb = 0.0) 
 CNSsolve>	eval($zb = 0.0) 
 CNSsolve>	eval($zb = 0.0) 
 CNSsolve> 
 CNSsolve>        show aver (x) (segid $Toppar.prot_segid_$nchain1 and ((segid $Toppar.prot_segid_$nchain2) around $distcu)) 
 CNSsolve>        evaluate ($xa = $result) 
 CNSsolve>        show aver (y) (segid $Toppar.prot_segid_$nchain1 and ((segid $Toppar.prot_segid_$nchain2) around $distcu)) 
 CNSsolve>        evaluate ($ya = $result) 
 CNSsolve>        show aver (z) (segid $Toppar.prot_segid_$nchain1 and ((segid $Toppar.prot_segid_$nchain2) around $distcu)) 
 CNSsolve>        evaluate ($za = $result) 
 CNSsolve>        show aver (x) (segid $Toppar.prot_segid_$nchain2 and ((segid $Toppar.prot_segid_$nchain1) around $distcu)) 
 CNSsolve>        evaluate ($xb = $result) 
 CNSsolve>        show aver (y) (segid $Toppar.prot_segid_$nchain2 and ((segid $Toppar.prot_segid_$nchain1) around $distcu)) 
 CNSsolve>        evaluate ($yb = $result) 
 CNSsolve>        show aver (z) (segid $Toppar.prot_segid_$nchain2 and ((segid $Toppar.prot_segid_$nchain1) around $distcu)) 
 CNSsolve>        evaluate ($zb = $result) 
 CNSsolve>        eval($xdiff=$xa-$xb) 
 CNSsolve>        eval($ydiff=$ya-$yb) 
 CNSsolve>        eval($zdiff=$za-$zb) 
 CNSsolve>	eval($rnorm=$xdiff**2+$ydiff**2+$zdiff**2) 
 CNSsolve> 
 CNSsolve>	if ($rnorm > 0.0) then 
 CNSsolve> 
 CNSsolve>          coor 
 CNSsolve>            rotate sele= (segid $Toppar.prot_segid_$nchain2 or segid $watersegname_$nchain2) 
 CNSsolve>            center=($xa $ya $za) 
 CNSsolve>            axis ($xdiff $ydiff $zdiff) 
 CNSsolve>            $rotate180 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>   	  fix sele=(name OO) end 
 CNSsolve>	 
 CNSsolve>          minimize rigid 
 CNSsolve>            eval ($nch1 = 0) 
 CNSsolve>            while ($nch1 < $data.ncomponents) loop nloop1 
 CNSsolve>	      eval($nch1 = $nch1 + 1) 
 CNSsolve>              group (segid $Toppar.prot_segid_$nch1 or segid $watersegname_$nch1) 
 CNSsolve>              translation=true 
 CNSsolve>            end loop nloop1 
 CNSsolve>            translation=true 
 CNSsolve>            nstep 250 
 CNSsolve>            nprint 10 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          minimize rigid 
 CNSsolve>            eval ($nch1 = 0) 
 CNSsolve>            while ($nch1 < $data.ncomponents) loop nloop1 
 CNSsolve>	      eval($nch1 = $nch1 + 1) 
 CNSsolve>              group (segid $Toppar.prot_segid_$nch1 or segid $watersegname_$nch1) 
 CNSsolve>              translation=true 
 CNSsolve>            end loop nloop1 
 CNSsolve>            translation=true 
 CNSsolve>            nstep 250 
 CNSsolve>            nprint 10 
 CNSsolve>          end 
 CNSsolve> 
 CNSsolve>          energy end 
 CNSsolve> 
 CNSsolve>          if ($anisotropy eq true) then 
 CNSsolve>            fix sele=(not all) end 
 CNSsolve>   	    fix sele=(name OO) end 
 CNSsolve>            minimize rigid 
 CNSsolve>              group (not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>              translation=false 
 CNSsolve>              for $id in id ((resn ANI or resn DAN or resn XAN) and name OO) loop miniani 
 CNSsolve>                group (byres(id $id)) 
 CNSsolve>                translation=false 
 CNSsolve>              end loop miniani 
 CNSsolve>              translation=false 
 CNSsolve>              nstep 100 
 CNSsolve>              drop 10.0 
 CNSsolve>              nprint 10 
 CNSsolve>            end 
 CNSsolve>            minimize rigid 
 CNSsolve>              eval ($nch1 = 0) 
 CNSsolve>              while ($nch1 < $data.ncomponents) loop nloop1 
 CNSsolve>                eval($nch1 = $nch1 + 1) 
 CNSsolve>                group (segid $Toppar.prot_segid_$nch1 or segid $watersegname_$nch1) 
 CNSsolve>                translation=true 
 CNSsolve>              end loop nloop1 
 CNSsolve>              for $id in id ((resn ANI or resn DAN or resn XAN) and name OO) loop miniani 
 CNSsolve>                group (byres(id $id)) 
 CNSsolve>                translation=true 
 CNSsolve>              end loop miniani 
 CNSsolve>              translation=true 
 CNSsolve>              nstep 250 
 CNSsolve>              nprint 10 
 CNSsolve>            end 
 CNSsolve>          end if 
 CNSsolve>	 
 CNSsolve>	end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      end loop nloop3 
 CNSsolve>    end loop nloop4 
 CNSsolve> 
 CNSsolve>    @@RUN:protocols/flags_new.cns(Iteration=$Iteration; Data=$Data; ) 
 CNSsolve>    if ($Data.flags.elec1 eq true) then 
 CNSsolve>      flag include elec end 
 CNSsolve>    end if 
 CNSsolve>    if ($Data.flags.dihed eq true) then 
 CNSsolve>      flag include dihed end 
 CNSsolve>    end if 
 CNSsolve>    flag include bond angle impr vdw end 
 CNSsolve> 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  igroup 
 CNSsolve>    interaction  (not (resname ANI or resname DAN or resname XAN)) 
 CNSsolve>                 (not (resname ANI or resname DAN or resname XAN)) weight * 1 end 
 CNSsolve>    interaction  (resname ANI or resname DAN or resname XAN) 
 CNSsolve>                 (resname ANI or resname DAN or resname XAN) weight * 1 vdw 0.0 elec 0.0 end 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>  energy end 
 CNSsolve>{* 0 ======================================= initial EM for flexible parts only *} 
 CNSsolve> 
 CNSsolve>  if ($Data.flags.rg eq true ) then 
 CNSsolve>    collapse force $Data.krg_hot end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($SaProtocol.rigidtrans eq true) then 
 CNSsolve>     
 CNSsolve>! flex_segment_back.cns 
 CNSsolve>!    Define the semi-flexible segments (both side-chains and backbone) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store5 = 0) (all) 
 CNSsolve>do (store6 = 0) (all) 
 CNSsolve>do (store7 = 0) (all) 
 CNSsolve> 
 CNSsolve>!first flexible segments for docking 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  evaluate($fcounter=0) 
 CNSsolve> 
 CNSsolve>  if ($Toppar.nseg_$nchain1 = 0) then 
 CNSsolve>    display NO FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    if ($Toppar.nseg_$nchain1 < 0) then 
 CNSsolve>      display AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE $nchain1 
 CNSsolve>      inline  
 CNSsolve>! flexauto-neighbors.cns 
 CNSsolve>!    Automatic definition of flexible segments for docking for contacting residues 
 CNSsolve>!    including neighboring residues of residues making contacts 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($flcut = 5.0) 
 CNSsolve> 
 CNSsolve>do (store5 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve>do (store7 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve> 
 CNSsolve>do (store6 = 0) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = decode($result)) 
 CNSsolve>    evaluate ($preres = $inres) 
 CNSsolve>    evaluate ($nexres = $inres) 
 CNSsolve>    if ($iteration = 1) then 
 CNSsolve>      evaluate ($preres = $preres - 1) 
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>end loop flexres1 
 CNSsolve> 
 CNSsolve>do (store5 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>do (store7 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve> 
 CNSsolve>display THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule $nchain1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = $result) 
 CNSsolve>    show (resn) (id $id) 
 CNSsolve>    evaluate ($nares = $result) 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($seres = $result) 
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
 CNSsolve>end loop flexres2 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    else 
 CNSsolve>      display FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>      while ($fcounter < $Toppar.nseg_$nchain1) loop Xflex 
 CNSsolve>        evaluate($fcounter=$fcounter + 1) 
 CNSsolve>        do (store5 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>        display FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>      end loop Xflex 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>!then fully flexible segments for all stages 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop2 
 CNSsolve> 
 CNSsolve>do (store5 = 7) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = 0) 
 CNSsolve> 
 CNSsolve>! check number of flexible residues per molecule 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop3 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and (attr store5 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numfle=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not (attr store5 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numrig=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numres=$result) 
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 CNSsolve>end loop nloop3 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = $nfletot + $result) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = $nfletot + 10) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    fix sele=((attr store5 = 0 or name OO) and not name H* and not (resn WAT or resn HOH or resn TIP* or resn XAN)) end 
 CNSsolve>    minimize powell nstep=200 drop=10.0 nprint=25 end 
 CNSsolve>    fix sele=(not all) end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  energy end 
 CNSsolve> 
 CNSsolve>  do (refx = x) (all) 
 CNSsolve>  do (refy = y) (all) 
 CNSsolve>  do (refz = z) (all) 
 CNSsolve> 
 CNSsolve>  do (harm = 0) (all) 
 CNSsolve>  do (harm = 20) (name OO and not resn XAN) 
 CNSsolve>  restraints harmonic exponent=2 end 
 CNSsolve>  flag incl harm end 
 CNSsolve> 
 CNSsolve>  ! the following is added to avoid the generation of the torsion angle topology if not needed 
 CNSsolve>  ! in cases where the number of steps is set to 0 (avoid issues with isolated atoms) 
 CNSsolve>  eval ($torsiondone = false) 
 CNSsolve>  if ($failure eq false) then 
 CNSsolve>{* 1 ======================================= rigid body high temperature search*} 
 CNSsolve>{* rigid bodies *} 
 CNSsolve>    if ($SaProtocol.initiosteps > 0) then 
 CNSsolve>       
 CNSsolve>! torsiontop.cns 
 CNSsolve>!   Create the topology for torsion angle MD first stage 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = 150) 
 CNSsolve>!define flexible segments: 
 CNSsolve>display CALLING flex_segment.cns FOR RIGID BODY SA 
 CNSsolve>inline  
 CNSsolve>! flex_segment.cns 
 CNSsolve>!    Define fully flexible segments for docking 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store5 = 0) (all) 
 CNSsolve> 
 CNSsolve>display NO FLEXIBLE SEGMENTS for all molecule at this stage 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>do (store5 = 7) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = 0) 
 CNSsolve>! check number of flexible residues per molecule 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and attr store5 = $nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numfle=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not attr store5 = $nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numrig=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numres=$result) 
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 CNSsolve>end loop nloop2 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = $nfletot + $result) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = $nfletot + 10) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($numtrees=$data.ncomponents) 
 CNSsolve> 
 CNSsolve>! numtrees.cns 
 CNSsolve>!    Define the number of trees for torsion angle MD 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module (numtrees; Data; Toppar;) 
 CNSsolve>(numtrees=$numtrees; Data; Toppar;) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = 1) 
 CNSsolve>evaluate ($ncount = 0) 
 CNSsolve>evaluate ($break=$data.ncomponents) 
 CNSsolve> 
 CNSsolve>while ($ncount < $data.ncomponents) loop nsloop 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = $ncount + 1) 
 CNSsolve> 
 CNSsolve>  for $id1 in id ( name C and bondedto(name CA) and segid $Toppar.prot_segid_$ncount) loop break 
 CNSsolve> 
 CNSsolve>     show (resid) (id $id1) 
 CNSsolve>     evaluate ($resid1=$result) 
 CNSsolve> 
 CNSsolve>     evaluate ($resid2=encode(decode($resid1)+1)) 
 CNSsolve> 
 CNSsolve>     show sum(1) (id $id1 and known) 
 CNSsolve>     if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>       identity (store1) ( name N and bondedto(name CA) and segid $Toppar.prot_segid_$ncount and resid $resid2 ) 
 CNSsolve>       show element (store1) (attribute store1 > 0) 
 CNSsolve>       if ( $result ne 0) then 
 CNSsolve>         evaluate ($id2=$result) 
 CNSsolve> 
 CNSsolve>         show sum(1) (id $id2 and known) 
 CNSsolve> 
 CNSsolve>         if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>           pick bond 
 CNSsolve>             (name c and segid $Toppar.prot_segid_$ncount and resid $resid1) 
 CNSsolve>             (name n and segid $Toppar.prot_segid_$ncount and resid $resid2) 
 CNSsolve>             geometry 
 CNSsolve> 
 CNSsolve>           if ( $result > 2.5 ) then 
 CNSsolve>             evaluate ($break=$break+1) 
 CNSsolve>           end if 
 CNSsolve>         else 
 CNSsolve>           evaluate ($break=$break+1) 
 CNSsolve>         end if 
 CNSsolve>       end if 
 CNSsolve>     end if 
 CNSsolve> 
 CNSsolve>   end loop break 
 CNSsolve> 
 CNSsolve>end loop nsloop 
 CNSsolve> 
 CNSsolve>! check for water molecules 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate (&numtrees = $numtrees + $break + $result) 
 CNSsolve> 
 CNSsolve>if ($data.flags.sani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xrdc eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xpcs eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.dani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = $numtrees + 30) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>DISPLAY NUMTREES set to $numtrees 
 CNSsolve> 
 CNSsolve>dyna tors 
 CNSsolve>   topology 
 CNSsolve>      maxtree $numtrees 
 CNSsolve>      kdihmax = 23. 
 CNSsolve> 
 CNSsolve>      evaluate ($N_atom_id = 0) 
 CNSsolve>      evaluate ($atom_id = 0) 
 CNSsolve> 
 CNSsolve>      for $atom_id in id ( name ca ) loop main 
 CNSsolve>         if ( $N_atom_id > 0 ) then 
 CNSsolve>            fix group 
 CNSsolve>            (( byresidue ( id $N_atom_id ) and 
 CNSsolve>                (name C or name O {or name CA} )) 
 CNSsolve>             or ( byresidue ( id $atom_id ) and 
 CNSsolve>                (((name N or name HN {or name CA}) {and not resn pro}) 
 CNSsolve>                {or (( name N or name CD or name CA ) and resn pro)}))) 
 CNSsolve>         end if 
 CNSsolve>         evaluate ($N_atom_id = $atom_id) 
 CNSsolve>      end loop main 
 CNSsolve>      if ( $atom_id > 0 ) then 
 CNSsolve>        fix group 
 CNSsolve>            ( byresidue ( id $atom_id ) 
 CNSsolve>            and (name c or name ot1 or name ot2 {or name CA} )) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      for $atom_id in id 
 FOR-clause=     ( name ca and (resn phe or resn trp or resn his or resn asp or resn asn or resn nep)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                          name %Z* or name %E* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn tyr)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                 name %Z* or name %E* or name OH  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn gln or resn glu)) 
 FOR-clause=      loop main	 
 CNSsolve>            fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                 and ({name CG or} name %D* or name %E*)) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn arg)) 
 FOR-clause=      loop main	 
 CNSsolve>      fix group 
 CNSsolve>        ( byresidue ( id $atom_id ) 
 CNSsolve>          and ({name CD or} name %E* or name %Z* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve>      fix group ( resn PRO and not (name c or name o) ) 
 CNSsolve> 
 CNSsolve>      !next loop is for all sugars defined in glycans-uu.top 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name c1 and (resn GCP or resn GCF or resn GTP or resn GTF or resn MNP 
 FOR-clause=	  or resn MNF or resn ALP or resn ALF or resn ARP or resn ARF or resn GLP 
 FOR-clause=	  or resn GLF or resn IDP or resn IDF or resn TLP or resn TLF or resn PCP 
 FOR-clause=	  or resn PCF or resn FTP or resn FTF or resn SBP or resn SBF or resn TTP 
 FOR-clause=	  or resn TTF or resn NAA or resn RBP or resn RBF or resn ANF or resn XLF 
 FOR-clause=	  or resn LXF or resn RLF or resn LLF)) 
 FOR-clause=      loop main	 
 CNSsolve>      fix group 
 CNSsolve>        ( byresidue ( id $atom_id ) 
 CNSsolve>          and (name %1 or name %2 or name %3 or name %4 or name %5 or name O5)) 
 CNSsolve>      end loop main 
 CNSsolve> 
 CNSsolve>      for $id in id (name C1') loop freeribose 
 CNSsolve>        free bond (id $id) (byresid (id $id) and name C2') 
 CNSsolve>      end loop freeribose 
 CNSsolve> 
 CNSsolve>      fix group ( resn HEC and (name C1* or name C2* or name C3* or name C4* or name N* or name CH*)) 
 CNSsolve> 
 CNSsolve>      fix group ( resn CYM and not (name CA or name C or name O or name OXT or 
 CNSsolve>                  name N or name HN or name HA or name CB or name HB1 or name HB2 or 
 CNSsolve>                  name SG or name SAL or name CAJ)) 
 CNSsolve> 
 CNSsolve>      fix group ( byresidue (resn WAT)) 
 CNSsolve>      fix group ( byresidue (resn HOH)) 
 CNSsolve>      fix group ( byresidue (resn TIP*)) 
 CNSsolve>      fix group ( byresidue (resn ANI)) 
 CNSsolve>      fix group ( byresidue (resn DAN)) 
 CNSsolve>      fix group ( byresidue (resn XAN)) 
 CNSsolve> 
 CNSsolve>     eval($nchain1 = 0) 
 CNSsolve>     while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>       eval($nchain1 = $nchain1 + 1) 
 CNSsolve>       fix group (segid $Toppar.prot_segid_$nchain1 and 
 CNSsolve>                  not (attribute store5 = $nchain1) 
 CNSsolve>		  and not ((resn WAT or resn HOH or resn TIP*))) 
 CNSsolve>     end loop nloop1 
 CNSsolve>   end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      eval ($torsiondone = true) 
 CNSsolve>      flags exclude dihed end 
 CNSsolve>       
 CNSsolve>! sa_ltad_hightemp.cns 
 CNSsolve>!    Perform the high-temperature rigid-body MD of it1 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>! module sa_ltad_hightemp.cns 
 CNSsolve>! torsion dynamics high temperature phase 
 CNSsolve> 
 CNSsolve>module(SaProtocol;Data;Toppar) 
 CNSsolve>(SaProtocol=$SaProtocol;Data=$Data;Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($calcsteps= $SaProtocol.initiosteps) 
 CNSsolve>evaluate ($printsteps= max(int($calcsteps/10),1)) 
 CNSsolve> 
 CNSsolve>noe 
 CNSsolve>    rswitch ambi &Data.Rswi_hot 
 CNSsolve>    rswitch dist &Data.Rswi_hot 
 CNSsolve>    rswitch hbon &Data.Rswi_hot 
 CNSsolve> 
 CNSsolve>    mrswitch ambi &Data.mRswi_hot 
 CNSsolve>    mrswitch dist &Data.mRswi_hot 
 CNSsolve>    mrswitch hbon &Data.mRswi_hot 
 CNSsolve> 
 CNSsolve>    asym ambi &Data.asy_hot 
 CNSsolve>    asym dist &Data.asy_hot 
 CNSsolve>    asym hbon &Data.asy_hot 
 CNSsolve> 
 CNSsolve>    masym ambi &Data.masy_hot 
 CNSsolve>    masym dist &Data.masy_hot 
 CNSsolve>    masym hbon &Data.masy_hot 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($bath = &SaPRotocol.tadhigh_t) 
 CNSsolve>evaluate ($timestep = &SaProtocol.timestep*&SaProtocol.tadfactor) 
 CNSsolve> 
 CNSsolve>do (vx = maxwell($bath)) (all) 
 CNSsolve>do (vy = maxwell($bath)) (all) 
 CNSsolve>do (vz = maxwell($bath)) (all) 
 CNSsolve> 
 CNSsolve>!for the vean statement: 
 CNSsolve>evaluate( $k_cen_1 = &data.ini_cen_hot_1) 
 CNSsolve>evaluate( $k_bor_1 = &data.ini_bor_hot_1) 
 CNSsolve>evaluate( $k_cen_2 = &data.ini_cen_hot_2) 
 CNSsolve>evaluate( $k_bor_2 = &data.ini_bor_hot_2) 
 CNSsolve>evaluate( $k_cen_3 = &data.ini_cen_hot_3) 
 CNSsolve>evaluate( $k_bor_3 = &data.ini_bor_hot_3) 
 CNSsolve>evaluate( $k_cen_4 = &data.ini_cen_hot_4) 
 CNSsolve>evaluate( $k_bor_4 = &data.ini_bor_hot_4) 
 CNSsolve>evaluate( $k_cen_5 = &data.ini_cen_hot_5) 
 CNSsolve>evaluate( $k_bor_5 = &data.ini_bor_hot_5) 
 CNSsolve> 
 CNSsolve>restraints dihedral scale &Data.dihedrals_hot end 
 CNSsolve> 
 CNSsolve>couplings class c1 force $Data.c1_hot end 
 CNSsolve>couplings class c2 force $Data.c2_hot end 
 CNSsolve>couplings class c3 force $Data.c3_hot end 
 CNSsolve>couplings class c4 force $Data.c4_hot end 
 CNSsolve>couplings class c5 force $Data.c5_hot end 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sani eq true) then 
 CNSsolve>  sani class rdc1 force $Data.rdc1_hot end 
 CNSsolve>  sani class rdc2 force $Data.rdc2_hot end 
 CNSsolve>  sani class rdc3 force $Data.rdc3_hot end 
 CNSsolve>  sani class rdc4 force $Data.rdc4_hot end 
 CNSsolve>  sani class rdc5 force $Data.rdc5_hot end 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.dani eq true) then 
 CNSsolve>  dani class dan1 force $Data.dan1_hot end 
 CNSsolve>  dani class dan2 force $Data.dan2_hot end 
 CNSsolve>  dani class dan3 force $Data.dan3_hot end 
 CNSsolve>  dani class dan4 force $Data.dan4_hot end 
 CNSsolve>  dani class dan5 force $Data.dan5_hot end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.vean eq true) then 
 CNSsolve>  vean class vea1 force $k_bor_1 $k_cen_1 end 
 CNSsolve>  vean class vea2 force $k_bor_2 $k_cen_2 end 
 CNSsolve>  vean class vea3 force $k_bor_3 $k_cen_3 end 
 CNSsolve>  vean class vea4 force $k_bor_4 $k_cen_4 end 
 CNSsolve>  vean class vea5 force $k_bor_5 $k_cen_5 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.xpcs eq true) then 
 CNSsolve>  xpcs class pcs1 force $Data.pcs1_hot end 
 CNSsolve>  xpcs class pcs2 force $Data.pcs2_hot end 
 CNSsolve>  xpcs class pcs3 force $Data.pcs3_hot end 
 CNSsolve>  xpcs class pcs4 force $Data.pcs4_hot end 
 CNSsolve>  xpcs class pcs5 force $Data.pcs5_hot end 
 CNSsolve>  xpcs class pcs6 force $Data.pcs6_hot end 
 CNSsolve>  xpcs class pcs7 force $Data.pcs7_hot end 
 CNSsolve>  xpcs class pcs8 force $Data.pcs8_hot end 
 CNSsolve>  xpcs class pcs9 force $Data.pcs9_hot end 
 CNSsolve>  xpcs class pcsA force $Data.pcsA_hot end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($reassign = TRUE) 
 CNSsolve> 
 CNSsolve>if ($Data.scaling eq TRUE) then 
 CNSsolve>  inline  
 CNSsolve>! set_noe_scale.cns 
 CNSsolve>!    Set the distance restraint force constant 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($enoe   = 0.0 ) 
 CNSsolve>evaluate ($vdw    = 0.0 ) 
 CNSsolve>evaluate ($elec   = 0.0 ) 
 CNSsolve>evaluate ($einter = 0.0 ) 
 CNSsolve>evaluate ($noescale = 1.0 ) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym ne true) then 
 CNSsolve>  print threshold=0.5 noe 
 CNSsolve>  evaluate ($numnoe=$violations) 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_amb > 0) then 
 CNSsolve>    evaluate ($ambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_amb)))) 
 CNSsolve>    if ($ambcorr = 0) then 
 CNSsolve>      evaluate ($ambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($ambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_unamb > 0) then 
 CNSsolve>    evaluate ($unambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_unamb)))) 
 CNSsolve>    if ($unambcorr = 0) then 
 CNSsolve>      evaluate ($unambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($unambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve>else 
 CNSsolve>  evaluate ($unambcorr = 1) 
 CNSsolve>  evaluate ($ambcorr = 1) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>eval ($nchain1 = 0) 
 CNSsolve>igroup 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction  (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                   (segid $Toppar.prot_segid_$nchain2) weights * 1 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>  end loop nloop1 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>energy end 
 CNSsolve>igroup 
 CNSsolve>    interaction  (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($einter = abs($vdw + $elec)) 
 CNSsolve>evaluate ($enoe   = $noe) 
 CNSsolve> 
 CNSsolve>if ($enoe ne 0) then 
 CNSsolve>  evaluate ($noescale = min(5000, (2 * $einter / $enoe))) 
 CNSsolve>  if ($noescale ne 0) then 
 CNSsolve>    evaluate ($Data.unamb_hot   = $Data.unamb_hot   * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_hot     = $Data.amb_hot     * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool1 = $Data.unamb_cool1 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool1   = $Data.amb_cool1   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool2 = $Data.unamb_cool2 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool2   = $Data.amb_cool2   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool3 = $Data.unamb_cool3 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool3   = $Data.amb_cool3   * $noescale * $ambcorr) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>noe 
 CNSsolve>  scale dist  &Data.unamb_hot 
 CNSsolve>  scale ambi  &Data.amb_hot 
 CNSsolve>  scale hbon  &Data.hbond_hot 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($kinter = &SaProtocol.inter_init_rigid) 
 CNSsolve>inline  
 CNSsolve>! scale_inter.cns 
 CNSsolve>!    Scaling of intermolecular interactions 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) weight * $Toppar.int_$nchain1_$nchain1 end 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve> 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> 
 CNSsolve>  interaction ((resn WAT or resn HOH or resn TIP*)) ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>dyna tors 
 CNSsolve>  reassign $reassign 
 CNSsolve>  timestep=$timestep 
 CNSsolve>  nstep=$calcsteps 
 CNSsolve>  nprint=$printsteps 
 CNSsolve>  ntrfrq=0 
 CNSsolve>  tcoupling = true  temperature = $bath 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($reassign = FALSE) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>{* 2 ======================================= rigid body first slow cooling *} 
 CNSsolve>{* rigid bodies only *} 
 CNSsolve> 
 CNSsolve>    if ($Data.flags.rg eq true ) then 
 CNSsolve>      collapse force $Data.krg_cool1 end 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($SaProtocol.cool1_steps > 0) then 
 CNSsolve>      if ($torsiondone ne true) then 
 CNSsolve>         
 CNSsolve>! torsiontop.cns 
 CNSsolve>!   Create the topology for torsion angle MD first stage 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = 150) 
 CNSsolve>!define flexible segments: 
 CNSsolve>display CALLING flex_segment.cns FOR RIGID BODY SA 
 CNSsolve>inline  
 CNSsolve>! flex_segment.cns 
 CNSsolve>!    Define fully flexible segments for docking 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store5 = 0) (all) 
 CNSsolve> 
 CNSsolve>display NO FLEXIBLE SEGMENTS for all molecule at this stage 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>do (store5 = 7) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = 0) 
 CNSsolve>! check number of flexible residues per molecule 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and attr store5 = $nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numfle=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not attr store5 = $nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numrig=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numres=$result) 
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 CNSsolve>end loop nloop2 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = $nfletot + $result) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = $nfletot + 10) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($numtrees=$data.ncomponents) 
 CNSsolve> 
 CNSsolve>! numtrees.cns 
 CNSsolve>!    Define the number of trees for torsion angle MD 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module (numtrees; Data; Toppar;) 
 CNSsolve>(numtrees=$numtrees; Data; Toppar;) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = 1) 
 CNSsolve>evaluate ($ncount = 0) 
 CNSsolve>evaluate ($break=$data.ncomponents) 
 CNSsolve> 
 CNSsolve>while ($ncount < $data.ncomponents) loop nsloop 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = $ncount + 1) 
 CNSsolve> 
 CNSsolve>  for $id1 in id ( name C and bondedto(name CA) and segid $Toppar.prot_segid_$ncount) loop break 
 CNSsolve> 
 CNSsolve>     show (resid) (id $id1) 
 CNSsolve>     evaluate ($resid1=$result) 
 CNSsolve> 
 CNSsolve>     evaluate ($resid2=encode(decode($resid1)+1)) 
 CNSsolve> 
 CNSsolve>     show sum(1) (id $id1 and known) 
 CNSsolve>     if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>       identity (store1) ( name N and bondedto(name CA) and segid $Toppar.prot_segid_$ncount and resid $resid2 ) 
 CNSsolve>       show element (store1) (attribute store1 > 0) 
 CNSsolve>       if ( $result ne 0) then 
 CNSsolve>         evaluate ($id2=$result) 
 CNSsolve> 
 CNSsolve>         show sum(1) (id $id2 and known) 
 CNSsolve> 
 CNSsolve>         if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>           pick bond 
 CNSsolve>             (name c and segid $Toppar.prot_segid_$ncount and resid $resid1) 
 CNSsolve>             (name n and segid $Toppar.prot_segid_$ncount and resid $resid2) 
 CNSsolve>             geometry 
 CNSsolve> 
 CNSsolve>           if ( $result > 2.5 ) then 
 CNSsolve>             evaluate ($break=$break+1) 
 CNSsolve>           end if 
 CNSsolve>         else 
 CNSsolve>           evaluate ($break=$break+1) 
 CNSsolve>         end if 
 CNSsolve>       end if 
 CNSsolve>     end if 
 CNSsolve> 
 CNSsolve>   end loop break 
 CNSsolve> 
 CNSsolve>end loop nsloop 
 CNSsolve> 
 CNSsolve>! check for water molecules 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate (&numtrees = $numtrees + $break + $result) 
 CNSsolve> 
 CNSsolve>if ($data.flags.sani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xrdc eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xpcs eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.dani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = $numtrees + 30) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>DISPLAY NUMTREES set to $numtrees 
 CNSsolve> 
 CNSsolve>dyna tors 
 CNSsolve>   topology 
 CNSsolve>      maxtree $numtrees 
 CNSsolve>      kdihmax = 23. 
 CNSsolve> 
 CNSsolve>      evaluate ($N_atom_id = 0) 
 CNSsolve>      evaluate ($atom_id = 0) 
 CNSsolve> 
 CNSsolve>      for $atom_id in id ( name ca ) loop main 
 CNSsolve>         if ( $N_atom_id > 0 ) then 
 CNSsolve>            fix group 
 CNSsolve>            (( byresidue ( id $N_atom_id ) and 
 CNSsolve>                (name C or name O {or name CA} )) 
 CNSsolve>             or ( byresidue ( id $atom_id ) and 
 CNSsolve>                (((name N or name HN {or name CA}) {and not resn pro}) 
 CNSsolve>                {or (( name N or name CD or name CA ) and resn pro)}))) 
 CNSsolve>         end if 
 CNSsolve>         evaluate ($N_atom_id = $atom_id) 
 CNSsolve>      end loop main 
 CNSsolve>      if ( $atom_id > 0 ) then 
 CNSsolve>        fix group 
 CNSsolve>            ( byresidue ( id $atom_id ) 
 CNSsolve>            and (name c or name ot1 or name ot2 {or name CA} )) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      for $atom_id in id 
 FOR-clause=     ( name ca and (resn phe or resn trp or resn his or resn asp or resn asn or resn nep)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                          name %Z* or name %E* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn tyr)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                 name %Z* or name %E* or name OH  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn gln or resn glu)) 
 FOR-clause=      loop main	 
 CNSsolve>            fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                 and ({name CG or} name %D* or name %E*)) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn arg)) 
 FOR-clause=      loop main	 
 CNSsolve>      fix group 
 CNSsolve>        ( byresidue ( id $atom_id ) 
 CNSsolve>          and ({name CD or} name %E* or name %Z* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve>      fix group ( resn PRO and not (name c or name o) ) 
 CNSsolve> 
 CNSsolve>      !next loop is for all sugars defined in glycans-uu.top 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name c1 and (resn GCP or resn GCF or resn GTP or resn GTF or resn MNP 
 FOR-clause=	  or resn MNF or resn ALP or resn ALF or resn ARP or resn ARF or resn GLP 
 FOR-clause=	  or resn GLF or resn IDP or resn IDF or resn TLP or resn TLF or resn PCP 
 FOR-clause=	  or resn PCF or resn FTP or resn FTF or resn SBP or resn SBF or resn TTP 
 FOR-clause=	  or resn TTF or resn NAA or resn RBP or resn RBF or resn ANF or resn XLF 
 FOR-clause=	  or resn LXF or resn RLF or resn LLF)) 
 FOR-clause=      loop main	 
 CNSsolve>      fix group 
 CNSsolve>        ( byresidue ( id $atom_id ) 
 CNSsolve>          and (name %1 or name %2 or name %3 or name %4 or name %5 or name O5)) 
 CNSsolve>      end loop main 
 CNSsolve> 
 CNSsolve>      for $id in id (name C1') loop freeribose 
 CNSsolve>        free bond (id $id) (byresid (id $id) and name C2') 
 CNSsolve>      end loop freeribose 
 CNSsolve> 
 CNSsolve>      fix group ( resn HEC and (name C1* or name C2* or name C3* or name C4* or name N* or name CH*)) 
 CNSsolve> 
 CNSsolve>      fix group ( resn CYM and not (name CA or name C or name O or name OXT or 
 CNSsolve>                  name N or name HN or name HA or name CB or name HB1 or name HB2 or 
 CNSsolve>                  name SG or name SAL or name CAJ)) 
 CNSsolve> 
 CNSsolve>      fix group ( byresidue (resn WAT)) 
 CNSsolve>      fix group ( byresidue (resn HOH)) 
 CNSsolve>      fix group ( byresidue (resn TIP*)) 
 CNSsolve>      fix group ( byresidue (resn ANI)) 
 CNSsolve>      fix group ( byresidue (resn DAN)) 
 CNSsolve>      fix group ( byresidue (resn XAN)) 
 CNSsolve> 
 CNSsolve>     eval($nchain1 = 0) 
 CNSsolve>     while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>       eval($nchain1 = $nchain1 + 1) 
 CNSsolve>       fix group (segid $Toppar.prot_segid_$nchain1 and 
 CNSsolve>                  not (attribute store5 = $nchain1) 
 CNSsolve>		  and not ((resn WAT or resn HOH or resn TIP*))) 
 CNSsolve>     end loop nloop1 
 CNSsolve>   end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>        eval ($torsiondone = true) 
 CNSsolve>      end if 
 CNSsolve>      evaluate ($SaProtocol.tadfactor = 4) 
 CNSsolve>       
 CNSsolve>! sa_ltad_cool1.cns 
 CNSsolve>!    Perform the first simulated annealing stage of it1 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module(SaProtocol;Data;Toppar) 
 CNSsolve>(SaProtocol=$SaProtocol;Data=$Data;Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! module sa_ltad_cool1.cns 
 CNSsolve>! torsion dynamics cooling 
 CNSsolve> 
 CNSsolve>evaluate ($ncycle = 10) 
 CNSsolve> 
 CNSsolve>evaluate ($interstep = (&SaProtocol.inter_fin_rigid - &SaProtocol.inter_init_rigid)/($ncycle-1)) 
 CNSsolve>evaluate ($kinter = &SaProtocol.inter_init_rigid) 
 CNSsolve> 
 CNSsolve>evaluate ($asy_add = (&Data.asy_cool1-&Data.asy_hot)/$ncycle) 
 CNSsolve>evaluate ($masy_add = (&Data.masy_cool1-&Data.masy_hot)/$ncycle) 
 CNSsolve> 
 CNSsolve>evaluate ($asy=&Data.asy_hot) 
 CNSsolve>evaluate ($masy=&Data.masy_hot) 
 CNSsolve>noe 
 CNSsolve>    rswitch ambi &Data.Rswi_hot 
 CNSsolve>    rswitch dist &Data.Rswi_hot 
 CNSsolve>    rswitch hbon &Data.Rswi_hot 
 CNSsolve> 
 CNSsolve>    mrswitch ambi &Data.mRswi_hot 
 CNSsolve>    mrswitch dist &Data.mRswi_hot 
 CNSsolve>    mrswitch hbon &Data.mRswi_hot 
 CNSsolve> 
 CNSsolve>    asym ambi &Data.asy_hot 
 CNSsolve>    asym dist &Data.asy_hot 
 CNSsolve>    asym hbon &Data.asy_hot 
 CNSsolve> 
 CNSsolve>    masym ambi &Data.masy_hot 
 CNSsolve>    masym dist &Data.masy_hot 
 CNSsolve>    masym hbon &Data.masy_hot 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>restraints dihedral   scale=&Data.dihedrals_cool1   end 
 CNSsolve>couplings class c1 force &Data.c1_cool1 end 
 CNSsolve>couplings class c2 force &Data.c2_cool1 end 
 CNSsolve>couplings class c3 force &Data.c3_cool1 end 
 CNSsolve>couplings class c4 force &Data.c4_cool1 end 
 CNSsolve>couplings class c5 force &Data.c5_cool1 end 
 CNSsolve> 
 CNSsolve>evaluate( $k_sani_1  = &Data.rdc1_hot) 
 CNSsolve>if (&Data.rdc1_hot > 0) then 
 CNSsolve>  evaluate( $sani_fac_1 = ( &Data.rdc1_cool1 / &Data.rdc1_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_2  = &Data.rdc2_hot) 
 CNSsolve>if (&Data.rdc2_hot > 0) then 
 CNSsolve>  evaluate( $sani_fac_2 = ( &Data.rdc2_cool1 / &Data.rdc2_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_3  = &Data.rdc3_hot) 
 CNSsolve>if (&Data.rdc3_hot > 0) then 
 CNSsolve>  evaluate( $sani_fac_3 = ( &Data.rdc3_cool1 / &Data.rdc3_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_4  = &Data.rdc4_hot) 
 CNSsolve>if (&Data.rdc4_hot > 0) then 
 CNSsolve>  evaluate( $sani_fac_4 = ( &Data.rdc4_cool1 / &Data.rdc4_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_5  = &Data.rdc5_hot) 
 CNSsolve>if (&Data.rdc5_hot > 0) then 
 CNSsolve>  evaluate( $sani_fac_5 = ( &Data.rdc5_cool1 / &Data.rdc5_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sani eq true) then 
 CNSsolve>  sani class rdc1 force $k_sani_1 end 
 CNSsolve>  sani class rdc2 force $k_sani_2 end 
 CNSsolve>  sani class rdc3 force $k_sani_3 end 
 CNSsolve>  sani class rdc4 force $k_sani_4 end 
 CNSsolve>  sani class rdc5 force $k_sani_5 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate( $k_dani_1  = &Data.dan1_hot) 
 CNSsolve>if (&Data.dan1_hot > 0) then 
 CNSsolve>  evaluate( $dani_fac_1 = ( &Data.dan1_cool1 / &Data.dan1_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_2  = &Data.dan2_hot) 
 CNSsolve>if (&Data.dan2_hot > 0) then 
 CNSsolve>  evaluate( $dani_fac_2 = ( &Data.dan2_cool1 / &Data.dan2_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_3  = &Data.dan3_hot) 
 CNSsolve>if (&Data.dan3_hot > 0) then 
 CNSsolve>  evaluate( $dani_fac_3 = ( &Data.dan3_cool1 / &Data.dan3_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_4  = &Data.dan4_hot) 
 CNSsolve>if (&Data.dan4_hot > 0) then 
 CNSsolve>  evaluate( $dani_fac_4 = ( &Data.dan4_cool1 / &Data.dan4_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_5  = &Data.dan5_hot) 
 CNSsolve>if (&Data.dan5_hot > 0) then 
 CNSsolve>  evaluate( $dani_fac_5 = ( &Data.dan5_cool1 / &Data.dan5_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.dani eq true) then 
 CNSsolve>  dani class dan1 force $k_dani_1 end 
 CNSsolve>  dani class dan2 force $k_dani_2 end 
 CNSsolve>  dani class dan3 force $k_dani_3 end 
 CNSsolve>  dani class dan4 force $k_dani_4 end 
 CNSsolve>  dani class dan5 force $k_dani_5 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate( $k_xpcs_1  = &Data.pcs1_hot) 
 CNSsolve>if (&Data.pcs1_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_1 = ( &Data.pcs1_cool1 / &Data.pcs1_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_2  = &Data.pcs2_hot) 
 CNSsolve>if (&Data.pcs2_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_2 = ( &Data.pcs2_cool1 / &Data.pcs2_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_3  = &Data.pcs3_hot) 
 CNSsolve>if (&Data.pcs3_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_3 = ( &Data.pcs3_cool1 / &Data.pcs3_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_4  = &Data.pcs4_hot) 
 CNSsolve>if (&Data.pcs4_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_4 = ( &Data.pcs4_cool1 / &Data.pcs4_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_5  = &Data.pcs5_hot) 
 CNSsolve>if (&Data.pcs5_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_5 = ( &Data.pcs5_cool1 / &Data.pcs5_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_6  = &Data.pcs6_hot) 
 CNSsolve>if (&Data.pcs6_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_6 = ( &Data.pcs6_cool1 / &Data.pcs6_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_6 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_7  = &Data.pcs7_hot) 
 CNSsolve>if (&Data.pcs7_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_7 = ( &Data.pcs7_cool1 / &Data.pcs7_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_7 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_8  = &Data.pcs8_hot) 
 CNSsolve>if (&Data.pcs8_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_8 = ( &Data.pcs8_cool1 / &Data.pcs8_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_8 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_9  = &Data.pcs9_hot) 
 CNSsolve>if (&Data.pcs9_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_9 = ( &Data.pcs9_cool1 / &Data.pcs9_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_9 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_A  = &Data.pcsA_hot) 
 CNSsolve>if (&Data.pcsA_hot > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_A = ( &Data.pcsA_cool1 / &Data.pcsA_hot)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_A = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($Data.flags.xpcs eq true) then 
 CNSsolve>  xpcs class pcs1 force $k_xpcs_1 end 
 CNSsolve>  xpcs class pcs2 force $k_xpcs_2 end 
 CNSsolve>  xpcs class pcs3 force $k_xpcs_3 end 
 CNSsolve>  xpcs class pcs4 force $k_xpcs_4 end 
 CNSsolve>  xpcs class pcs5 force $k_xpcs_5 end 
 CNSsolve>  xpcs class pcs6 force $k_xpcs_6 end 
 CNSsolve>  xpcs class pcs7 force $k_xpcs_7 end 
 CNSsolve>  xpcs class pcs8 force $k_xpcs_8 end 
 CNSsolve>  xpcs class pcs9 force $k_xpcs_9 end 
 CNSsolve>  xpcs class pcsA force $k_xpcs_A end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($tempstep = (&SaProtocol.t1_init - &SaProtocol.t1_final)/$ncycle) 
 CNSsolve>evaluate ($calcsteps = int(&SaProtocol.cool1_steps/$ncycle)) 
 CNSsolve>evaluate ($printsteps = int($calcsteps / 4)) 
 CNSsolve>evaluate ($timestep = &SaProtocol.timestep*&SaProtocol.tadfactor) 
 CNSsolve> 
 CNSsolve>if (&Data.unamb_hot = 0) then 
 CNSsolve>  evaluate (&Data.unamb_hot = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.unamb_cool1 = 0) then 
 CNSsolve>  evaluate (&Data.unamb_cool1 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.amb_hot = 0)then 
 CNSsolve>  evaluate (&Data.amb_hot = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.amb_cool1 = 0) then 
 CNSsolve>  evaluate (&Data.amb_cool1 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.hbond_hot = 0) then 
 CNSsolve>  evaluate (&Data.hbond_hot = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.hbond_cool1 = 0) then 
 CNSsolve>  evaluate (&Data.hbond_cool1 = 0.000001) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($k_unamb= &Data.unamb_hot) 
 CNSsolve>evaluate ($unamb_fac = (&Data.unamb_cool1/&Data.unamb_hot)^(1/$ncycle)) 
 CNSsolve>evaluate ($k_amb= &Data.amb_hot) 
 CNSsolve>evaluate ($amb_fac = (&Data.amb_cool1/&Data.amb_hot)^(1/$ncycle)) 
 CNSsolve>evaluate ($k_hbond= &Data.hbond_hot) 
 CNSsolve>evaluate ($hbond_fac = (&Data.hbond_cool1/&Data.hbond_hot)^(1/$ncycle)) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!for the vean statement: 
 CNSsolve>evaluate( $k_cen_1 = &Data.ini_cen_cool1_1) 
 CNSsolve>evaluate( $cen_fac_1 = ( &Data.fin_cen_cool1_1 / &Data.ini_cen_cool1_1)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_1 = &Data.ini_bor_cool1_1) 
 CNSsolve>evaluate( $bor_fac_1 = ( &Data.fin_bor_cool1_1 / &Data.ini_bor_cool1_1)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_2 = &Data.ini_cen_cool1_2) 
 CNSsolve>evaluate( $cen_fac_2 = ( &Data.fin_cen_cool1_2 / &Data.ini_cen_cool1_2)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_2 = &Data.ini_bor_cool1_2) 
 CNSsolve>evaluate( $bor_fac_2 = ( &Data.fin_bor_cool1_2 / &Data.ini_bor_cool1_2)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_3 = &Data.ini_cen_cool1_3) 
 CNSsolve>evaluate( $cen_fac_3 = ( &Data.fin_cen_cool1_3 / &Data.ini_cen_cool1_3)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_3 = &Data.ini_bor_cool1_3) 
 CNSsolve>evaluate( $bor_fac_3 = ( &Data.fin_bor_cool1_3 / &Data.ini_bor_cool1_3)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_4 = &Data.ini_cen_cool1_4) 
 CNSsolve>evaluate( $cen_fac_4 = ( &Data.fin_cen_cool1_4 / &Data.ini_cen_cool1_4)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_4 = &Data.ini_bor_cool1_4) 
 CNSsolve>evaluate( $bor_fac_4 = ( &Data.fin_bor_cool1_4 / &Data.ini_bor_cool1_4)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_5 = &Data.ini_cen_cool1_5) 
 CNSsolve>evaluate( $cen_fac_5 = ( &Data.fin_cen_cool1_5 / &Data.ini_cen_cool1_5)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_5 = &Data.ini_bor_cool1_5) 
 CNSsolve>evaluate( $bor_fac_5 = ( &Data.fin_bor_cool1_5 / &Data.ini_bor_cool1_5)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate ($bath  = &SaProtocol.t1_init) 
 CNSsolve>do (vx=maxwell($bath)) ( all ) 
 CNSsolve>do (vy=maxwell($bath)) ( all ) 
 CNSsolve>do (vz=maxwell($bath)) ( all ) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($reassign = TRUE) 
 CNSsolve>evaluate ($i_cool = 0) 
 CNSsolve>while ($i_cool < $ncycle) loop cool 
 CNSsolve> 
 CNSsolve>      evaluate ($i_cool=$i_cool+1) 
 CNSsolve> 
 CNSsolve>      evaluate ($bath  = $bath  - $tempstep) 
 CNSsolve>      evaluate ($k_unamb = $k_unamb*$unamb_fac) 
 CNSsolve>      evaluate ($k_amb = $k_amb*$amb_fac) 
 CNSsolve>      evaluate ($k_hbond = $k_hbond*$hbond_fac) 
 CNSsolve>      evaluate ($asy=$asy+$asy_add) 
 CNSsolve>      evaluate ($masy=$masy+$masy_add) 
 CNSsolve> 
 CNSsolve>      evaluate ($k_bor_1 = $k_bor_1 * $bor_fac_1) 
 CNSsolve>      evaluate ($k_bor_2 = $k_bor_2 * $bor_fac_2) 
 CNSsolve>      evaluate ($k_bor_3 = $k_bor_3 * $bor_fac_3) 
 CNSsolve>      evaluate ($k_bor_4 = $k_bor_4 * $bor_fac_4) 
 CNSsolve>      evaluate ($k_bor_5 = $k_bor_5 * $bor_fac_5) 
 CNSsolve> 
 CNSsolve>      evaluate ($k_cen_1 = $k_cen_1 * $cen_fac_1) 
 CNSsolve>      evaluate ($k_cen_2 = $k_cen_2 * $cen_fac_2) 
 CNSsolve>      evaluate ($k_cen_3 = $k_cen_3 * $cen_fac_3) 
 CNSsolve>      evaluate ($k_cen_4 = $k_cen_4 * $cen_fac_4) 
 CNSsolve>      evaluate ($k_cen_5 = $k_cen_5 * $cen_fac_5) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.vean eq true) then 
 CNSsolve>        vean class vea1 force $k_bor_1 $k_cen_1 end 
 CNSsolve>        vean class vea2 force $k_bor_2 $k_cen_2 end 
 CNSsolve>        vean class vea3 force $k_bor_3 $k_cen_3 end 
 CNSsolve>        vean class vea4 force $k_bor_4 $k_cen_4 end 
 CNSsolve>        vean class vea5 force $k_bor_5 $k_cen_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_sani_1 = $k_sani_1 * $sani_fac_1) 
 CNSsolve>      evaluate ($k_sani_2 = $k_sani_2 * $sani_fac_2) 
 CNSsolve>      evaluate ($k_sani_3 = $k_sani_3 * $sani_fac_3) 
 CNSsolve>      evaluate ($k_sani_4 = $k_sani_4 * $sani_fac_4) 
 CNSsolve>      evaluate ($k_sani_5 = $k_sani_5 * $sani_fac_5) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.sani eq true) then 
 CNSsolve>        sani class rdc1 force $k_sani_1 end 
 CNSsolve>        sani class rdc2 force $k_sani_2 end 
 CNSsolve>        sani class rdc3 force $k_sani_3 end 
 CNSsolve>        sani class rdc4 force $k_sani_4 end 
 CNSsolve>        sani class rdc5 force $k_sani_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_xpcs_1 = $k_xpcs_1 * $xpcs_fac_1) 
 CNSsolve>      evaluate ($k_xpcs_2 = $k_xpcs_2 * $xpcs_fac_2) 
 CNSsolve>      evaluate ($k_xpcs_3 = $k_xpcs_3 * $xpcs_fac_3) 
 CNSsolve>      evaluate ($k_xpcs_4 = $k_xpcs_4 * $xpcs_fac_4) 
 CNSsolve>      evaluate ($k_xpcs_5 = $k_xpcs_5 * $xpcs_fac_5) 
 CNSsolve>      evaluate ($k_xpcs_6 = $k_xpcs_6 * $xpcs_fac_6) 
 CNSsolve>      evaluate ($k_xpcs_7 = $k_xpcs_7 * $xpcs_fac_7) 
 CNSsolve>      evaluate ($k_xpcs_8 = $k_xpcs_8 * $xpcs_fac_8) 
 CNSsolve>      evaluate ($k_xpcs_9 = $k_xpcs_9 * $xpcs_fac_9) 
 CNSsolve>      evaluate ($k_xpcs_A = $k_xpcs_A * $xpcs_fac_A) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.xpcs eq true) then 
 CNSsolve>        xpcs class pcs1 force $k_xpcs_1 end 
 CNSsolve>        xpcs class pcs2 force $k_xpcs_2 end 
 CNSsolve>        xpcs class pcs3 force $k_xpcs_3 end 
 CNSsolve>        xpcs class pcs4 force $k_xpcs_4 end 
 CNSsolve>        xpcs class pcs5 force $k_xpcs_5 end 
 CNSsolve>        xpcs class pcs6 force $k_xpcs_6 end 
 CNSsolve>        xpcs class pcs7 force $k_xpcs_7 end 
 CNSsolve>        xpcs class pcs8 force $k_xpcs_8 end 
 CNSsolve>        xpcs class pcs9 force $k_xpcs_9 end 
 CNSsolve>        xpcs class pcsA force $k_xpcs_A end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_dani_1 = $k_dani_1 * $dani_fac_1) 
 CNSsolve>      evaluate ($k_dani_2 = $k_dani_2 * $dani_fac_2) 
 CNSsolve>      evaluate ($k_dani_3 = $k_dani_3 * $dani_fac_3) 
 CNSsolve>      evaluate ($k_dani_4 = $k_dani_4 * $dani_fac_4) 
 CNSsolve>      evaluate ($k_dani_5 = $k_dani_5 * $dani_fac_5) 
 CNSsolve>      if ($Data.flags.dani eq true) then 
 CNSsolve>        dani class dan1 force $k_dani_1 end 
 CNSsolve>        dani class dan2 force $k_dani_2 end 
 CNSsolve>        dani class dan3 force $k_dani_3 end 
 CNSsolve>        dani class dan4 force $k_dani_4 end 
 CNSsolve>        dani class dan5 force $k_dani_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      if ($Data.scaling eq TRUE) then 
 CNSsolve>        inline  
 CNSsolve>! set_noe_scale.cns 
 CNSsolve>!    Set the distance restraint force constant 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($enoe   = 0.0 ) 
 CNSsolve>evaluate ($vdw    = 0.0 ) 
 CNSsolve>evaluate ($elec   = 0.0 ) 
 CNSsolve>evaluate ($einter = 0.0 ) 
 CNSsolve>evaluate ($noescale = 1.0 ) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym ne true) then 
 CNSsolve>  print threshold=0.5 noe 
 CNSsolve>  evaluate ($numnoe=$violations) 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_amb > 0) then 
 CNSsolve>    evaluate ($ambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_amb)))) 
 CNSsolve>    if ($ambcorr = 0) then 
 CNSsolve>      evaluate ($ambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($ambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_unamb > 0) then 
 CNSsolve>    evaluate ($unambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_unamb)))) 
 CNSsolve>    if ($unambcorr = 0) then 
 CNSsolve>      evaluate ($unambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($unambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve>else 
 CNSsolve>  evaluate ($unambcorr = 1) 
 CNSsolve>  evaluate ($ambcorr = 1) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>eval ($nchain1 = 0) 
 CNSsolve>igroup 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction  (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                   (segid $Toppar.prot_segid_$nchain2) weights * 1 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>  end loop nloop1 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>energy end 
 CNSsolve>igroup 
 CNSsolve>    interaction  (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($einter = abs($vdw + $elec)) 
 CNSsolve>evaluate ($enoe   = $noe) 
 CNSsolve> 
 CNSsolve>if ($enoe ne 0) then 
 CNSsolve>  evaluate ($noescale = min(5000, (2 * $einter / $enoe))) 
 CNSsolve>  if ($noescale ne 0) then 
 CNSsolve>    evaluate ($Data.unamb_hot   = $Data.unamb_hot   * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_hot     = $Data.amb_hot     * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool1 = $Data.unamb_cool1 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool1   = $Data.amb_cool1   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool2 = $Data.unamb_cool2 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool2   = $Data.amb_cool2   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool3 = $Data.unamb_cool3 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool3   = $Data.amb_cool3   * $noescale * $ambcorr) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>        noe 
 CNSsolve>           scale dist $Data.unamb_cool1 
 CNSsolve>           scale ambi $Data.amb_cool1 
 CNSsolve>           scale hbon $Data.hbond_cool1 
 CNSsolve>           asym ambi $asy 
 CNSsolve>           asym dist $asy 
 CNSsolve>           asym hbon $asy 
 CNSsolve>           masym ambi $masy 
 CNSsolve>           masym dist $masy 
 CNSsolve>           masym hbon $masy 
 CNSsolve>        end 
 CNSsolve>      else 
 CNSsolve>        noe 
 CNSsolve>           scale dist $k_unamb 
 CNSsolve>           scale ambi $k_amb 
 CNSsolve>           scale hbon $k_hbond 
 CNSsolve>           asym ambi $asy 
 CNSsolve>           asym dist $asy 
 CNSsolve>           asym hbon $asy 
 CNSsolve>           masym ambi $masy 
 CNSsolve>           masym dist $masy 
 CNSsolve>           masym hbon $masy 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      !scale intermolecular interactions 
 CNSsolve>      inline  
 CNSsolve>! scale_inter.cns 
 CNSsolve>!    Scaling of intermolecular interactions 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) weight * $Toppar.int_$nchain1_$nchain1 end 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve> 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> 
 CNSsolve>  interaction ((resn WAT or resn HOH or resn TIP*)) ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      evaluate ($kinter = $kinter + $interstep) 
 CNSsolve> 
 CNSsolve>      dyna tors 
 CNSsolve>         reassign $reassign 
 CNSsolve>         timestep=$timestep 
 CNSsolve>         nstep=$calcsteps 
 CNSsolve>         nprint=$printsteps 
 CNSsolve>         ntrfrq=0 
 CNSsolve>         tcoupling = true  temperature = $bath 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      energy end 
 CNSsolve>      if ($ener > 99999999) then 
 CNSsolve>        display ENERGY PROBLEM, THE SYSTEM IS BLOWING UP: ==> STOPPING 
 CNSsolve>	stop 
 CNSsolve>      end if 
 CNSsolve>      evaluate ($reassign = FALSE) 
 CNSsolve>end loop cool 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>{* 3 ======================================= second slow cooling *} 
 CNSsolve>{* flexible side-chains and reduced time step *} 
 CNSsolve> 
 CNSsolve>    if ($Data.flags.rg eq true ) then 
 CNSsolve>      collapse force $Data.krg_cool2 end 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($Data.flags.dihed eq true) then flags include dihed end end if 
 CNSsolve> 
 CNSsolve>    if ($SaProtocol.cool2_steps > 0) then 
 CNSsolve>      if ($torsiondone eq true) then 
 CNSsolve>        dyna tors topo reset end end 
 CNSsolve>      end if 
 CNSsolve>       
 CNSsolve>! torsiontop_flex.cns 
 CNSsolve>!    Set the topology for torsion angle MD with semi-flexible side-chains 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($nfletot = 150) 
 CNSsolve>!define flexible segments: 
 CNSsolve>display CALLING flex_segment_side.cns FOR SEMI-FLEXIBLE SA WITH SIDE-CHAINS 
 CNSsolve>inline  
 CNSsolve>! flex_segment_side.cns 
 CNSsolve>!     Define semi-flexible segments (side-chains only) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store5 = 0) (all) 
 CNSsolve>do (store6 = 0) (all) 
 CNSsolve>do (store7 = 0) (all) 
 CNSsolve> 
 CNSsolve>!first flexible segments for docking 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  evaluate($fcounter=0) 
 CNSsolve>  if ($Toppar.nseg_$nchain1 = 0) then 
 CNSsolve>    display NO FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    if ($Toppar.nseg_$nchain1 < 0) then 
 CNSsolve>      display AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE $nchain1 
 CNSsolve>      inline  
 CNSsolve>! flexauto-neighbors.cns 
 CNSsolve>!    Automatic definition of flexible segments for docking for contacting residues 
 CNSsolve>!    including neighboring residues of residues making contacts 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($flcut = 5.0) 
 CNSsolve> 
 CNSsolve>do (store5 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve>do (store7 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve> 
 CNSsolve>do (store6 = 0) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = decode($result)) 
 CNSsolve>    evaluate ($preres = $inres) 
 CNSsolve>    evaluate ($nexres = $inres) 
 CNSsolve>    if ($iteration = 1) then 
 CNSsolve>      evaluate ($preres = $preres - 1) 
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>end loop flexres1 
 CNSsolve> 
 CNSsolve>do (store5 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>do (store7 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve> 
 CNSsolve>display THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule $nchain1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = $result) 
 CNSsolve>    show (resn) (id $id) 
 CNSsolve>    evaluate ($nares = $result) 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($seres = $result) 
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
 CNSsolve>end loop flexres2 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      do (store5 = 0) (name CA or name C or name N or name O) 
 CNSsolve>    else 
 CNSsolve>      display FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>      while ($fcounter < $Toppar.nseg_$nchain1) loop Xflex 
 CNSsolve>        evaluate($fcounter=$fcounter + 1) 
 CNSsolve>        do (store5 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                                 and not(name CA or name C or name N or name O) ) 
 CNSsolve>        do (store7 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>        display FLEXIBLE SIDE-CHAINS SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>      end loop Xflex 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>!then fully flexible segments for all stages 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>      do (store7 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop2 
 CNSsolve> 
 CNSsolve>do (store5 = 7) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = 0) 
 CNSsolve>! check number of flexible residues per molecule 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop3 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and (attr store7 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numfle=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not (attr store7 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numrig=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numres=$result) 
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 CNSsolve>end loop nloop3 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = $nfletot + $result) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = $nfletot + 10) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($numtrees=$data.ncomponents) 
 CNSsolve> 
 CNSsolve>! numtrees.cns 
 CNSsolve>!    Define the number of trees for torsion angle MD 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module (numtrees; Data; Toppar;) 
 CNSsolve>(numtrees=$numtrees; Data; Toppar;) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = 1) 
 CNSsolve>evaluate ($ncount = 0) 
 CNSsolve>evaluate ($break=$data.ncomponents) 
 CNSsolve> 
 CNSsolve>while ($ncount < $data.ncomponents) loop nsloop 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = $ncount + 1) 
 CNSsolve> 
 CNSsolve>  for $id1 in id ( name C and bondedto(name CA) and segid $Toppar.prot_segid_$ncount) loop break 
 CNSsolve> 
 CNSsolve>     show (resid) (id $id1) 
 CNSsolve>     evaluate ($resid1=$result) 
 CNSsolve> 
 CNSsolve>     evaluate ($resid2=encode(decode($resid1)+1)) 
 CNSsolve> 
 CNSsolve>     show sum(1) (id $id1 and known) 
 CNSsolve>     if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>       identity (store1) ( name N and bondedto(name CA) and segid $Toppar.prot_segid_$ncount and resid $resid2 ) 
 CNSsolve>       show element (store1) (attribute store1 > 0) 
 CNSsolve>       if ( $result ne 0) then 
 CNSsolve>         evaluate ($id2=$result) 
 CNSsolve> 
 CNSsolve>         show sum(1) (id $id2 and known) 
 CNSsolve> 
 CNSsolve>         if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>           pick bond 
 CNSsolve>             (name c and segid $Toppar.prot_segid_$ncount and resid $resid1) 
 CNSsolve>             (name n and segid $Toppar.prot_segid_$ncount and resid $resid2) 
 CNSsolve>             geometry 
 CNSsolve> 
 CNSsolve>           if ( $result > 2.5 ) then 
 CNSsolve>             evaluate ($break=$break+1) 
 CNSsolve>           end if 
 CNSsolve>         else 
 CNSsolve>           evaluate ($break=$break+1) 
 CNSsolve>         end if 
 CNSsolve>       end if 
 CNSsolve>     end if 
 CNSsolve> 
 CNSsolve>   end loop break 
 CNSsolve> 
 CNSsolve>end loop nsloop 
 CNSsolve> 
 CNSsolve>! check for water molecules 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate (&numtrees = $numtrees + $break + $result) 
 CNSsolve> 
 CNSsolve>if ($data.flags.sani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xrdc eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xpcs eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.dani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = $numtrees + 30) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>DISPLAY NUMTREES set to $numtrees 
 CNSsolve> 
 CNSsolve>dyna tors 
 CNSsolve>   topology 
 CNSsolve>      maxtree $numtrees 
 CNSsolve>      kdihmax = 23. 
 CNSsolve>      evaluate ($N_atom_id = 0) 
 CNSsolve>      evaluate ($atom_id = 0) 
 CNSsolve> 
 CNSsolve>      for $atom_id in id ( name ca ) loop main 
 CNSsolve>         if ( $N_atom_id > 0 ) then 
 CNSsolve>            fix group 
 CNSsolve>            (( byresidue ( id $N_atom_id ) and 
 CNSsolve>                (name C or name O {or name CA} )) 
 CNSsolve>             or ( byresidue ( id $atom_id ) and 
 CNSsolve>                (((name N or name HN {or name CA}) {and not resn pro}) 
 CNSsolve>                {or (( name N or name CD or name CA ) and resn pro)}))) 
 CNSsolve>         end if 
 CNSsolve>         evaluate ($N_atom_id = $atom_id) 
 CNSsolve>      end loop main 
 CNSsolve>      if ( $atom_id > 0 ) then 
 CNSsolve>        fix group 
 CNSsolve>         ( byresidue ( id $atom_id ) 
 CNSsolve>            and (name c or name ot1 or name ot2 {or name CA} )) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      for $atom_id in id 
 FOR-clause=     ( name ca and (resn phe or resn trp or resn his or resn asp or resn asn or resn nep)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                          name %Z* or name %E* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn tyr)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                 name %Z* or name %E* or name OH  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn gln or resn glu)) 
 FOR-clause=      loop main	 
 CNSsolve>            fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                 and ({name CG or} name %D* or name %E*)) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn arg)) 
 FOR-clause=      loop main	 
 CNSsolve>        fix group 
 CNSsolve>          ( byresidue ( id $atom_id ) 
 CNSsolve>          and ({name CD or} name %E* or name %Z* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve>      fix group ( resn PRO and not (name c or name o) ) 
 CNSsolve> 
 CNSsolve>      !next loop is for all sugars defined in glycans-uu.top 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name c1 and (resn GCP or resn GCF or resn GTP or resn GTF or resn MNP 
 FOR-clause=	  or resn MNF or resn ALP or resn ALF or resn ARP or resn ARF or resn GLP 
 FOR-clause=	  or resn GLF or resn IDP or resn IDF or resn TLP or resn TLF or resn PCP 
 FOR-clause=	  or resn PCF or resn FTP or resn FTF or resn SBP or resn SBF or resn TTP 
 FOR-clause=	  or resn TTF or resn NAA or resn RBP or resn RBF or resn ANF or resn XLF 
 FOR-clause=	  or resn LXF or resn RLF or resn LLF)) 
 FOR-clause=      loop main	 
 CNSsolve>        fix group 
 CNSsolve>          ( byresidue ( id $atom_id ) 
 CNSsolve>          and (name %1 or name %2 or name %3 or name %4 or name %5 or name O5)) 
 CNSsolve>      end loop main 
 CNSsolve> 
 CNSsolve>      for $id in id (name C1') loop freeribose 
 CNSsolve>        free bond (id $id) (byresid (id $id) and name C2') 
 CNSsolve>      end loop freeribose 
 CNSsolve> 
 CNSsolve>      fix group ( resn HEC and (name C1* or name C2* or name C3* or name C4* or name N* or name CH*)) 
 CNSsolve> 
 CNSsolve>      fix group ( resn CYM and not (name CA or name C or name O or name OXT or 
 CNSsolve>                  name N or name HN or name HA or name CB or name HB1 or name HB2 or 
 CNSsolve>                  name SG or name SAL or name CAJ)) 
 CNSsolve> 
 CNSsolve>      fix group ( byresidue (resn WAT)) 
 CNSsolve>      fix group ( byresidue (resn HOH)) 
 CNSsolve>      fix group ( byresidue (resn TIP*)) 
 CNSsolve>      fix group ( byresidue (resn ANI)) 
 CNSsolve>      fix group ( byresidue (resn DAN)) 
 CNSsolve>      fix group ( byresidue (resn XAN)) 
 CNSsolve> 
 CNSsolve>      eval($nchain1=0) 
 CNSsolve>      while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>        eval($nchain1 = $nchain1 + 1) 
 CNSsolve>        fix group (segid $Toppar.prot_segid_$nchain1 and 
 CNSsolve>                   not (attribute store5 = $nchain1) 
 CNSsolve>		   and not ((resn WAT or resn HOH or resn TIP*))) 
 CNSsolve>      end loop nloop1 
 CNSsolve>   end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      eval ($torsiondone = true) 
 CNSsolve>      evaluate ($SaProtocol.tadfactor = 1) 
 CNSsolve>       
 CNSsolve>! sa_ltad_cool2.cns 
 CNSsolve>!   Perform the second simulation annealing stage of it1 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module(SaProtocol;Data;Toppar) 
 CNSsolve>(SaProtocol=$SaProtocol;Data=$Data;Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! module sa_ltad_cool2.cns 
 CNSsolve>! torsion dynamics cooling 
 CNSsolve> 
 CNSsolve>evaluate ($ncycle = 10) 
 CNSsolve> 
 CNSsolve>evaluate ($asy_add = (&Data.asy_cool2-&Data.asy_cool1)/$ncycle) 
 CNSsolve>evaluate ($masy_add = (&Data.masy_cool2-&Data.masy_cool1)/$ncycle) 
 CNSsolve> 
 CNSsolve>evaluate ($asy=&Data.asy_cool1) 
 CNSsolve>evaluate ($masy=&Data.masy_cool1) 
 CNSsolve> 
 CNSsolve>noe 
 CNSsolve>    rswitch ambi &Data.Rswi_cool1 
 CNSsolve>    rswitch dist &Data.Rswi_cool1 
 CNSsolve>    rswitch hbon &Data.Rswi_cool1 
 CNSsolve> 
 CNSsolve>    mrswitch ambi &Data.mRswi_cool1 
 CNSsolve>    mrswitch dist &Data.mRswi_cool1 
 CNSsolve>    mrswitch hbon &Data.mRswi_cool1 
 CNSsolve> 
 CNSsolve>    asym ambi &Data.asy_cool1 
 CNSsolve>    asym dist &Data.asy_cool1 
 CNSsolve>    asym hbon &Data.asy_cool1 
 CNSsolve> 
 CNSsolve>    masym ambi &Data.masy_cool1 
 CNSsolve>    masym dist &Data.masy_cool1 
 CNSsolve>    masym hbon &Data.masy_cool1 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>restraints dihedral   scale=&Data.dihedrals_cool2   end 
 CNSsolve>couplings class c1 force &Data.c1_cool2 end 
 CNSsolve>couplings class c2 force &Data.c2_cool2 end 
 CNSsolve>couplings class c3 force &Data.c3_cool2 end 
 CNSsolve>couplings class c4 force &Data.c4_cool2 end 
 CNSsolve>couplings class c5 force &Data.c5_cool2 end 
 CNSsolve> 
 CNSsolve>evaluate( $k_sani_1  = &Data.rdc1_cool1) 
 CNSsolve>if (&Data.rdc1_cool1 > 0) then 
 CNSsolve>  evaluate( $sani_fac_1 = ( &Data.rdc1_cool2 / &Data.rdc1_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_2  = &Data.rdc2_cool1) 
 CNSsolve>if (&Data.rdc2_cool1 > 0) then 
 CNSsolve>  evaluate( $sani_fac_2 = ( &Data.rdc2_cool2 / &Data.rdc2_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_3  = &Data.rdc3_cool1) 
 CNSsolve>if (&Data.rdc3_cool1 > 0) then 
 CNSsolve>  evaluate( $sani_fac_3 = ( &Data.rdc3_cool2 / &Data.rdc3_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_4  = &Data.rdc4_cool1) 
 CNSsolve>if (&Data.rdc4_cool1 > 0) then 
 CNSsolve>  evaluate( $sani_fac_4 = ( &Data.rdc4_cool2 / &Data.rdc4_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_5  = &Data.rdc5_cool1) 
 CNSsolve>if (&Data.rdc5_cool1 > 0) then 
 CNSsolve>  evaluate( $sani_fac_5 = ( &Data.rdc5_cool2 / &Data.rdc5_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sani eq true) then 
 CNSsolve>  sani class rdc1 force $k_sani_1 end 
 CNSsolve>  sani class rdc2 force $k_sani_2 end 
 CNSsolve>  sani class rdc3 force $k_sani_3 end 
 CNSsolve>  sani class rdc4 force $k_sani_4 end 
 CNSsolve>  sani class rdc5 force $k_sani_5 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate( $k_dani_1  = &Data.dan1_cool1) 
 CNSsolve>if (&Data.dan1_cool1 > 0) then 
 CNSsolve>  evaluate( $dani_fac_1 = ( &Data.dan1_cool2 / &Data.dan1_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_2  = &Data.dan2_cool1) 
 CNSsolve>if (&Data.dan2_cool1 > 0) then 
 CNSsolve>  evaluate( $dani_fac_2 = ( &Data.dan2_cool2 / &Data.dan2_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_3  = &Data.dan3_cool1) 
 CNSsolve>if (&Data.dan3_cool1 > 0) then 
 CNSsolve>  evaluate( $dani_fac_3 = ( &Data.dan3_cool2 / &Data.dan3_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_4  = &Data.dan4_cool1) 
 CNSsolve>if (&Data.dan4_cool1 > 0) then 
 CNSsolve>  evaluate( $dani_fac_4 = ( &Data.dan4_cool2 / &Data.dan4_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_5  = &Data.dan5_cool1) 
 CNSsolve>if (&Data.dan5_cool1 > 0) then 
 CNSsolve>  evaluate( $dani_fac_5 = ( &Data.dan5_cool2 / &Data.dan5_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.dani eq true) then 
 CNSsolve>  dani class dan1 force $k_dani_1 end 
 CNSsolve>  dani class dan2 force $k_dani_2 end 
 CNSsolve>  dani class dan3 force $k_dani_3 end 
 CNSsolve>  dani class dan4 force $k_dani_4 end 
 CNSsolve>  dani class dan5 force $k_dani_5 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate( $k_xpcs_1  = &Data.pcs1_cool1) 
 CNSsolve>if (&Data.pcs1_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_1 = ( &Data.pcs1_cool2 / &Data.pcs1_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_2  = &Data.pcs2_cool1) 
 CNSsolve>if (&Data.pcs2_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_2 = ( &Data.pcs2_cool2 / &Data.pcs2_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_3  = &Data.pcs3_cool1) 
 CNSsolve>if (&Data.pcs3_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_3 = ( &Data.pcs3_cool2 / &Data.pcs3_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_4  = &Data.pcs4_cool1) 
 CNSsolve>if (&Data.pcs4_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_4 = ( &Data.pcs4_cool2 / &Data.pcs4_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_5  = &Data.pcs5_cool1) 
 CNSsolve>if (&Data.pcs5_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_5 = ( &Data.pcs5_cool2 / &Data.pcs5_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_6  = &Data.pcs6_cool1) 
 CNSsolve>if (&Data.pcs6_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_6 = ( &Data.pcs6_cool2 / &Data.pcs6_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_6 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_7  = &Data.pcs7_cool1) 
 CNSsolve>if (&Data.pcs7_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_7 = ( &Data.pcs7_cool2 / &Data.pcs7_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_7 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_8  = &Data.pcs8_cool1) 
 CNSsolve>if (&Data.pcs8_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_8 = ( &Data.pcs8_cool2 / &Data.pcs8_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_8 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_9  = &Data.pcs9_cool1) 
 CNSsolve>if (&Data.pcs9_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_9 = ( &Data.pcs9_cool2 / &Data.pcs9_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_9 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_A  = &Data.pcsA_cool1) 
 CNSsolve>if (&Data.pcsA_cool1 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_A = ( &Data.pcsA_cool2 / &Data.pcsA_cool1)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_A = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($Data.flags.xpcs eq true) then 
 CNSsolve>  xpcs class pcs1 force $k_xpcs_1 end 
 CNSsolve>  xpcs class pcs2 force $k_xpcs_2 end 
 CNSsolve>  xpcs class pcs3 force $k_xpcs_3 end 
 CNSsolve>  xpcs class pcs4 force $k_xpcs_4 end 
 CNSsolve>  xpcs class pcs5 force $k_xpcs_5 end 
 CNSsolve>  xpcs class pcs6 force $k_xpcs_6 end 
 CNSsolve>  xpcs class pcs7 force $k_xpcs_7 end 
 CNSsolve>  xpcs class pcs8 force $k_xpcs_8 end 
 CNSsolve>  xpcs class pcs9 force $k_xpcs_9 end 
 CNSsolve>  xpcs class pcsA force $k_xpcs_A end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($interstep = (&SaProtocol.inter_fin_cool2 - &SaProtocol.inter_init_cool2)/($ncycle-1)) 
 CNSsolve>evaluate ($kinter = &SaProtocol.inter_init_cool2) 
 CNSsolve> 
 CNSsolve>evaluate ($tempstep = (&SaProtocol.t2_init - &SaProtocol.t2_final)/$ncycle) 
 CNSsolve>evaluate ($calcsteps = int(&SaProtocol.cool2_steps/$ncycle)) 
 CNSsolve>evaluate ($printsteps = int($calcsteps / 4)) 
 CNSsolve>evaluate ($timestep = &SaProtocol.timestep*&SaProtocol.tadfactor) 
 CNSsolve> 
 CNSsolve>if (&Data.unamb_cool1 = 0) then 
 CNSsolve>  evaluate (&Data.unamb_cool1 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.unamb_cool2 = 0) then 
 CNSsolve>  evaluate (&Data.unamb_cool2 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.amb_cool1 = 0) then 
 CNSsolve>  evaluate (&Data.amb_cool1 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.amb_cool2 = 0) then 
 CNSsolve>  evaluate (&Data.amb_cool2 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.hbond_cool1 = 0) then 
 CNSsolve>  evaluate (&Data.hbond_cool1 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.hbond_cool2 = 0) then 
 CNSsolve>  evaluate (&Data.hbond_cool2 = 0.000001) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($k_unamb= &Data.unamb_cool1) 
 CNSsolve>evaluate ($unamb_fac = (&Data.unamb_cool2/&Data.unamb_cool1)^(1/$ncycle)) 
 CNSsolve>evaluate ($k_amb= &Data.amb_cool1) 
 CNSsolve>evaluate ($amb_fac = (&Data.amb_cool2/&Data.amb_cool1)^(1/$ncycle)) 
 CNSsolve>evaluate ($k_hbond= &Data.hbond_cool1) 
 CNSsolve>evaluate ($hbond_fac = (&Data.hbond_cool2/&Data.hbond_cool1)^(1/$ncycle)) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!for the vean statement: 
 CNSsolve>evaluate( $k_cen_1 = &Data.ini_cen_cool2_1) 
 CNSsolve>evaluate( $cen_fac_1 = ( &Data.fin_cen_cool2_1 / &Data.ini_cen_cool2_1)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_1 = &Data.ini_bor_cool2_1) 
 CNSsolve>evaluate( $bor_fac_1 = ( &Data.fin_bor_cool2_1 / &Data.ini_bor_cool2_1)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_2 = &Data.ini_cen_cool2_2) 
 CNSsolve>evaluate( $cen_fac_2 = ( &Data.fin_cen_cool2_2 / &Data.ini_cen_cool2_2)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_2 = &Data.ini_bor_cool2_2) 
 CNSsolve>evaluate( $bor_fac_2 = ( &Data.fin_bor_cool2_2 / &Data.ini_bor_cool2_2)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_3 = &Data.ini_cen_cool2_3) 
 CNSsolve>evaluate( $cen_fac_3 = ( &Data.fin_cen_cool2_3 / &Data.ini_cen_cool2_3)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_3 = &Data.ini_bor_cool2_3) 
 CNSsolve>evaluate( $bor_fac_3 = ( &Data.fin_bor_cool2_3 / &Data.ini_bor_cool2_3)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_4 = &Data.ini_cen_cool2_4) 
 CNSsolve>evaluate( $cen_fac_4 = ( &Data.fin_cen_cool2_4 / &Data.ini_cen_cool2_4)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_4 = &Data.ini_bor_cool2_4) 
 CNSsolve>evaluate( $bor_fac_4 = ( &Data.fin_bor_cool2_4 / &Data.ini_bor_cool2_4)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_5 = &Data.ini_cen_cool2_5) 
 CNSsolve>evaluate( $cen_fac_5 = ( &Data.fin_cen_cool2_5 / &Data.ini_cen_cool2_5)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_5 = &Data.ini_bor_cool2_5) 
 CNSsolve>evaluate( $bor_fac_5 = ( &Data.fin_bor_cool2_5 / &Data.ini_bor_cool2_5)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate ($bath  = &SaProtocol.t2_init) 
 CNSsolve>do (vx=maxwell($bath)) ( all ) 
 CNSsolve>do (vy=maxwell($bath)) ( all ) 
 CNSsolve>do (vz=maxwell($bath)) ( all ) 
 CNSsolve> 
 CNSsolve>evaluate ($reassign = TRUE) 
 CNSsolve>evaluate ($i_cool = 0) 
 CNSsolve>while ($i_cool < $ncycle) loop cool 
 CNSsolve> 
 CNSsolve>      evaluate ($i_cool=$i_cool+1) 
 CNSsolve> 
 CNSsolve>      evaluate ($bath  = $bath  - $tempstep) 
 CNSsolve>      evaluate ($k_unamb = $k_unamb*$unamb_fac) 
 CNSsolve>      evaluate ($k_amb = $k_amb*$amb_fac) 
 CNSsolve>      evaluate ($k_hbond = $k_hbond*$hbond_fac) 
 CNSsolve>      evaluate ($asy=$asy+$asy_add) 
 CNSsolve>      evaluate ($masy=$masy+$masy_add) 
 CNSsolve> 
 CNSsolve>      evaluate ($k_bor_1 = $k_bor_1 * $bor_fac_1) 
 CNSsolve>      evaluate ($k_bor_2 = $k_bor_2 * $bor_fac_2) 
 CNSsolve>      evaluate ($k_bor_3 = $k_bor_3 * $bor_fac_3) 
 CNSsolve>      evaluate ($k_bor_4 = $k_bor_4 * $bor_fac_4) 
 CNSsolve>      evaluate ($k_bor_5 = $k_bor_5 * $bor_fac_5) 
 CNSsolve> 
 CNSsolve>      evaluate ($k_cen_1 = $k_cen_1 * $cen_fac_1) 
 CNSsolve>      evaluate ($k_cen_2 = $k_cen_2 * $cen_fac_2) 
 CNSsolve>      evaluate ($k_cen_3 = $k_cen_3 * $cen_fac_3) 
 CNSsolve>      evaluate ($k_cen_4 = $k_cen_4 * $cen_fac_4) 
 CNSsolve>      evaluate ($k_cen_5 = $k_cen_5 * $cen_fac_5) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.vean eq true) then 
 CNSsolve>        vean class vea1 force $k_bor_1 $k_cen_1 end 
 CNSsolve>        vean class vea2 force $k_bor_2 $k_cen_2 end 
 CNSsolve>        vean class vea3 force $k_bor_3 $k_cen_3 end 
 CNSsolve>        vean class vea4 force $k_bor_4 $k_cen_4 end 
 CNSsolve>        vean class vea5 force $k_bor_5 $k_cen_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_sani_1 = $k_sani_1 * $sani_fac_1) 
 CNSsolve>      evaluate ($k_sani_2 = $k_sani_2 * $sani_fac_2) 
 CNSsolve>      evaluate ($k_sani_3 = $k_sani_3 * $sani_fac_3) 
 CNSsolve>      evaluate ($k_sani_4 = $k_sani_4 * $sani_fac_4) 
 CNSsolve>      evaluate ($k_sani_5 = $k_sani_5 * $sani_fac_5) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.sani eq true) then 
 CNSsolve>        sani class rdc1 force $k_sani_1 end 
 CNSsolve>        sani class rdc2 force $k_sani_2 end 
 CNSsolve>        sani class rdc3 force $k_sani_3 end 
 CNSsolve>        sani class rdc4 force $k_sani_4 end 
 CNSsolve>        sani class rdc5 force $k_sani_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_xpcs_1 = $k_xpcs_1 * $xpcs_fac_1) 
 CNSsolve>      evaluate ($k_xpcs_2 = $k_xpcs_2 * $xpcs_fac_2) 
 CNSsolve>      evaluate ($k_xpcs_3 = $k_xpcs_3 * $xpcs_fac_3) 
 CNSsolve>      evaluate ($k_xpcs_4 = $k_xpcs_4 * $xpcs_fac_4) 
 CNSsolve>      evaluate ($k_xpcs_5 = $k_xpcs_5 * $xpcs_fac_5) 
 CNSsolve>      evaluate ($k_xpcs_6 = $k_xpcs_6 * $xpcs_fac_6) 
 CNSsolve>      evaluate ($k_xpcs_7 = $k_xpcs_7 * $xpcs_fac_7) 
 CNSsolve>      evaluate ($k_xpcs_8 = $k_xpcs_8 * $xpcs_fac_8) 
 CNSsolve>      evaluate ($k_xpcs_9 = $k_xpcs_9 * $xpcs_fac_9) 
 CNSsolve>      evaluate ($k_xpcs_A = $k_xpcs_A * $xpcs_fac_A) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.xpcs eq true) then 
 CNSsolve>        xpcs class pcs1 force $k_xpcs_1 end 
 CNSsolve>        xpcs class pcs2 force $k_xpcs_2 end 
 CNSsolve>        xpcs class pcs3 force $k_xpcs_3 end 
 CNSsolve>        xpcs class pcs4 force $k_xpcs_4 end 
 CNSsolve>        xpcs class pcs5 force $k_xpcs_5 end 
 CNSsolve>        xpcs class pcs6 force $k_xpcs_6 end 
 CNSsolve>        xpcs class pcs7 force $k_xpcs_7 end 
 CNSsolve>        xpcs class pcs8 force $k_xpcs_8 end 
 CNSsolve>        xpcs class pcs9 force $k_xpcs_9 end 
 CNSsolve>        xpcs class pcsA force $k_xpcs_A end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_dani_1 = $k_dani_1 * $dani_fac_1) 
 CNSsolve>      evaluate ($k_dani_2 = $k_dani_2 * $dani_fac_2) 
 CNSsolve>      evaluate ($k_dani_3 = $k_dani_3 * $dani_fac_3) 
 CNSsolve>      evaluate ($k_dani_4 = $k_dani_4 * $dani_fac_4) 
 CNSsolve>      evaluate ($k_dani_5 = $k_dani_5 * $dani_fac_5) 
 CNSsolve>      if ($Data.flags.dani eq true) then 
 CNSsolve>        dani class dan1 force $k_dani_1 end 
 CNSsolve>        dani class dan2 force $k_dani_2 end 
 CNSsolve>        dani class dan3 force $k_dani_3 end 
 CNSsolve>        dani class dan4 force $k_dani_4 end 
 CNSsolve>        dani class dan5 force $k_dani_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      if ($Data.scaling eq TRUE) then 
 CNSsolve>        inline  
 CNSsolve>! set_noe_scale.cns 
 CNSsolve>!    Set the distance restraint force constant 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($enoe   = 0.0 ) 
 CNSsolve>evaluate ($vdw    = 0.0 ) 
 CNSsolve>evaluate ($elec   = 0.0 ) 
 CNSsolve>evaluate ($einter = 0.0 ) 
 CNSsolve>evaluate ($noescale = 1.0 ) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym ne true) then 
 CNSsolve>  print threshold=0.5 noe 
 CNSsolve>  evaluate ($numnoe=$violations) 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_amb > 0) then 
 CNSsolve>    evaluate ($ambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_amb)))) 
 CNSsolve>    if ($ambcorr = 0) then 
 CNSsolve>      evaluate ($ambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($ambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_unamb > 0) then 
 CNSsolve>    evaluate ($unambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_unamb)))) 
 CNSsolve>    if ($unambcorr = 0) then 
 CNSsolve>      evaluate ($unambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($unambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve>else 
 CNSsolve>  evaluate ($unambcorr = 1) 
 CNSsolve>  evaluate ($ambcorr = 1) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>eval ($nchain1 = 0) 
 CNSsolve>igroup 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction  (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                   (segid $Toppar.prot_segid_$nchain2) weights * 1 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>  end loop nloop1 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>energy end 
 CNSsolve>igroup 
 CNSsolve>    interaction  (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($einter = abs($vdw + $elec)) 
 CNSsolve>evaluate ($enoe   = $noe) 
 CNSsolve> 
 CNSsolve>if ($enoe ne 0) then 
 CNSsolve>  evaluate ($noescale = min(5000, (2 * $einter / $enoe))) 
 CNSsolve>  if ($noescale ne 0) then 
 CNSsolve>    evaluate ($Data.unamb_hot   = $Data.unamb_hot   * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_hot     = $Data.amb_hot     * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool1 = $Data.unamb_cool1 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool1   = $Data.amb_cool1   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool2 = $Data.unamb_cool2 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool2   = $Data.amb_cool2   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool3 = $Data.unamb_cool3 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool3   = $Data.amb_cool3   * $noescale * $ambcorr) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>        noe 
 CNSsolve>           scale dist $Data.unamb_cool2 
 CNSsolve>           scale ambi $Data.amb_cool2 
 CNSsolve>           scale hbon $Data.hbond_cool2 
 CNSsolve>           asym ambi $asy 
 CNSsolve>           asym dist $asy 
 CNSsolve>           asym hbon $asy 
 CNSsolve>           masym ambi $masy 
 CNSsolve>           masym dist $masy 
 CNSsolve>           masym hbon $masy 
 CNSsolve>        end 
 CNSsolve>      else 
 CNSsolve>        noe 
 CNSsolve>           scale dist $k_unamb 
 CNSsolve>           scale ambi $k_amb 
 CNSsolve>           scale hbon $k_hbond 
 CNSsolve>           asym ambi $asy 
 CNSsolve>           asym dist $asy 
 CNSsolve>           asym hbon $asy 
 CNSsolve>           masym ambi $masy 
 CNSsolve>           masym dist $masy 
 CNSsolve>           masym hbon $masy 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      !scale intermolecular interactions: 
 CNSsolve>      inline  
 CNSsolve>! scale_inter.cns 
 CNSsolve>!    Scaling of intermolecular interactions 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) weight * $Toppar.int_$nchain1_$nchain1 end 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve> 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> 
 CNSsolve>  interaction ((resn WAT or resn HOH or resn TIP*)) ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      evaluate ($kinter = $kinter + $interstep) 
 CNSsolve> 
 CNSsolve>      dyna tors 
 CNSsolve>         reassign $reassign 
 CNSsolve>         timestep=$timestep 
 CNSsolve>         nstep=$calcsteps 
 CNSsolve>         nprint=$printsteps 
 CNSsolve>         ntrfrq=0 
 CNSsolve>         tcoupling = true  temperature = $bath 
 CNSsolve>      end 
 CNSsolve>      evaluate ($reassign = FALSE) 
 CNSsolve> 
 CNSsolve>      energy end 
 CNSsolve>      if ($ener > 99999999) then 
 CNSsolve>        display ENERGY PROBLEM, THE SYSTEM IS BLOWING UP: ==> STOPPING 
 CNSsolve>        stop 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>end loop cool 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>{* 4 ============================================ third slow cooling *} 
 CNSsolve>{* flexible side-chains and backbone at interface and reduced time step *} 
 CNSsolve> 
 CNSsolve>    if ($Data.flags.rg eq true ) then 
 CNSsolve>      collapse force $Data.krg_cool3 end 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    if ($SaProtocol.cool3_steps > 0) then 
 CNSsolve>      if ($torsiondone eq true) then 
 CNSsolve>        dyna tors topo reset end end 
 CNSsolve>      end if 
 CNSsolve>       
 CNSsolve>! torsiontop_flex_back.cns 
 CNSsolve>!    Set the topology for torsion angle MD with semi-flexible side-chains 
 CNSsolve>!    and backbone at the interface 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($nfletot = 150) 
 CNSsolve>!define flexible segments: 
 CNSsolve>display CALLING flex_segment_back.cns FOR SEMI-FLEXIBLE SA WITH BACKBONE 
 CNSsolve>inline  
 CNSsolve>! flex_segment_back.cns 
 CNSsolve>!    Define the semi-flexible segments (both side-chains and backbone) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store5 = 0) (all) 
 CNSsolve>do (store6 = 0) (all) 
 CNSsolve>do (store7 = 0) (all) 
 CNSsolve> 
 CNSsolve>!first flexible segments for docking 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  evaluate($fcounter=0) 
 CNSsolve> 
 CNSsolve>  if ($Toppar.nseg_$nchain1 = 0) then 
 CNSsolve>    display NO FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    if ($Toppar.nseg_$nchain1 < 0) then 
 CNSsolve>      display AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE $nchain1 
 CNSsolve>      inline  
 CNSsolve>! flexauto-neighbors.cns 
 CNSsolve>!    Automatic definition of flexible segments for docking for contacting residues 
 CNSsolve>!    including neighboring residues of residues making contacts 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($flcut = 5.0) 
 CNSsolve> 
 CNSsolve>do (store5 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve>do (store7 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve> 
 CNSsolve>do (store6 = 0) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = decode($result)) 
 CNSsolve>    evaluate ($preres = $inres) 
 CNSsolve>    evaluate ($nexres = $inres) 
 CNSsolve>    if ($iteration = 1) then 
 CNSsolve>      evaluate ($preres = $preres - 1) 
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>end loop flexres1 
 CNSsolve> 
 CNSsolve>do (store5 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>do (store7 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve> 
 CNSsolve>display THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule $nchain1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = $result) 
 CNSsolve>    show (resn) (id $id) 
 CNSsolve>    evaluate ($nares = $result) 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($seres = $result) 
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
 CNSsolve>end loop flexres2 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    else 
 CNSsolve>      display FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>      while ($fcounter < $Toppar.nseg_$nchain1) loop Xflex 
 CNSsolve>        evaluate($fcounter=$fcounter + 1) 
 CNSsolve>        do (store5 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>        display FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>      end loop Xflex 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>!then fully flexible segments for all stages 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop2 
 CNSsolve> 
 CNSsolve>do (store5 = 7) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = 0) 
 CNSsolve> 
 CNSsolve>! check number of flexible residues per molecule 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop3 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and (attr store5 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numfle=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not (attr store5 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numrig=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numres=$result) 
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 CNSsolve>end loop nloop3 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = $nfletot + $result) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = $nfletot + 10) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($numtrees=$data.ncomponents) 
 CNSsolve> 
 CNSsolve>! numtrees.cns 
 CNSsolve>!    Define the number of trees for torsion angle MD 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module (numtrees; Data; Toppar;) 
 CNSsolve>(numtrees=$numtrees; Data; Toppar;) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = 1) 
 CNSsolve>evaluate ($ncount = 0) 
 CNSsolve>evaluate ($break=$data.ncomponents) 
 CNSsolve> 
 CNSsolve>while ($ncount < $data.ncomponents) loop nsloop 
 CNSsolve> 
 CNSsolve>  evaluate ($ncount = $ncount + 1) 
 CNSsolve> 
 CNSsolve>  for $id1 in id ( name C and bondedto(name CA) and segid $Toppar.prot_segid_$ncount) loop break 
 CNSsolve> 
 CNSsolve>     show (resid) (id $id1) 
 CNSsolve>     evaluate ($resid1=$result) 
 CNSsolve> 
 CNSsolve>     evaluate ($resid2=encode(decode($resid1)+1)) 
 CNSsolve> 
 CNSsolve>     show sum(1) (id $id1 and known) 
 CNSsolve>     if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>       identity (store1) ( name N and bondedto(name CA) and segid $Toppar.prot_segid_$ncount and resid $resid2 ) 
 CNSsolve>       show element (store1) (attribute store1 > 0) 
 CNSsolve>       if ( $result ne 0) then 
 CNSsolve>         evaluate ($id2=$result) 
 CNSsolve> 
 CNSsolve>         show sum(1) (id $id2 and known) 
 CNSsolve> 
 CNSsolve>         if ( $result ne 0 ) then 
 CNSsolve> 
 CNSsolve>           pick bond 
 CNSsolve>             (name c and segid $Toppar.prot_segid_$ncount and resid $resid1) 
 CNSsolve>             (name n and segid $Toppar.prot_segid_$ncount and resid $resid2) 
 CNSsolve>             geometry 
 CNSsolve> 
 CNSsolve>           if ( $result > 2.5 ) then 
 CNSsolve>             evaluate ($break=$break+1) 
 CNSsolve>           end if 
 CNSsolve>         else 
 CNSsolve>           evaluate ($break=$break+1) 
 CNSsolve>         end if 
 CNSsolve>       end if 
 CNSsolve>     end if 
 CNSsolve> 
 CNSsolve>   end loop break 
 CNSsolve> 
 CNSsolve>end loop nsloop 
 CNSsolve> 
 CNSsolve>! check for water molecules 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate (&numtrees = $numtrees + $break + $result) 
 CNSsolve> 
 CNSsolve>if ($data.flags.sani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xrdc eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.xpcs eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve>if ($data.flags.dani eq true) then 
 CNSsolve>  evaluate (&numtrees = $numtrees + 5) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate (&numtrees = $numtrees + 30) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>DISPLAY NUMTREES set to $numtrees 
 CNSsolve> 
 CNSsolve>dyna tors 
 CNSsolve>   topology 
 CNSsolve>      maxtree $numtrees 
 CNSsolve>      kdihmax = 23. 
 CNSsolve>      evaluate ($N_atom_id = 0) 
 CNSsolve>      evaluate ($atom_id = 0) 
 CNSsolve> 
 CNSsolve>      for $atom_id in id ( name ca ) loop main 
 CNSsolve>         if ( $N_atom_id > 0 ) then 
 CNSsolve>            fix group 
 CNSsolve>            (( byresidue ( id $N_atom_id ) and 
 CNSsolve>                (name C or name O {or name CA} )) 
 CNSsolve>             or ( byresidue ( id $atom_id ) and 
 CNSsolve>                (((name N or name HN {or name CA}) {and not resn pro}) 
 CNSsolve>                {or (( name N or name CD or name CA ) and resn pro)}))) 
 CNSsolve>         end if 
 CNSsolve>         evaluate ($N_atom_id = $atom_id) 
 CNSsolve>      end loop main 
 CNSsolve>      if ( $atom_id > 0 ) then 
 CNSsolve>        fix group 
 CNSsolve>           ( byresidue ( id $atom_id ) 
 CNSsolve>            and (name c or name ot1 or name ot2 {or name CA} )) 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      for $atom_id in id 
 FOR-clause=     ( name ca and (resn phe or resn trp or resn his or resn asp or resn asn or resn nep)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                          name %Z* or name %E* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn tyr)) 
 FOR-clause=      loop main	 
 CNSsolve>         fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                     and ({name CB or} name CG or name %D* or 
 CNSsolve>                 name %Z* or name %E* or name OH  )) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn gln or resn glu)) 
 FOR-clause=      loop main	 
 CNSsolve>            fix group 
 CNSsolve>               ( byresidue ( id $atom_id ) 
 CNSsolve>                 and ({name CG or} name %D* or name %E*)) 
 CNSsolve>      end loop main 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name ca and (resn arg)) 
 FOR-clause=      loop main	 
 CNSsolve>        fix group 
 CNSsolve>          ( byresidue ( id $atom_id ) 
 CNSsolve>          and ({name CD or} name %E* or name %Z* or name %H*  )) 
 CNSsolve>      end loop main 
 CNSsolve> 
 CNSsolve>      !next loop is for all sugars defined in glycans-uu.top 
 CNSsolve>      for $atom_id in id 
 FOR-clause=        ( name c1 and (resn GCP or resn GCF or resn GTP or resn GTF or resn MNP 
 FOR-clause=	  or resn MNF or resn ALP or resn ALF or resn ARP or resn ARF or resn GLP 
 FOR-clause=	  or resn GLF or resn IDP or resn IDF or resn TLP or resn TLF or resn PCP 
 FOR-clause=	  or resn PCF or resn FTP or resn FTF or resn SBP or resn SBF or resn TTP 
 FOR-clause=	  or resn TTF or resn NAA or resn RBP or resn RBF or resn ANF or resn XLF 
 FOR-clause=	  or resn LXF or resn RLF or resn LLF)) 
 FOR-clause=      loop main	 
 CNSsolve>        fix group 
 CNSsolve>          ( byresidue ( id $atom_id ) 
 CNSsolve>          and (name %1 or name %2 or name %3 or name %4 or name %5 or name O5)) 
 CNSsolve>      end loop main 
 CNSsolve> 
 CNSsolve>      fix group ( resn HEC and (name C1* or name C2* or name C3* or name C4* or name N* or name CH*)) 
 CNSsolve> 
 CNSsolve>      fix group ( resn PRO and not (name c or name o) ) 
 CNSsolve> 
 CNSsolve>      fix group ( resn CYM and not (name CA or name C or name O or name OXT or 
 CNSsolve>                  name N or name HN or name HA or name CB or name HB1 or name HB2 or 
 CNSsolve>                  name SG or name SAL or name CAJ)) 
 CNSsolve> 
 CNSsolve>      fix group ( byresidue (resn WAT)) 
 CNSsolve>      fix group ( byresidue (resn HOH)) 
 CNSsolve>      fix group ( byresidue (resn TIP*)) 
 CNSsolve>      fix group ( byresidue (resn ANI)) 
 CNSsolve>      fix group ( byresidue (resn DAN)) 
 CNSsolve>      fix group ( byresidue (resn XAN)) 
 CNSsolve> 
 CNSsolve>      for $id in id (name C1') loop freeribose 
 CNSsolve>        free bond (id $id) (byresid (id $id) and name C2') 
 CNSsolve>      end loop freeribose 
 CNSsolve>      eval($nchain1 = 0) 
 CNSsolve>      while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>        eval($nchain1 = $nchain1 + 1) 
 CNSsolve>        fix group (segid $Toppar.prot_segid_$nchain1 and 
 CNSsolve>                   not (attribute store5 = $nchain1) 
 CNSsolve>		   and not ((resn WAT or resn HOH or resn TIP*))) 
 CNSsolve>      end loop nloop1 
 CNSsolve>   end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      eval ($torsiondone = true) 
 CNSsolve>      evaluate ($SaProtocol.tadfactor = 1) 
 CNSsolve>       
 CNSsolve>! sa_ltad_cool3.cns 
 CNSsolve>!    Perfrom the third simulated annealing stage of it1 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>module(SaProtocol;Data;Toppar) 
 CNSsolve>(SaProtocol=$SaProtocol;Data=$Data;Toppar=$Toppar) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! module sa_ltad_cool3.cns 
 CNSsolve>! torsion dynamics cooling 
 CNSsolve> 
 CNSsolve>evaluate ($ncycle = 20) 
 CNSsolve> 
 CNSsolve>evaluate ($asy_add = (&Data.asy_cool3-&Data.asy_cool2)/$ncycle) 
 CNSsolve>evaluate ($masy_add = (&Data.masy_cool3-&Data.masy_cool2)/$ncycle) 
 CNSsolve> 
 CNSsolve>evaluate ($asy=&Data.asy_cool2) 
 CNSsolve>evaluate ($masy=&Data.masy_cool2) 
 CNSsolve> 
 CNSsolve>noe 
 CNSsolve>    rswitch ambi &Data.Rswi_cool2 
 CNSsolve>    rswitch dist &Data.Rswi_cool2 
 CNSsolve>    rswitch hbon &Data.Rswi_cool2 
 CNSsolve> 
 CNSsolve>    mrswitch ambi &Data.mRswi_cool2 
 CNSsolve>    mrswitch dist &Data.mRswi_cool2 
 CNSsolve>    mrswitch hbon &Data.mRswi_cool2 
 CNSsolve> 
 CNSsolve>    asym ambi &Data.asy_cool2 
 CNSsolve>    asym dist &Data.asy_cool2 
 CNSsolve>    asym hbon &Data.asy_cool2 
 CNSsolve> 
 CNSsolve>    masym ambi &Data.masy_cool2 
 CNSsolve>    masym dist &Data.masy_cool2 
 CNSsolve>    masym hbon &Data.masy_cool2 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>restraints dihedral   scale=&Data.dihedrals_cool3   end 
 CNSsolve>couplings class c1 force &Data.c1_cool3 end 
 CNSsolve>couplings class c2 force &Data.c2_cool3 end 
 CNSsolve>couplings class c3 force &Data.c3_cool3 end 
 CNSsolve>couplings class c4 force &Data.c4_cool3 end 
 CNSsolve>couplings class c5 force &Data.c5_cool3 end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate( $k_sani_1  = &Data.rdc1_cool2) 
 CNSsolve>if (&Data.rdc1_cool2 > 0) then 
 CNSsolve>  evaluate( $sani_fac_1 = ( &Data.rdc1_cool3 / &Data.rdc1_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_2  = &Data.rdc2_cool2) 
 CNSsolve>if (&Data.rdc2_cool2 > 0) then 
 CNSsolve>  evaluate( $sani_fac_2 = ( &Data.rdc2_cool3 / &Data.rdc2_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_3  = &Data.rdc3_cool2) 
 CNSsolve>if (&Data.rdc3_cool2 > 0) then 
 CNSsolve>  evaluate( $sani_fac_3 = ( &Data.rdc3_cool3 / &Data.rdc3_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_4  = &Data.rdc4_cool2) 
 CNSsolve>if (&Data.rdc4_cool2 > 0) then 
 CNSsolve>  evaluate( $sani_fac_4 = ( &Data.rdc4_cool3 / &Data.rdc4_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_sani_5  = &Data.rdc5_cool2) 
 CNSsolve>if (&Data.rdc5_cool2 > 0) then 
 CNSsolve>  evaluate( $sani_fac_5 = ( &Data.rdc5_cool3 / &Data.rdc5_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $sani_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sani eq true) then 
 CNSsolve>  sani class rdc1 force $k_sani_1 end 
 CNSsolve>  sani class rdc2 force $k_sani_2 end 
 CNSsolve>  sani class rdc3 force $k_sani_3 end 
 CNSsolve>  sani class rdc4 force $k_sani_4 end 
 CNSsolve>  sani class rdc5 force $k_sani_5 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate( $k_dani_1  = &Data.dan1_cool2) 
 CNSsolve>if (&Data.dan1_cool2 > 0) then 
 CNSsolve>  evaluate( $dani_fac_1 = ( &Data.dan1_cool3 / &Data.dan1_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_2  = &Data.dan2_cool2) 
 CNSsolve>if (&Data.dan2_cool2 > 0) then 
 CNSsolve>  evaluate( $dani_fac_2 = ( &Data.dan2_cool3 / &Data.dan2_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_3  = &Data.dan3_cool2) 
 CNSsolve>if (&Data.dan3_cool2 > 0) then 
 CNSsolve>  evaluate( $dani_fac_3 = ( &Data.dan3_cool3 / &Data.dan3_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_4  = &Data.dan4_cool2) 
 CNSsolve>if (&Data.dan4_cool2 > 0) then 
 CNSsolve>  evaluate( $dani_fac_4 = ( &Data.dan4_cool3 / &Data.dan4_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_dani_5  = &Data.dan5_cool2) 
 CNSsolve>if (&Data.dan5_cool2 > 0) then 
 CNSsolve>  evaluate( $dani_fac_5 = ( &Data.dan5_cool3 / &Data.dan5_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $dani_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.dani eq true) then 
 CNSsolve>  dani class dan1 force $k_dani_1 end 
 CNSsolve>  dani class dan2 force $k_dani_2 end 
 CNSsolve>  dani class dan3 force $k_dani_3 end 
 CNSsolve>  dani class dan4 force $k_dani_4 end 
 CNSsolve>  dani class dan5 force $k_dani_5 end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate( $k_xpcs_1  = &Data.pcs1_cool2) 
 CNSsolve>if (&Data.pcs1_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_1 = ( &Data.pcs1_cool3 / &Data.pcs1_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_1 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_2  = &Data.pcs2_cool2) 
 CNSsolve>if (&Data.pcs2_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_2 = ( &Data.pcs2_cool3 / &Data.pcs2_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_2 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_3  = &Data.pcs3_cool2) 
 CNSsolve>if (&Data.pcs3_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_3 = ( &Data.pcs3_cool3 / &Data.pcs3_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_3 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_4  = &Data.pcs4_cool2) 
 CNSsolve>if (&Data.pcs4_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_4 = ( &Data.pcs4_cool3 / &Data.pcs4_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_4 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_5  = &Data.pcs5_cool2) 
 CNSsolve>if (&Data.pcs5_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_5 = ( &Data.pcs5_cool3 / &Data.pcs5_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_5 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_6  = &Data.pcs6_cool2) 
 CNSsolve>if (&Data.pcs6_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_6 = ( &Data.pcs6_cool3 / &Data.pcs6_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_6 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_7  = &Data.pcs7_cool2) 
 CNSsolve>if (&Data.pcs7_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_7 = ( &Data.pcs7_cool3 / &Data.pcs7_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_7 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_8  = &Data.pcs8_cool2) 
 CNSsolve>if (&Data.pcs8_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_8 = ( &Data.pcs8_cool3 / &Data.pcs8_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_8 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_9  = &Data.pcs9_cool2) 
 CNSsolve>if (&Data.pcs9_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_9 = ( &Data.pcs9_cool3 / &Data.pcs9_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_9 = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $k_xpcs_A  = &Data.pcsA_cool2) 
 CNSsolve>if (&Data.pcsA_cool2 > 0) then 
 CNSsolve>  evaluate( $xpcs_fac_A = ( &Data.pcsA_cool3 / &Data.pcsA_cool2)^( 1 / $ncycle)) 
 CNSsolve>else 
 CNSsolve>  evaluate( $xpcs_fac_A = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($Data.flags.xpcs eq true) then 
 CNSsolve>  xpcs class pcs1 force $k_xpcs_1 end 
 CNSsolve>  xpcs class pcs2 force $k_xpcs_2 end 
 CNSsolve>  xpcs class pcs3 force $k_xpcs_3 end 
 CNSsolve>  xpcs class pcs4 force $k_xpcs_4 end 
 CNSsolve>  xpcs class pcs5 force $k_xpcs_5 end 
 CNSsolve>  xpcs class pcs6 force $k_xpcs_6 end 
 CNSsolve>  xpcs class pcs7 force $k_xpcs_7 end 
 CNSsolve>  xpcs class pcs8 force $k_xpcs_8 end 
 CNSsolve>  xpcs class pcs9 force $k_xpcs_9 end 
 CNSsolve>  xpcs class pcsA force $k_xpcs_A end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>evaluate ($interstep = (&SaProtocol.inter_fin_cool3 - &SaProtocol.inter_init_cool3)/($ncycle-1)) 
 CNSsolve>evaluate ($kinter = &SaProtocol.inter_init_cool3) 
 CNSsolve> 
 CNSsolve>evaluate ($tempstep = (&SaProtocol.t3_init - &SaProtocol.t3_final)/$ncycle) 
 CNSsolve>evaluate ($calcsteps = int(&SaProtocol.cool3_steps/$ncycle)) 
 CNSsolve>evaluate ($printsteps = int($calcsteps / 4)) 
 CNSsolve>evaluate ($timestep = &SaProtocol.timestep*&SaProtocol.tadfactor) 
 CNSsolve> 
 CNSsolve>if (&Data.unamb_cool2 = 0) then 
 CNSsolve>  evaluate (&Data.unamb_cool2 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.unamb_cool3 = 0) then 
 CNSsolve>  evaluate (&Data.unamb_cool3 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.amb_cool2 = 0) then 
 CNSsolve>  evaluate (&Data.amb_cool2 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.amb_cool3 = 0) then 
 CNSsolve>  evaluate (&Data.amb_cool3 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.hbond_cool2 = 0) then 
 CNSsolve>  evaluate (&Data.hbond_cool2 = 0.000001) 
 CNSsolve>end if 
 CNSsolve>if (&Data.hbond_cool3 = 0) then 
 CNSsolve>  evaluate (&Data.hbond_cool3 = 0.000001) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($k_unamb= &Data.unamb_cool2) 
 CNSsolve>evaluate ($unamb_fac = (&Data.unamb_cool3/&Data.unamb_cool2)^(1/$ncycle)) 
 CNSsolve>evaluate ($k_amb= &Data.amb_cool2) 
 CNSsolve>evaluate ($amb_fac = (&Data.amb_cool3/&Data.amb_cool2)^(1/$ncycle)) 
 CNSsolve>evaluate ($k_hbond= &Data.hbond_cool2) 
 CNSsolve>evaluate ($hbond_fac = (&Data.hbond_cool3/&Data.hbond_cool2)^(1/$ncycle)) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>!for the vean statement: 
 CNSsolve>evaluate( $k_cen_1 = &Data.ini_cen_cool3_1) 
 CNSsolve>evaluate( $cen_fac_1 = ( &Data.fin_cen_cool3_1 / &Data.ini_cen_cool3_1)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_1 = &Data.ini_bor_cool3_1) 
 CNSsolve>evaluate( $bor_fac_1 = ( &Data.fin_bor_cool3_1 / &Data.ini_bor_cool3_1)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_2 = &Data.ini_cen_cool3_2) 
 CNSsolve>evaluate( $cen_fac_2 = ( &Data.fin_cen_cool3_2 / &Data.ini_cen_cool3_2)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_2 = &Data.ini_bor_cool3_2) 
 CNSsolve>evaluate( $bor_fac_2 = ( &Data.fin_bor_cool3_2 / &Data.ini_bor_cool3_2)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_3 = &Data.ini_cen_cool3_3) 
 CNSsolve>evaluate( $cen_fac_3 = ( &Data.fin_cen_cool3_3 / &Data.ini_cen_cool3_3)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_3 = &Data.ini_bor_cool3_3) 
 CNSsolve>evaluate( $bor_fac_3 = ( &Data.fin_bor_cool3_3 / &Data.ini_bor_cool3_3)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_4 = &Data.ini_cen_cool3_4) 
 CNSsolve>evaluate( $cen_fac_4 = ( &Data.fin_cen_cool3_4 / &Data.ini_cen_cool3_4)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_4 = &Data.ini_bor_cool3_4) 
 CNSsolve>evaluate( $bor_fac_4 = ( &Data.fin_bor_cool3_4 / &Data.ini_bor_cool3_4)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate( $k_cen_5 = &Data.ini_cen_cool3_5) 
 CNSsolve>evaluate( $cen_fac_5 = ( &Data.fin_cen_cool3_5 / &Data.ini_cen_cool3_5)^( 1 / $ncycle)) 
 CNSsolve>evaluate( $k_bor_5 = &Data.ini_bor_cool3_5) 
 CNSsolve>evaluate( $bor_fac_5 = ( &Data.fin_bor_cool3_5 / &Data.ini_bor_cool3_5)^( 1 / $ncycle)) 
 CNSsolve> 
 CNSsolve>evaluate ($bath  = &SaProtocol.t3_init) 
 CNSsolve>do (vx=maxwell($bath)) ( all ) 
 CNSsolve>do (vy=maxwell($bath)) ( all ) 
 CNSsolve>do (vz=maxwell($bath)) ( all ) 
 CNSsolve> 
 CNSsolve>evaluate ($reassign = TRUE) 
 CNSsolve>evaluate ($i_cool = 0) 
 CNSsolve>while ($i_cool < $ncycle) loop cool 
 CNSsolve> 
 CNSsolve>      evaluate ($i_cool=$i_cool+1) 
 CNSsolve> 
 CNSsolve>      evaluate ($bath  = $bath  - $tempstep) 
 CNSsolve>      evaluate ($k_unamb = $k_unamb*$unamb_fac) 
 CNSsolve>      evaluate ($k_amb = $k_amb*$amb_fac) 
 CNSsolve>      evaluate ($k_hbond = $k_hbond*$hbond_fac) 
 CNSsolve>      evaluate ($asy=$asy+$asy_add) 
 CNSsolve>      evaluate ($masy=$masy+$masy_add) 
 CNSsolve> 
 CNSsolve>      evaluate ($k_bor_1 = $k_bor_1 * $bor_fac_1) 
 CNSsolve>      evaluate ($k_bor_2 = $k_bor_2 * $bor_fac_2) 
 CNSsolve>      evaluate ($k_bor_3 = $k_bor_3 * $bor_fac_3) 
 CNSsolve>      evaluate ($k_bor_4 = $k_bor_4 * $bor_fac_4) 
 CNSsolve>      evaluate ($k_bor_5 = $k_bor_5 * $bor_fac_5) 
 CNSsolve> 
 CNSsolve>      evaluate ($k_cen_1 = $k_cen_1 * $cen_fac_1) 
 CNSsolve>      evaluate ($k_cen_2 = $k_cen_2 * $cen_fac_2) 
 CNSsolve>      evaluate ($k_cen_3 = $k_cen_3 * $cen_fac_3) 
 CNSsolve>      evaluate ($k_cen_4 = $k_cen_4 * $cen_fac_4) 
 CNSsolve>      evaluate ($k_cen_5 = $k_cen_5 * $cen_fac_5) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.vean eq true) then 
 CNSsolve>        vean class vea1 force $k_bor_1 $k_cen_1 end 
 CNSsolve>        vean class vea2 force $k_bor_2 $k_cen_2 end 
 CNSsolve>        vean class vea3 force $k_bor_3 $k_cen_3 end 
 CNSsolve>        vean class vea4 force $k_bor_4 $k_cen_4 end 
 CNSsolve>        vean class vea5 force $k_bor_5 $k_cen_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_sani_1 = $k_sani_1 * $sani_fac_1) 
 CNSsolve>      evaluate ($k_sani_2 = $k_sani_2 * $sani_fac_2) 
 CNSsolve>      evaluate ($k_sani_3 = $k_sani_3 * $sani_fac_3) 
 CNSsolve>      evaluate ($k_sani_4 = $k_sani_4 * $sani_fac_4) 
 CNSsolve>      evaluate ($k_sani_5 = $k_sani_5 * $sani_fac_5) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.sani eq true) then 
 CNSsolve>        sani class rdc1 force $k_sani_1 end 
 CNSsolve>        sani class rdc2 force $k_sani_2 end 
 CNSsolve>        sani class rdc3 force $k_sani_3 end 
 CNSsolve>        sani class rdc4 force $k_sani_4 end 
 CNSsolve>        sani class rdc5 force $k_sani_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_xpcs_1 = $k_xpcs_1 * $xpcs_fac_1) 
 CNSsolve>      evaluate ($k_xpcs_2 = $k_xpcs_2 * $xpcs_fac_2) 
 CNSsolve>      evaluate ($k_xpcs_3 = $k_xpcs_3 * $xpcs_fac_3) 
 CNSsolve>      evaluate ($k_xpcs_4 = $k_xpcs_4 * $xpcs_fac_4) 
 CNSsolve>      evaluate ($k_xpcs_5 = $k_xpcs_5 * $xpcs_fac_5) 
 CNSsolve>      evaluate ($k_xpcs_6 = $k_xpcs_6 * $xpcs_fac_6) 
 CNSsolve>      evaluate ($k_xpcs_7 = $k_xpcs_7 * $xpcs_fac_7) 
 CNSsolve>      evaluate ($k_xpcs_8 = $k_xpcs_8 * $xpcs_fac_8) 
 CNSsolve>      evaluate ($k_xpcs_9 = $k_xpcs_9 * $xpcs_fac_9) 
 CNSsolve>      evaluate ($k_xpcs_A = $k_xpcs_A * $xpcs_fac_A) 
 CNSsolve> 
 CNSsolve>      if ($Data.flags.xpcs eq true) then 
 CNSsolve>        xpcs class pcs1 force $k_xpcs_1 end 
 CNSsolve>        xpcs class pcs2 force $k_xpcs_2 end 
 CNSsolve>        xpcs class pcs3 force $k_xpcs_3 end 
 CNSsolve>        xpcs class pcs4 force $k_xpcs_4 end 
 CNSsolve>        xpcs class pcs5 force $k_xpcs_5 end 
 CNSsolve>        xpcs class pcs6 force $k_xpcs_6 end 
 CNSsolve>        xpcs class pcs7 force $k_xpcs_7 end 
 CNSsolve>        xpcs class pcs8 force $k_xpcs_8 end 
 CNSsolve>        xpcs class pcs9 force $k_xpcs_9 end 
 CNSsolve>        xpcs class pcsA force $k_xpcs_A end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      evaluate ($k_dani_1 = $k_dani_1 * $dani_fac_1) 
 CNSsolve>      evaluate ($k_dani_2 = $k_dani_2 * $dani_fac_2) 
 CNSsolve>      evaluate ($k_dani_3 = $k_dani_3 * $dani_fac_3) 
 CNSsolve>      evaluate ($k_dani_4 = $k_dani_4 * $dani_fac_4) 
 CNSsolve>      evaluate ($k_dani_5 = $k_dani_5 * $dani_fac_5) 
 CNSsolve>      if ($Data.flags.dani eq true) then 
 CNSsolve>        dani class dan1 force $k_dani_1 end 
 CNSsolve>        dani class dan2 force $k_dani_2 end 
 CNSsolve>        dani class dan3 force $k_dani_3 end 
 CNSsolve>        dani class dan4 force $k_dani_4 end 
 CNSsolve>        dani class dan5 force $k_dani_5 end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      if ($Data.scaling eq TRUE) then 
 CNSsolve>        inline  
 CNSsolve>! set_noe_scale.cns 
 CNSsolve>!    Set the distance restraint force constant 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($enoe   = 0.0 ) 
 CNSsolve>evaluate ($vdw    = 0.0 ) 
 CNSsolve>evaluate ($elec   = 0.0 ) 
 CNSsolve>evaluate ($einter = 0.0 ) 
 CNSsolve>evaluate ($noescale = 1.0 ) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym ne true) then 
 CNSsolve>  print threshold=0.5 noe 
 CNSsolve>  evaluate ($numnoe=$violations) 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_amb > 0) then 
 CNSsolve>    evaluate ($ambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_amb)))) 
 CNSsolve>    if ($ambcorr = 0) then 
 CNSsolve>      evaluate ($ambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($ambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_unamb > 0) then 
 CNSsolve>    evaluate ($unambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_unamb)))) 
 CNSsolve>    if ($unambcorr = 0) then 
 CNSsolve>      evaluate ($unambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($unambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve>else 
 CNSsolve>  evaluate ($unambcorr = 1) 
 CNSsolve>  evaluate ($ambcorr = 1) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>eval ($nchain1 = 0) 
 CNSsolve>igroup 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction  (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                   (segid $Toppar.prot_segid_$nchain2) weights * 1 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>  end loop nloop1 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>energy end 
 CNSsolve>igroup 
 CNSsolve>    interaction  (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($einter = abs($vdw + $elec)) 
 CNSsolve>evaluate ($enoe   = $noe) 
 CNSsolve> 
 CNSsolve>if ($enoe ne 0) then 
 CNSsolve>  evaluate ($noescale = min(5000, (2 * $einter / $enoe))) 
 CNSsolve>  if ($noescale ne 0) then 
 CNSsolve>    evaluate ($Data.unamb_hot   = $Data.unamb_hot   * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_hot     = $Data.amb_hot     * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool1 = $Data.unamb_cool1 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool1   = $Data.amb_cool1   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool2 = $Data.unamb_cool2 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool2   = $Data.amb_cool2   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool3 = $Data.unamb_cool3 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool3   = $Data.amb_cool3   * $noescale * $ambcorr) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>        noe 
 CNSsolve>           scale dist $Data.unamb_cool3 
 CNSsolve>           scale ambi $Data.amb_cool3 
 CNSsolve>           scale hbon $Data.hbond_cool3 
 CNSsolve>           asym ambi $asy 
 CNSsolve>           asym dist $asy 
 CNSsolve>           asym hbon $asy 
 CNSsolve>           masym ambi $masy 
 CNSsolve>           masym dist $masy 
 CNSsolve>           masym hbon $masy 
 CNSsolve>        end 
 CNSsolve>      else 
 CNSsolve>        noe 
 CNSsolve>           scale dist $k_unamb 
 CNSsolve>           scale ambi $k_amb 
 CNSsolve>           scale hbon $k_hbond 
 CNSsolve>           asym ambi $asy 
 CNSsolve>           asym dist $asy 
 CNSsolve>           asym hbon $asy 
 CNSsolve>           masym ambi $masy 
 CNSsolve>           masym dist $masy 
 CNSsolve>           masym hbon $masy 
 CNSsolve>        end 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>      !scale intermolecular interactions: 
 CNSsolve>      inline  
 CNSsolve>! scale_inter.cns 
 CNSsolve>!    Scaling of intermolecular interactions 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) weight * $Toppar.int_$nchain1_$nchain1 end 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 vdw $kinter elec $kinter end 
 CNSsolve> 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> 
 CNSsolve>  interaction ((resn WAT or resn HOH or resn TIP*)) ((resn WAT or resn HOH or resn TIP*)) weight * 1.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      evaluate ($kinter = $kinter + $interstep) 
 CNSsolve> 
 CNSsolve>      dyna tors 
 CNSsolve>         reassign $reassign 
 CNSsolve>         timestep=$timestep 
 CNSsolve>         nstep=$calcsteps 
 CNSsolve>         nprint=$printsteps 
 CNSsolve>         ntrfrq=0 
 CNSsolve>         tcoupling = true  temperature = $bath 
 CNSsolve>      end 
 CNSsolve>      evaluate ($reassign = FALSE) 
 CNSsolve> 
 CNSsolve>      energy end 
 CNSsolve>      if ($ener > 99999999) then 
 CNSsolve>        display ENERGY PROBLEM, THE SYSTEM IS BLOWING UP: ==> STOPPING 
 CNSsolve>        stop 
 CNSsolve>      end if 
 CNSsolve> 
 CNSsolve>end loop cool 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>{* 5 =========================== final minimization *} 
 CNSsolve> 
 CNSsolve>  if ($Data.scaling eq true) then 
 CNSsolve>    inline  
 CNSsolve>! set_noe_scale.cns 
 CNSsolve>!    Set the distance restraint force constant 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($enoe   = 0.0 ) 
 CNSsolve>evaluate ($vdw    = 0.0 ) 
 CNSsolve>evaluate ($elec   = 0.0 ) 
 CNSsolve>evaluate ($einter = 0.0 ) 
 CNSsolve>evaluate ($noescale = 1.0 ) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym ne true) then 
 CNSsolve>  print threshold=0.5 noe 
 CNSsolve>  evaluate ($numnoe=$violations) 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_amb > 0) then 
 CNSsolve>    evaluate ($ambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_amb)))) 
 CNSsolve>    if ($ambcorr = 0) then 
 CNSsolve>      evaluate ($ambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($ambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.totnoe_unamb > 0) then 
 CNSsolve>    evaluate ($unambcorr = min(1.0,max(0.0,($numnoe / $Data.totnoe_unamb)))) 
 CNSsolve>    if ($unambcorr = 0) then 
 CNSsolve>      evaluate ($unambcorr = 1) 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    evaluate ($unambcorr = 1) 
 CNSsolve>  end if 
 CNSsolve>else 
 CNSsolve>  evaluate ($unambcorr = 1) 
 CNSsolve>  evaluate ($ambcorr = 1) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>eval ($nchain1 = 0) 
 CNSsolve>igroup 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      interaction  (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>                   (segid $Toppar.prot_segid_$nchain2) weights * 1 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>  end loop nloop1 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>energy end 
 CNSsolve>igroup 
 CNSsolve>    interaction  (not (resn ANI or resn DAN or resn XAN)) (not (resn ANI or resn DAN or resn XAN)) weight * 1 end 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve>evaluate ($einter = abs($vdw + $elec)) 
 CNSsolve>evaluate ($enoe   = $noe) 
 CNSsolve> 
 CNSsolve>if ($enoe ne 0) then 
 CNSsolve>  evaluate ($noescale = min(5000, (2 * $einter / $enoe))) 
 CNSsolve>  if ($noescale ne 0) then 
 CNSsolve>    evaluate ($Data.unamb_hot   = $Data.unamb_hot   * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_hot     = $Data.amb_hot     * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool1 = $Data.unamb_cool1 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool1   = $Data.amb_cool1   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool2 = $Data.unamb_cool2 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool2   = $Data.amb_cool2   * $noescale * $ambcorr) 
 CNSsolve>    evaluate ($Data.unamb_cool3 = $Data.unamb_cool3 * $noescale * $unambcorr) 
 CNSsolve>    evaluate ($Data.amb_cool3   = $Data.amb_cool3   * $noescale * $ambcorr) 
 CNSsolve>  end if 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    energy end 
 CNSsolve>    noe 
 CNSsolve>      scale dist $Data.unamb_cool3 
 CNSsolve>      scale ambi $Data.amb_cool3 
 CNSsolve>      scale hbon $Data.hbond_cool3 
 CNSsolve>    end 
 CNSsolve>    energy end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>   
 CNSsolve>! flex_segment_back.cns 
 CNSsolve>!    Define the semi-flexible segments (both side-chains and backbone) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>do (store5 = 0) (all) 
 CNSsolve>do (store6 = 0) (all) 
 CNSsolve>do (store7 = 0) (all) 
 CNSsolve> 
 CNSsolve>!first flexible segments for docking 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  evaluate($fcounter=0) 
 CNSsolve> 
 CNSsolve>  if ($Toppar.nseg_$nchain1 = 0) then 
 CNSsolve>    display NO FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    if ($Toppar.nseg_$nchain1 < 0) then 
 CNSsolve>      display AUTOMATIC DEFINITION OF FLEXIBLE SEGMENTS BASED ON INTERMOLECULAR PROXIMITY FOR MOLECULE $nchain1 
 CNSsolve>      inline  
 CNSsolve>! flexauto-neighbors.cns 
 CNSsolve>!    Automatic definition of flexible segments for docking for contacting residues 
 CNSsolve>!    including neighboring residues of residues making contacts 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>evaluate ($flcut = 5.0) 
 CNSsolve> 
 CNSsolve>do (store5 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve>do (store7 = $nchain1) (byres (segid $Toppar.prot_segid_$nchain1 
 CNSsolve>                               and (not segid $Toppar.prot_segid_$nchain1) around $flcut)) 
 CNSsolve> 
 CNSsolve>do (store6 = 0) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres1 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = decode($result)) 
 CNSsolve>    evaluate ($preres = $inres) 
 CNSsolve>    evaluate ($nexres = $inres) 
 CNSsolve>    if ($iteration = 1) then 
 CNSsolve>      evaluate ($preres = $preres - 1) 
 CNSsolve>!      evaluate ($nexres = $nexres + 1) 
 CNSsolve>    end if 
 CNSsolve>    do (store6 = $nchain1) (resid $preres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>    do (store6 = $nchain1) (resid $nexres and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>end loop flexres1 
 CNSsolve> 
 CNSsolve>do (store5 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>do (store7 = store6) (segid $Toppar.prot_segid_$nchain1) 
 CNSsolve> 
 CNSsolve>display THE FOLLOWING RESIDUES HAVE BEEN DEFINED AS FLEXIBLE for molecule $nchain1 
 CNSsolve>for $id in id (tag and attr store5 >0 and not ((resn WAT or resn HOH or resn TIP*) or resn DMSO) and segid $Toppar.prot_segid_$nchain1) loop flexres2 
 CNSsolve>    show (resid) (id $id) 
 CNSsolve>    evaluate ($inres = $result) 
 CNSsolve>    show (resn) (id $id) 
 CNSsolve>    evaluate ($nares = $result) 
 CNSsolve>    show (segid) (id $id) 
 CNSsolve>    evaluate ($seres = $result) 
 CNSsolve>    display AUTOMATICALLY SELECTED SEGMENT: $nares,$inres,$seres 
 CNSsolve>end loop flexres2 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    else 
 CNSsolve>      display FLEXIBLE SIDE-CHAINS SEGMENTS for molecule $nchain1 
 CNSsolve>      while ($fcounter < $Toppar.nseg_$nchain1) loop Xflex 
 CNSsolve>        evaluate($fcounter=$fcounter + 1) 
 CNSsolve>        do (store5 = $nchain1) ( resid $Toppar.start_seg_$nchain1_$fcounter : $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>                                 and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>        display FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_seg_$nchain1_$fcounter TO $Toppar.end_seg_$nchain1_$fcounter 
 CNSsolve>      end loop Xflex 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>!then fully flexible segments for all stages 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  if ($Toppar.nfle_$nchain1 = 0) then 
 CNSsolve>    display NO FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>  else 
 CNSsolve>    display FULLY FLEXIBLE SEGMENTS for molecule $nchain1 
 CNSsolve>    evaluate($fcounter=0) 
 CNSsolve>    while ($fcounter < $Toppar.nfle_$nchain1) loop Xfflex 
 CNSsolve>      evaluate($fcounter=$fcounter + 1) 
 CNSsolve>      do (store5 = $nchain1) ( resid $Toppar.start_fle_$nchain1_$fcounter : $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>                               and segid $Toppar.prot_segid_$nchain1 ) 
 CNSsolve>      display FULLY FLEXIBLE SEGMENT NR $fcounter FROM $Toppar.start_fle_$nchain1_$fcounter TO $Toppar.end_fle_$nchain1_$fcounter 
 CNSsolve>    end loop Xfflex 
 CNSsolve>  end if 
 CNSsolve>end loop nloop2 
 CNSsolve> 
 CNSsolve>do (store5 = 7) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = 0) 
 CNSsolve> 
 CNSsolve>! check number of flexible residues per molecule 
 CNSsolve>evaluate($nchain1 = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop3 
 CNSsolve>  evaluate($nchain1 = $nchain1 + 1) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and (attr store5 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numfle=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1 and not (attr store5 = $nchain1)) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numrig=$result) 
 CNSsolve>  do (store6 = 0) (all) 
 CNSsolve>  do (store6 = 1) (tag and segid $Toppar.prot_segid_$nchain1) 
 CNSsolve>  show sum (store6) (all) 
 CNSsolve>  evaluate ($numres=$result) 
 CNSsolve>  display FLEXIBILITY STATISTIC FOR MOLECULE $nchain1 : Nres=$numres Nrigid=$numrig Nflex=$numfle 
 CNSsolve>  evaluate ($nfletot = $nfletot + $numfle) 
 CNSsolve>end loop nloop3 
 CNSsolve> 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH or resn TIP*) and name OH2) 
 CNSsolve>show sum (store1) ((resn WAT or resn HOH or resn TIP*)) 
 CNSsolve>evaluate ($nfletot = $nfletot + $result) 
 CNSsolve> 
 CNSsolve>evaluate ($nfletot = $nfletot + 10) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  fix sele=((attr store5 = 0 or name OO) and not name H* and not (resn WAT or resn HOH or resn TIP* or resn XAN)) end 
 CNSsolve>  minimize powell nstep=200 drop=10.0 nprint=25 end 
 CNSsolve>  fix sele=(not all) end 
 CNSsolve>  energy end 
 CNSsolve> 
 CNSsolve>  if ($nlcount = 1) then 
 CNSsolve>    coor swap end 
 CNSsolve>    if ($torsiondone eq true) then 
 CNSsolve>      if ($failure eq false) then 
 CNSsolve>        dyna tors topo reset end end 
 CNSsolve>      end if 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>end loop rotloop1 
 CNSsolve> 
 CNSsolve>coor swap end 
 COOR: selected coordinates swaped (main<->comp)
 CNSsolve> 
 CNSsolve>if ($iterations.rotate180 eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($rotiter = 2)  {* two iteration in rotloop2, rotation *} 
 CNSsolve>else 
 CNSsolve>  evaluate ($rotiter = 1)  {* only one iteration in rotloop2, no rotation *} 
 EVALUATE: symbol $ROTITER set to    1.00000     (real)
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($nlcount = 0) 
 EVALUATE: symbol $NLCOUNT set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>{* ================== Loop to write 180 degrees rotated solutions if requested *} 
 CNSsolve> 
 CNSsolve>while ($nlcount < $rotiter) loop rotloop2 
 NEXTCD: condition evaluated as true
 CNSsolve> 
 CNSsolve>  evaluate ($nlcount = $nlcount + 1) 
 EVALUATE: symbol $NLCOUNT set to    1.00000     (real)
 CNSsolve> 
 CNSsolve>{* ===================== calculate complex internal energy *} 
 CNSsolve>  evaluate ($kinter = 1.0) 
 EVALUATE: symbol $KINTER set to    1.00000     (real)
 CNSsolve>  @RUN:protocols/scale_intra_only.cns 
 ASSFIL: file scale_intra_only.cns opened.
 CNSsolve>! scale_intra_only.cns 
 CNSsolve>!    Scaling of intramolecular energies (no intermolecular energies) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 SELRPN:      0 atoms have been selected out of   3007
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>igroup 
 IGROup> 
 IGROup>  eval($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 IGROup> 
 IGROup>  while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 IGROup>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 IGROup> 
 IGROup>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 SELRPN:   2970 atoms have been selected out of   3007
 SELRPN>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 end 
 SELRPN:   2970 atoms have been selected out of   3007
 IGROup> 
 IGROup> end loop nloop1 
 IGROup>  while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 IGROup>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 IGROup> 
 IGROup>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 SELRPN:     37 atoms have been selected out of   3007
 SELRPN>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 end 
 SELRPN:     37 atoms have been selected out of   3007
 IGROup> 
 IGROup> end loop nloop1 
 IGROup>  while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 IGROup>    eval($nchain1 = $nchain1 + 1) 
 IGROup> 
 IGROup>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 IGROup>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 end 
 IGROup> 
 IGROup> end loop nloop1 
 IGROup> 
 IGROup> interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3007
 SELRPN:      0 atoms have been selected out of   3007
 IGROup> interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3007
 SELRPN:      0 atoms have been selected out of   3007
 IGROup> interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3007
 SELRPN:      0 atoms have been selected out of   3007
 IGROup> 
 IGROup>end 
 CNSsolve>  energy end 
 NBONDS: generating intra-molecular exclusion list with mode= 5
 MAKINB: mode   5 found   7433 exclusions and   5249 interactions(1-4)
 NBONDS: found   205030 intra-atom interactions
 NBONDS: generating intra-molecular exclusion list with mode= 5
 MAKINB: mode   5 found    102 exclusions and     65 interactions(1-4)
 NBONDS: found      303 intra-atom interactions
 --------------- cycle=     6 --------------------------------------------------
 | Etotal =27607.995  grad(E)=129.764    E(BOND)=294.126    E(ANGL)=1319.134   |
 | E(DIHE)=1749.218   E(IMPR)=25112.228  E(VDW )=187.916    E(ELEC)=-1095.877  |
 | E(HARM)=0.000      E(NOE )=41.249                                           |
 -------------------------------------------------------------------------------
 CNSsolve>  evaluate ($eintcplx = $bond + $angl + $impr + $dihe + $vdw + $elec) 
 EVALUATE: symbol $EINTCPLX set to    27566.7     (real)
 CNSsolve>  if ($data.ncomponents = 1) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    evaluate ($eintfree = $eintcplx) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>{* ===================== calculate final energies and write structure *} 
 CNSsolve>  evaluate ($cdih=0.0) 
 EVALUATE: symbol $CDIH set to    0.00000     (real)
 CNSsolve>  flag incl noe cdih end 
 CNSsolve>  if ($Data.flags.sani eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    flag incl sani end 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.flags.xrdc eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    flag incl xrdc end 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.flags.xpcs eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    flag incl xpcs end 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.flags.dani eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    flag incl dani end 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.flags.vean eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    flag incl vean end 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.ncomponents > 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate ($kinter = 1.0) 
 EVALUATE: symbol $KINTER set to    1.00000     (real)
 CNSsolve>    @RUN:protocols/scale_inter_final.cns 
 ASSFIL: file scale_inter_final.cns opened.
 CNSsolve>! scale_inter_final.cns 
 CNSsolve>!   Scaling of intermolecular interactions 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 SELRPN:      0 atoms have been selected out of   3007
 SELRPN:      0 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>igroup 
 IGROup> 
 IGROup>  eval($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 IGROup> 
 IGROup>  while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 IGROup>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 IGROup>    eval($nchain2 = $nchain1 ) 
 EVALUATE: symbol $NCHAIN2 set to    1.00000     (real)
 IGROup>    while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as true
 IGROup>      eval($nchain2 = $nchain2 + 1) 
 EVALUATE: symbol $NCHAIN2 set to    2.00000     (real)
 IGROup>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 EVALUATE: symbol $SCALFAC set to    1.00000     (real)
 IGROup>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 SELRPN:   2970 atoms have been selected out of   3007
 SELRPN>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 SELRPN:     37 atoms have been selected out of   3007
 IGROup>    end loop nloop2 
 IGROup>    while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as false
 IGROup>      eval($nchain2 = $nchain2 + 1) 
 IGROup>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 IGROup>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 IGROup>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 IGROup>    end loop nloop2 
 IGROup> 
 IGROup>  end loop nloop1 
 IGROup>  while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 IGROup>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 IGROup>    eval($nchain2 = $nchain1 ) 
 EVALUATE: symbol $NCHAIN2 set to    2.00000     (real)
 IGROup>    while ($nchain2 < $data.ncomponents) loop nloop2 
 NEXTCD: condition evaluated as false
 IGROup>      eval($nchain2 = $nchain2 + 1) 
 IGROup>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 IGROup>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 IGROup>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 IGROup>    end loop nloop2 
 IGROup> 
 IGROup>  end loop nloop1 
 IGROup>  while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 IGROup>    eval($nchain1 = $nchain1 + 1) 
 IGROup>    eval($nchain2 = $nchain1 ) 
 IGROup>    while ($nchain2 < $data.ncomponents) loop nloop2 
 IGROup>      eval($nchain2 = $nchain2 + 1) 
 IGROup>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 IGROup>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 IGROup>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 IGROup>    end loop nloop2 
 IGROup> 
 IGROup>  end loop nloop1 
 IGROup> 
 IGROup>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3007
 SELRPN:      0 atoms have been selected out of   3007
 IGROup>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3007
 SELRPN:      0 atoms have been selected out of   3007
 IGROup>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 SELRPN:      0 atoms have been selected out of   3007
 SELRPN:      0 atoms have been selected out of   3007
 IGROup> 
 IGROup>end 
 CNSsolve>  else 
 CNSsolve>    @RUN:protocols/scale_intra_only.cns 
 ASSFIL: file scale_intra_only.cns opened.
 CNSsolve>! scale_intra_only.cns 
 CNSsolve>!    Scaling of intramolecular energies (no intermolecular energies) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 end 
 CNSsolve> 
 CNSsolve> end loop nloop1 
 CNSsolve> 
 CNSsolve> interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  noe 
 NOE>    scale dist $Data.unamb_cool3 
 NOE>    scale ambi $Data.amb_cool3 
 NOE>    scale hbon 0.0 
 NOE>    scale symm 0.0 
 NOE>    scale cont 0.0 
 NOE>  end 
 CNSsolve>  energy end 
 NBONDS: generating intra-molecular exclusion list with mode= 5
 MAKINB: mode   5 found      0 exclusions and      0 interactions(1-4)
 NBONDS: found     5118 intra-atom interactions
 --------------- cycle=     7 --------------------------------------------------
 | Etotal =-43.254    grad(E)=0.178      E(BOND)=0.000      E(ANGL)=0.000      |
 | E(DIHE)=0.000      E(IMPR)=0.000      E(VDW )=-34.839    E(ELEC)=-8.501     |
 | E(HARM)=0.000      E(CDIH)=0.000      E(NOE )=0.086                         |
 -------------------------------------------------------------------------------
 CNSsolve>  evaluate ($eair= $noe) 
 EVALUATE: symbol $EAIR set to   0.860909E-01 (real)
 CNSsolve> 
 CNSsolve>  evaluate ($esym = 0.0) 
 EVALUATE: symbol $ESYM set to    0.00000     (real)
 CNSsolve>  evaluate ($ncs = 0.0) 
 EVALUATE: symbol $NCS set to    0.00000     (real)
 CNSsolve>  if ($Data.flags.sym  eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    noe reset nres= 200000 end 
 CNSsolve>    @RUN:protocols/symmultimer.cns 
 ASSFIL: file symmultimer.cns opened.
 CNSsolve>! symmultimer.cns 
 CNSsolve>!    Define symmetry restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>! Define NCS restraints for symmetrical multimers 
 CNSsolve>if ($Data.flags.ncs eq true) then 
 CNSsolve> 
 CNSsolve>  ncs restraints 
 CNSsolve>    initialize 
 CNSsolve>    eval ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.numncs) loop ncsloop 
 CNSsolve>      eval ($ncount = $ncount + 1) 
 CNSsolve>      group 
 CNSsolve>        equi (not name H* and resid $Toppar.ncs_sta1_$ncount : $Toppar.ncs_end1_$ncount and segid $Toppar.ncs_seg1_$ncount) 
 CNSsolve>        equi (not name H* and resid $Toppar.ncs_sta2_$ncount : $Toppar.ncs_end2_$ncount and segid $Toppar.ncs_seg2_$ncount) 
 CNSsolve>	weight = $Data.kncs 
 CNSsolve>      end 
 CNSsolve>    end loop ncsloop 
 CNSsolve>    ? 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym eq true) then 
 CNSsolve> 
 CNSsolve>  noe class symm end 
 CNSsolve> 
 CNSsolve>! Define C2 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc2sym) loop c2symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c2sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c2sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c2sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c2sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c2sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c2sym_seg2_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc2sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resid1 = $i1start) 
 CNSsolve>      evaluate ($resid2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resid3 = $i2start) 
 CNSsolve>      evaluate ($resid4 = $i1end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve>	assign (resid $resid1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>	       (resid $resid2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>	assign (resid $resid3 and (name CA or name P)  and segid $chain2) 
 CNSsolve>	       (resid $resid4 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + 1) 
 CNSsolve>      evaluate ($i1start = $i1start + 1) 
 CNSsolve>      evaluate ($i2start = $i2start + 1) 
 CNSsolve> 
 CNSsolve>    end loop genc2sym 
 CNSsolve> 
 CNSsolve>  end loop c2symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! Define C3 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc3sym) loop c3symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c3sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c3sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c3sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c3sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c3sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c3sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.c3sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.c3sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.c3sym_seg3_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc3sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst1 = $i1start) 
 CNSsolve>      evaluate ($resst2 = $i2start) 
 CNSsolve>      evaluate ($resst3 = $i3start) 
 CNSsolve>      evaluate ($resen1 = $i1end - $icount) 
 CNSsolve>      evaluate ($resen2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resen3 = $i3end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve> 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resen1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resen1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + 2) 
 CNSsolve>      evaluate ($i1start = $i1start + 2) 
 CNSsolve>      evaluate ($i2start = $i2start + 2) 
 CNSsolve>      evaluate ($i3start = $i3start + 2) 
 CNSsolve> 
 CNSsolve>    end loop genc3sym 
 CNSsolve> 
 CNSsolve>  end loop c3symloop 
 CNSsolve> 
 CNSsolve>! Define S3 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.nums3sym) loop s3symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.s3sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.s3sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.s3sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.s3sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.s3sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.s3sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.s3sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.s3sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.s3sym_seg3_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    eval ($istep = 4) 
 CNSsolve>    eval ($istop = $i1end - $istep) 
 CNSsolve>    while ($i1start < $istop) loop gens3sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst11 = $i1start) 
 CNSsolve>      evaluate ($resst21 = $i1start+1) 
 CNSsolve>      evaluate ($resst12 = $i2start) 
 CNSsolve>      evaluate ($resst22 = $i2start+1) 
 CNSsolve>      evaluate ($resst13 = $i3start) 
 CNSsolve>      evaluate ($resst23 = $i3start+1) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve> 
 CNSsolve>!         assign (resid $resst11 and (name CA or name P)  and segid $chain1) 
 CNSsolve>!                (resid $resst12 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>!         assign (resid $resst21 and (name CA or name P)  and segid $chain1) 
 CNSsolve>!                (resid $resst22 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>! 
 CNSsolve>!         assign (resid $resst12 and (name CA or name P)  and segid $chain2) 
 CNSsolve>!                (resid $resst13 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>!         assign (resid $resst22 and (name CA or name P)  and segid $chain2) 
 CNSsolve>!                (resid $resst23 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst11 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst12 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst12 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst13 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst21 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst22 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst22 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst23 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + $istep) 
 CNSsolve>      evaluate ($i1start = $i1start + $istep) 
 CNSsolve>      evaluate ($i2start = $i2start + $istep) 
 CNSsolve>      evaluate ($i3start = $i3start + $istep) 
 CNSsolve> 
 CNSsolve>    end loop gens3sym 
 CNSsolve> 
 CNSsolve>  end loop s3symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! Define C4 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  eval ($istep = 10) 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc4sym) loop c4symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c4sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c4sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c4sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c4sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c4sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c4sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.c4sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.c4sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.c4sym_seg3_$ncount) 
 CNSsolve>    evaluate ($i4start = decode($Toppar.c4sym_sta4_$ncount)) 
 CNSsolve>    evaluate ($i4end   = decode($Toppar.c4sym_end4_$ncount)) 
 CNSsolve>    evaluate ($chain4  = $Toppar.c4sym_seg4_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the four defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    evaluate ($diff4 = $i4end - $i4start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff3 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc4sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst1 = $i1start) 
 CNSsolve>      evaluate ($resst2 = $i2start) 
 CNSsolve>      evaluate ($resst3 = $i3start) 
 CNSsolve>      evaluate ($resst4 = $i4start) 
 CNSsolve>      evaluate ($resen1 = $i1end - $icount) 
 CNSsolve>      evaluate ($resen2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resen3 = $i3end - $icount) 
 CNSsolve>      evaluate ($resen4 = $i4end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve>		 
 CNSsolve>		! N to N sequential restraints to prevent anti-parallel arrangements 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resst4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resst4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>		 
 CNSsolve>		! N to C sequential restraints to assure planarity 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resen4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resen4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resen1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resen1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>		 
 CNSsolve>	 assign (resid $resen1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resen2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resen2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resen3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resst4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resen3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resst4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resen4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resen4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resen1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve> 
 CNSsolve>		! Cross restraints 
 CNSsolve>		{ 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resen3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resen1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resen4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resen2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>		} 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + $istep) 
 CNSsolve>      evaluate ($i1start = $i1start + $istep) 
 CNSsolve>      evaluate ($i2start = $i2start + $istep) 
 CNSsolve>      evaluate ($i3start = $i3start + $istep) 
 CNSsolve>      evaluate ($i4start = $i4start + $istep) 
 CNSsolve> 
 CNSsolve>    end loop genc4sym 
 CNSsolve> 
 CNSsolve>  end loop c4symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! Define C5 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve>  eval ($istep = 4) 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc5sym) loop c5symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c5sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c5sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c5sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c5sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c5sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c5sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.c5sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.c5sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.c5sym_seg3_$ncount) 
 CNSsolve>    evaluate ($i4start = decode($Toppar.c5sym_sta4_$ncount)) 
 CNSsolve>    evaluate ($i4end   = decode($Toppar.c5sym_end4_$ncount)) 
 CNSsolve>    evaluate ($chain4  = $Toppar.c5sym_seg4_$ncount) 
 CNSsolve>    evaluate ($i5start = decode($Toppar.c5sym_sta5_$ncount)) 
 CNSsolve>    evaluate ($i5end   = decode($Toppar.c5sym_end5_$ncount)) 
 CNSsolve>    evaluate ($chain5  = $Toppar.c5sym_seg5_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    evaluate ($diff4 = $i4end - $i4start) 
 CNSsolve>    evaluate ($diff5 = $i5end - $i5start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff3 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff4 ne $diff5) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc5sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst1 = $i1start) 
 CNSsolve>      evaluate ($resst2 = $i2start) 
 CNSsolve>      evaluate ($resst3 = $i3start) 
 CNSsolve>      evaluate ($resst4 = $i4start) 
 CNSsolve>      evaluate ($resst5 = $i5start) 
 CNSsolve>      evaluate ($resen1 = $i1end - $icount) 
 CNSsolve>      evaluate ($resen2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resen3 = $i3end - $icount) 
 CNSsolve>      evaluate ($resen4 = $i4end - $icount) 
 CNSsolve>      evaluate ($resen5 = $i5end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve>{ 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resen4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resen4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resen5 and (name CA or name P)  and segid $chain5) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resen5 and (name CA or name P)  and segid $chain5) 0 0 0 
 CNSsolve>         assign (resid $resst5 and (name CA or name P)  and segid $chain5) 
 CNSsolve>                (resid $resen1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst5 and (name CA or name P)  and segid $chain5) 
 CNSsolve>                (resid $resen1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>} 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst5 and (name CA or name P)  and segid $chain5) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resst5 and (name CA or name P)  and segid $chain5) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resst1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resst2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst5 and (name CA or name P)  and segid $chain5) 
 CNSsolve>                (resid $resst2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst5 and (name CA or name P)  and segid $chain5) 
 CNSsolve>                (resid $resst3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + $istep) 
 CNSsolve>      evaluate ($i1start = $i1start + $istep) 
 CNSsolve>      evaluate ($i2start = $i2start + $istep) 
 CNSsolve>      evaluate ($i3start = $i3start + $istep) 
 CNSsolve>      evaluate ($i4start = $i4start + $istep) 
 CNSsolve>      evaluate ($i5start = $i5start + $istep) 
 CNSsolve> 
 CNSsolve>    end loop genc5sym 
 CNSsolve> 
 CNSsolve>  end loop c5symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  noe 
 CNSsolve>    potential  symm symmetry 
 CNSsolve>    scale      symm $Data.ksym 
 CNSsolve>    sqconstant symm 1.0 
 CNSsolve>    sqexponent symm 2 
 CNSsolve>    soexponent symm 1 
 CNSsolve>    rswitch    symm 0.5 
 CNSsolve>    sqoffset   symm 0.0 
 CNSsolve>    asymptote  symm 1.0 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve>    noe 
 CNSsolve>      scale symm $Data.ksym 
 CNSsolve>    end 
 CNSsolve>    energy end 
 CNSsolve>    evaluate ($esym = $noe) 
 CNSsolve>    if ($Data.noecv eq true) then 
 CNSsolve>      evaluate ($violations_test_noe=0) 
 CNSsolve>      evaluate ($rms_test_noe=0.0) 
 CNSsolve>      display Print out of cross-validated violations and rms not 
 CNSsolve>      display possible in combination with symmetry restraints 
 CNSsolve>      display CV values set therefore to 0 
 CNSsolve>    end if 
 CNSsolve>    noe reset end 
 CNSsolve>    set message=normal echo=on end 
 CNSsolve>    !read all the experimental Data: 
 CNSsolve>    @@RUN:protocols/read_noes.cns(Iteration=$Iteration; Data=$Data; count=$count) 
 CNSsolve>    if ( $log_level = verbose ) then 
 CNSsolve>      set message=normal echo=on end 
 CNSsolve>    else 
 CNSsolve>      set message=off echo=off end 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    print threshold=0.3 noe 
 $$$$$$$$$$$$$$$$$$ working set $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 +++++++++++++++++++++++++++++++ CLASS CONT +++++++++++++++++++++++++++++++++++
 for this class: SCALe=   0.000 AVERage=center POTEntial=biharmonic 
                 TEMPerature= 300.000
 
 ========== restraint     3 ==========
 set-i-atoms
          A    1    GLU  CA  
          A    2    ALA  CA  
          A    3    PRO  CA  
          A    4    ASN  CA  
          A    5    GLN  CA  
          A    6    ALA  CA  
          A    7    LEU  CA  
          A    8    LEU  CA  
          A    9    ARG  CA  
          A    10   ILE  CA  
          A    11   LEU  CA  
          A    12   LYS  CA  
          A    13   GLU  CA  
          A    14   THR  CA  
          A    15   GLU  CA  
          A    16   PHE  CA  
          A    17   LYS  CA  
          A    18   LYS  CA  
          A    19   ILE  CA  
          A    20   LYS  CA  
          A    21   VAL  CA  
          A    22   LEU  CA  
          A    23   GLY  CA  
          A    24   SER  CA  
          A    25   GLY  CA  
          A    26   ALA  CA  
          A    27   PHE  CA  
          A    28   GLY  CA  
          A    29   THR  CA  
          A    30   VAL  CA  
          A    31   TYR  CA  
          A    32   LYS  CA  
          A    33   GLY  CA  
          A    34   LEU  CA  
          A    35   TRP  CA  
          A    36   ILE  CA  
          A    37   PRO  CA  
          A    38   GLU  CA  
          A    39   GLY  CA  
          A    40   GLU  CA  
          A    41   LYS  CA  
          A    42   VAL  CA  
          A    43   LYS  CA  
          A    44   ILE  CA  
          A    45   PRO  CA  
          A    46   VAL  CA  
          A    47   ALA  CA  
          A    48   ILE  CA  
          A    49   LYS  CA  
          A    50   GLU  CA  
          A    51   LEU  CA  
          A    52   ARG  CA  
          A    53   GLU  CA  
          A    54   ALA  CA  
          A    55   THR  CA  
          A    56   SER  CA  
          A    57   PRO  CA  
          A    58   LYS  CA  
          A    59   ALA  CA  
          A    60   ASN  CA  
          A    61   LYS  CA  
          A    62   GLU  CA  
          A    63   ILE  CA  
          A    64   LEU  CA  
          A    65   ASP  CA  
          A    66   GLU  CA  
          A    67   ALA  CA  
          A    68   TYR  CA  
          A    69   VAL  CA  
          A    70   MET  CA  
          A    71   ALA  CA  
          A    72   SER  CA  
          A    73   VAL  CA  
          A    74   ASP  CA  
          A    75   ASN  CA  
          A    76   PRO  CA  
          A    77   HIS  CA  
          A    78   VAL  CA  
          A    79   CYS  CA  
          A    80   ARG  CA  
          A    81   LEU  CA  
          A    82   LEU  CA  
          A    83   GLY  CA  
          A    84   ILE  CA  
          A    85   CYS  CA  
          A    86   LEU  CA  
          A    87   THR  CA  
          A    88   SER  CA  
          A    89   THR  CA  
          A    90   VAL  CA  
          A    91   GLN  CA  
          A    92   LEU  CA  
          A    93   ILE  CA  
          A    94   THR  CA  
          A    95   GLN  CA  
          A    96   LEU  CA  
          A    97   MET  CA  
          A    98   PRO  CA  
          A    99   PHE  CA  
          A    100  GLY  CA  
          A    101  CYS  CA  
          A    102  LEU  CA  
          A    103  LEU  CA  
          A    104  ASP  CA  
          A    105  TYR  CA  
          A    106  VAL  CA  
          A    107  ARG  CA  
          A    108  GLU  CA  
          A    109  HIS  CA  
          A    110  LYS  CA  
          A    111  ASP  CA  
          A    112  ASN  CA  
          A    113  ILE  CA  
          A    114  GLY  CA  
          A    115  SER  CA  
          A    116  GLN  CA  
          A    117  TYR  CA  
          A    118  LEU  CA  
          A    119  LEU  CA  
          A    120  ASN  CA  
          A    121  TRP  CA  
          A    122  CYS  CA  
          A    123  VAL  CA  
          A    124  GLN  CA  
          A    125  ILE  CA  
          A    126  ALA  CA  
          A    127  LYS  CA  
          A    128  GLY  CA  
          A    129  MET  CA  
          A    130  ASN  CA  
          A    131  TYR  CA  
          A    132  LEU  CA  
          A    133  GLU  CA  
          A    134  ASP  CA  
          A    135  ARG  CA  
          A    136  ARG  CA  
          A    137  LEU  CA  
          A    138  VAL  CA  
          A    139  HIS  CA  
          A    140  ARG  CA  
          A    141  ASP  CA  
          A    142  LEU  CA  
          A    143  ALA  CA  
          A    144  ALA  CA  
          A    145  ARG  CA  
          A    146  ASN  CA  
          A    147  VAL  CA  
          A    148  LEU  CA  
          A    149  VAL  CA  
          A    150  LYS  CA  
          A    151  THR  CA  
          A    152  PRO  CA  
          A    153  GLN  CA  
          A    154  HIS  CA  
          A    155  VAL  CA  
          A    156  LYS  CA  
          A    157  ILE  CA  
          A    158  THR  CA  
          A    159  ASP  CA  
          A    160  PHE  CA  
          A    161  GLY  CA  
          A    162  LEU  CA  
          A    163  ALA  CA  
          A    164  LYS  CA  
          A    165  LEU  CA  
          A    166  LEU  CA  
          A    167  GLY  CA  
          A    168  ALA  CA  
          A    169  GLU  CA  
          A    170  GLU  CA  
          A    171  LYS  CA  
          A    172  GLU  CA  
          A    173  TYR  CA  
          A    174  HIS  CA  
          A    175  ALA  CA  
          A    176  GLU  CA  
          A    177  GLY  CA  
          A    178  GLY  CA  
          A    179  LYS  CA  
          A    180  VAL  CA  
          A    181  PRO  CA  
          A    182  ILE  CA  
          A    183  LYS  CA  
          A    184  TRP  CA  
          A    185  MET  CA  
          A    186  ALA  CA  
          A    187  LEU  CA  
          A    188  GLU  CA  
          A    189  SER  CA  
          A    190  ILE  CA  
          A    191  LEU  CA  
          A    192  HIS  CA  
          A    193  ARG  CA  
          A    194  ILE  CA  
          A    195  TYR  CA  
          A    196  THR  CA  
          A    197  HIS  CA  
          A    198  GLN  CA  
          A    199  SER  CA  
          A    200  ASP  CA  
          A    201  VAL  CA  
          A    202  TRP  CA  
          A    203  SER  CA  
          A    204  TYR  CA  
          A    205  GLY  CA  
          A    206  VAL  CA  
          A    207  THR  CA  
          A    208  VAL  CA  
          A    209  TRP  CA  
          A    210  GLU  CA  
          A    211  LEU  CA  
          A    212  MET  CA  
          A    213  THR  CA  
          A    214  PHE  CA  
          A    215  GLY  CA  
          A    216  SER  CA  
          A    217  LYS  CA  
          A    218  PRO  CA  
          A    219  TYR  CA  
          A    220  ASP  CA  
          A    221  GLY  CA  
          A    222  ILE  CA  
          A    223  PRO  CA  
          A    224  ALA  CA  
          A    225  SER  CA  
          A    226  GLU  CA  
          A    227  ILE  CA  
          A    228  SER  CA  
          A    229  SER  CA  
          A    230  ILE  CA  
          A    231  LEU  CA  
          A    232  GLU  CA  
          A    233  LYS  CA  
          A    234  GLY  CA  
          A    235  GLU  CA  
          A    236  ARG  CA  
          A    237  LEU  CA  
          A    238  PRO  CA  
          A    239  GLN  CA  
          A    240  PRO  CA  
          A    241  PRO  CA  
          A    242  ILE  CA  
          A    243  CYS  CA  
          A    244  THR  CA  
          A    245  ILE  CA  
          A    246  ASP  CA  
          A    247  VAL  CA  
          A    248  TYR  CA  
          A    249  MET  CA  
          A    250  ILE  CA  
          A    251  MET  CA  
          A    252  VAL  CA  
          A    253  LYS  CA  
          A    254  CYS  CA  
          A    255  TRP  CA  
          A    256  MET  CA  
          A    257  ILE  CA  
          A    258  ASP  CA  
          A    259  ALA  CA  
          A    260  ASP  CA  
          A    261  SER  CA  
          A    262  ARG  CA  
          A    263  PRO  CA  
          A    264  LYS  CA  
          A    265  PHE  CA  
          A    266  ARG  CA  
          A    267  GLU  CA  
          A    268  LEU  CA  
          A    269  ILE  CA  
          A    270  ILE  CA  
          A    271  GLU  CA  
          A    272  PHE  CA  
          A    273  SER  CA  
          A    274  LYS  CA  
          A    275  MET  CA  
          A    276  ALA  CA  
          A    277  ARG  CA  
          A    278  ASP  CA  
          A    279  PRO  CA  
          A    280  GLN  CA  
          A    281  ARG  CA  
          A    282  TYR  CA  
          A    283  LEU  CA  
          A    284  VAL  CA  
          A    285  ILE  CA  
          A    286  GLN  CA  
          A    287  GLY  CA  
          A    288  ASP  CA  
          A    307  ASP  CA  
          A    308  GLU  CA  
          A    309  GLU  CA  
          A    310  ASP  CA  
          A    311  MET  CA  
          A    312  ASP  CA  
          A    313  ASP  CA  
          A    314  VAL  CA  
          A    315  VAL  CA  
          A    316  ASP  CA  
          A    317  ALA  CA  
          A    318  ASP  CA  
          A    319  GLU  CA  
          A    320  TYR  CA  
          A    321  LEU  CA  
          A    322  ILE  CA  
          A    323  PRO  CA  
          A    324  GLN  CA  
 set-j-atoms
          B    1    AEE  CAQ 
          B    1    AEE  CAO 
          B    1    AEE  NBF 
          B    1    AEE  CAN 
          B    1    AEE  CAA 
          B    1    AEE  HAA 
          B    1    AEE  CAP 
          B    1    AEE  CAR 
          B    1    AEE  NBG 
          B    1    AEE  HAB 
          B    1    AEE  CAS 
          B    1    AEE  CAX 
          B    1    AEE  CAJ 
          B    1    AEE  CAL 
          B    1    AEE  CAI 
          B    1    AEE  CAK 
          B    1    AEE  CAY 
          B    1    AEE  CBA 
          B    1    AEE  NAW 
          B    1    AEE  HAD 
          B    1    AEE  CAM 
          B    1    AEE  C5  
          B    1    AEE  C4  
          B    1    AEE  N3  
          B    1    AEE  C2  
          B    1    AEE  N1  
          B    1    AEE  C6  
          B    1    AEE  NAV 
          B    1    AEE  HAC 
          B    1    AEE  CBE 
          B    1    AEE  CAB 
          B    1    AEE  CAZ 
          B    1    AEE  CAG 
          B    1    AEE  CAD 
          B    1    AEE  CAC 
          B    1    AEE  CAE 
          B    1    AEE  CAH 
 R<average>=  11.751 NOE= 0.00 (- 0.00/+ 1.00) Delta= -11.751  E(NOE)=   0.000

 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 +++++++++++++++++++++++++++++++ CLASS SURF +++++++++++++++++++++++++++++++++++
 for this class: SCALe=   1.000 AVERage=sum    POTEntial=biharmonic 
                 TEMPerature= 300.000
 
 ========== restraint     4 ==========
 set-i-atoms
          A    1    GLU  CA  
          A    2    ALA  CA  
          A    3    PRO  CA  
          A    4    ASN  CA  
          A    5    GLN  CA  
          A    6    ALA  CA  
          A    7    LEU  CA  
          A    8    LEU  CA  
          A    9    ARG  CA  
          A    10   ILE  CA  
          A    11   LEU  CA  
          A    12   LYS  CA  
          A    13   GLU  CA  
          A    14   THR  CA  
          A    15   GLU  CA  
          A    16   PHE  CA  
          A    17   LYS  CA  
          A    18   LYS  CA  
          A    19   ILE  CA  
          A    20   LYS  CA  
          A    21   VAL  CA  
          A    22   LEU  CA  
          A    23   GLY  CA  
          A    24   SER  CA  
          A    25   GLY  CA  
          A    26   ALA  CA  
          A    27   PHE  CA  
          A    28   GLY  CA  
          A    29   THR  CA  
          A    30   VAL  CA  
          A    31   TYR  CA  
          A    32   LYS  CA  
          A    33   GLY  CA  
          A    34   LEU  CA  
          A    35   TRP  CA  
          A    36   ILE  CA  
          A    37   PRO  CA  
          A    38   GLU  CA  
          A    39   GLY  CA  
          A    40   GLU  CA  
          A    41   LYS  CA  
          A    42   VAL  CA  
          A    43   LYS  CA  
          A    44   ILE  CA  
          A    45   PRO  CA  
          A    46   VAL  CA  
          A    47   ALA  CA  
          A    48   ILE  CA  
          A    49   LYS  CA  
          A    50   GLU  CA  
          A    51   LEU  CA  
          A    52   ARG  CA  
          A    53   GLU  CA  
          A    54   ALA  CA  
          A    55   THR  CA  
          A    56   SER  CA  
          A    57   PRO  CA  
          A    58   LYS  CA  
          A    59   ALA  CA  
          A    60   ASN  CA  
          A    61   LYS  CA  
          A    62   GLU  CA  
          A    63   ILE  CA  
          A    64   LEU  CA  
          A    65   ASP  CA  
          A    66   GLU  CA  
          A    67   ALA  CA  
          A    68   TYR  CA  
          A    69   VAL  CA  
          A    70   MET  CA  
          A    71   ALA  CA  
          A    72   SER  CA  
          A    73   VAL  CA  
          A    74   ASP  CA  
          A    75   ASN  CA  
          A    76   PRO  CA  
          A    77   HIS  CA  
          A    78   VAL  CA  
          A    79   CYS  CA  
          A    80   ARG  CA  
          A    81   LEU  CA  
          A    82   LEU  CA  
          A    83   GLY  CA  
          A    84   ILE  CA  
          A    85   CYS  CA  
          A    86   LEU  CA  
          A    87   THR  CA  
          A    88   SER  CA  
          A    89   THR  CA  
          A    90   VAL  CA  
          A    91   GLN  CA  
          A    92   LEU  CA  
          A    93   ILE  CA  
          A    94   THR  CA  
          A    95   GLN  CA  
          A    96   LEU  CA  
          A    97   MET  CA  
          A    98   PRO  CA  
          A    99   PHE  CA  
          A    100  GLY  CA  
          A    101  CYS  CA  
          A    102  LEU  CA  
          A    103  LEU  CA  
          A    104  ASP  CA  
          A    105  TYR  CA  
          A    106  VAL  CA  
          A    107  ARG  CA  
          A    108  GLU  CA  
          A    109  HIS  CA  
          A    110  LYS  CA  
          A    111  ASP  CA  
          A    112  ASN  CA  
          A    113  ILE  CA  
          A    114  GLY  CA  
          A    115  SER  CA  
          A    116  GLN  CA  
          A    117  TYR  CA  
          A    118  LEU  CA  
          A    119  LEU  CA  
          A    120  ASN  CA  
          A    121  TRP  CA  
          A    122  CYS  CA  
          A    123  VAL  CA  
          A    124  GLN  CA  
          A    125  ILE  CA  
          A    126  ALA  CA  
          A    127  LYS  CA  
          A    128  GLY  CA  
          A    129  MET  CA  
          A    130  ASN  CA  
          A    131  TYR  CA  
          A    132  LEU  CA  
          A    133  GLU  CA  
          A    134  ASP  CA  
          A    135  ARG  CA  
          A    136  ARG  CA  
          A    137  LEU  CA  
          A    138  VAL  CA  
          A    139  HIS  CA  
          A    140  ARG  CA  
          A    141  ASP  CA  
          A    142  LEU  CA  
          A    143  ALA  CA  
          A    144  ALA  CA  
          A    145  ARG  CA  
          A    146  ASN  CA  
          A    147  VAL  CA  
          A    148  LEU  CA  
          A    149  VAL  CA  
          A    150  LYS  CA  
          A    151  THR  CA  
          A    152  PRO  CA  
          A    153  GLN  CA  
          A    154  HIS  CA  
          A    155  VAL  CA  
          A    156  LYS  CA  
          A    157  ILE  CA  
          A    158  THR  CA  
          A    159  ASP  CA  
          A    160  PHE  CA  
          A    161  GLY  CA  
          A    162  LEU  CA  
          A    163  ALA  CA  
          A    164  LYS  CA  
          A    165  LEU  CA  
          A    166  LEU  CA  
          A    167  GLY  CA  
          A    168  ALA  CA  
          A    169  GLU  CA  
          A    170  GLU  CA  
          A    171  LYS  CA  
          A    172  GLU  CA  
          A    173  TYR  CA  
          A    174  HIS  CA  
          A    175  ALA  CA  
          A    176  GLU  CA  
          A    177  GLY  CA  
          A    178  GLY  CA  
          A    179  LYS  CA  
          A    180  VAL  CA  
          A    181  PRO  CA  
          A    182  ILE  CA  
          A    183  LYS  CA  
          A    184  TRP  CA  
          A    185  MET  CA  
          A    186  ALA  CA  
          A    187  LEU  CA  
          A    188  GLU  CA  
          A    189  SER  CA  
          A    190  ILE  CA  
          A    191  LEU  CA  
          A    192  HIS  CA  
          A    193  ARG  CA  
          A    194  ILE  CA  
          A    195  TYR  CA  
          A    196  THR  CA  
          A    197  HIS  CA  
          A    198  GLN  CA  
          A    199  SER  CA  
          A    200  ASP  CA  
          A    201  VAL  CA  
          A    202  TRP  CA  
          A    203  SER  CA  
          A    204  TYR  CA  
          A    205  GLY  CA  
          A    206  VAL  CA  
          A    207  THR  CA  
          A    208  VAL  CA  
          A    209  TRP  CA  
          A    210  GLU  CA  
          A    211  LEU  CA  
          A    212  MET  CA  
          A    213  THR  CA  
          A    214  PHE  CA  
          A    215  GLY  CA  
          A    216  SER  CA  
          A    217  LYS  CA  
          A    218  PRO  CA  
          A    219  TYR  CA  
          A    220  ASP  CA  
          A    221  GLY  CA  
          A    222  ILE  CA  
          A    223  PRO  CA  
          A    224  ALA  CA  
          A    225  SER  CA  
          A    226  GLU  CA  
          A    227  ILE  CA  
          A    228  SER  CA  
          A    229  SER  CA  
          A    230  ILE  CA  
          A    231  LEU  CA  
          A    232  GLU  CA  
          A    233  LYS  CA  
          A    234  GLY  CA  
          A    235  GLU  CA  
          A    236  ARG  CA  
          A    237  LEU  CA  
          A    238  PRO  CA  
          A    239  GLN  CA  
          A    240  PRO  CA  
          A    241  PRO  CA  
          A    242  ILE  CA  
          A    243  CYS  CA  
          A    244  THR  CA  
          A    245  ILE  CA  
          A    246  ASP  CA  
          A    247  VAL  CA  
          A    248  TYR  CA  
          A    249  MET  CA  
          A    250  ILE  CA  
          A    251  MET  CA  
          A    252  VAL  CA  
          A    253  LYS  CA  
          A    254  CYS  CA  
          A    255  TRP  CA  
          A    256  MET  CA  
          A    257  ILE  CA  
          A    258  ASP  CA  
          A    259  ALA  CA  
          A    260  ASP  CA  
          A    261  SER  CA  
          A    262  ARG  CA  
          A    263  PRO  CA  
          A    264  LYS  CA  
          A    265  PHE  CA  
          A    266  ARG  CA  
          A    267  GLU  CA  
          A    268  LEU  CA  
          A    269  ILE  CA  
          A    270  ILE  CA  
          A    271  GLU  CA  
          A    272  PHE  CA  
          A    273  SER  CA  
          A    274  LYS  CA  
          A    275  MET  CA  
          A    276  ALA  CA  
          A    277  ARG  CA  
          A    278  ASP  CA  
          A    279  PRO  CA  
          A    280  GLN  CA  
          A    281  ARG  CA  
          A    282  TYR  CA  
          A    283  LEU  CA  
          A    284  VAL  CA  
          A    285  ILE  CA  
          A    286  GLN  CA  
          A    287  GLY  CA  
          A    288  ASP  CA  
          A    307  ASP  CA  
          A    308  GLU  CA  
          A    309  GLU  CA  
          A    310  ASP  CA  
          A    311  MET  CA  
          A    312  ASP  CA  
          A    313  ASP  CA  
          A    314  VAL  CA  
          A    315  VAL  CA  
          A    316  ASP  CA  
          A    317  ALA  CA  
          A    318  ASP  CA  
          A    319  GLU  CA  
          A    320  TYR  CA  
          A    321  LEU  CA  
          A    322  ILE  CA  
          A    323  PRO  CA  
          A    324  GLN  CA  
 set-j-atoms
          B    1    AEE  CAQ 
          B    1    AEE  CAO 
          B    1    AEE  NBF 
          B    1    AEE  CAN 
          B    1    AEE  CAA 
          B    1    AEE  HAA 
          B    1    AEE  CAP 
          B    1    AEE  CAR 
          B    1    AEE  NBG 
          B    1    AEE  HAB 
          B    1    AEE  CAS 
          B    1    AEE  CAX 
          B    1    AEE  CAJ 
          B    1    AEE  CAL 
          B    1    AEE  CAI 
          B    1    AEE  CAK 
          B    1    AEE  CAY 
          B    1    AEE  CBA 
          B    1    AEE  NAW 
          B    1    AEE  HAD 
          B    1    AEE  CAM 
          B    1    AEE  C5  
          B    1    AEE  C4  
          B    1    AEE  N3  
          B    1    AEE  C2  
          B    1    AEE  N1  
          B    1    AEE  C6  
          B    1    AEE  NAV 
          B    1    AEE  HAC 
          B    1    AEE  CBE 
          B    1    AEE  CAB 
          B    1    AEE  CAZ 
          B    1    AEE  CAG 
          B    1    AEE  CAD 
          B    1    AEE  CAC 
          B    1    AEE  CAE 
          B    1    AEE  CAH 
 R<average>=   2.082 NOE= 4.50 (- 4.50/+ 1.00) Delta=   2.418  E(NOE)=   0.086

 NOEPRI: RMS diff. =   5.999,  #(violat.> 0.3)=     2 of      4 NOEs
 NOEPRI: RMS diff. class DIST =   0.000,  #(viol.> 0.3)=     0 of      2 NOEs
 NOEPRI: RMS diff. class CONT =  11.751,  #(viol.> 0.3)=     1 of      1 NOEs
 NOEPRI: RMS diff. class SURF =   2.418,  #(viol.> 0.3)=     1 of      1 NOEs
 $$$$$$$$$$$$$$$$$$$$ test set (TEST=    2)  $$$$$$$$$$$$$$$$$$$$$$

 NOEPRI: RMS diff. =     NaN,  #(violat.> 0.3)=     0 of      0 NOEs
 CNSsolve>    evaluate ($rms_noe=$result) 
 EVALUATE: symbol $RMS_NOE set to    5.99878     (real)
 CNSsolve>    evaluate ($violations_noe=$violations) 
 EVALUATE: symbol $VIOLATIONS_NOE set to    2.00000     (real)
 CNSsolve>    if ($Data.noecv eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>      evaluate ($rms_test_noe=$test_rms) 
 CNSsolve>      evaluate ($violations_test_noe=$test_violations) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($rms_test_noe=0.0) 
 EVALUATE: symbol $RMS_TEST_NOE set to    0.00000     (real)
 CNSsolve>      evaluate ($violations_test_noe=0) 
 EVALUATE: symbol $VIOLATIONS_TEST_NOE set to    0.00000     (real)
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.dnarest eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    @RUN:data/sequence/dna-rna_restraints.def 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  energy end 
 --------------- cycle=     8 --------------------------------------------------
 | Etotal =-43.254    grad(E)=0.178      E(BOND)=0.000      E(ANGL)=0.000      |
 | E(DIHE)=0.000      E(IMPR)=0.000      E(VDW )=-34.839    E(ELEC)=-8.501     |
 | E(HARM)=0.000      E(CDIH)=0.000      E(NOE )=0.086                         |
 -------------------------------------------------------------------------------
 CNSsolve>  evaluate ($etot = $ener - $noe) 
 EVALUATE: symbol $ETOT set to   -43.3398     (real)
 CNSsolve>  evaluate ($noe = $eair) 
 EVALUATE: symbol $NOE set to   0.860909E-01 (real)
 CNSsolve>  evaluate ($etot = $etot + $noe) 
 EVALUATE: symbol $ETOT set to   -43.2537     (real)
 CNSsolve> 
 CNSsolve>  evaluate ($Data.flags.dihed = false) 
 EVALUATE: symbol $DATA.FLAGS.DIHED set to FALSE (logical)
 CNSsolve>  if ($nlcount = 1) then 
 NEXTCD: condition evaluated as true
 CNSsolve>    evaluate ($filename="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + ".pdb0") 
 EVALUATE: symbol $FILENAME set to "NEWIT:complex_1.pdb0" (string)
 CNSsolve>  else 
 CNSsolve>    evaluate ($num = $count + $iterations.structures) 
 CNSsolve>    evaluate ($filename="NEWIT:" + $Filenames.fileroot + "_" + encode($num) + ".pdb0") 
 CNSsolve>  end if 
 CNSsolve>  @RUN:protocols/print_coorheader.cns 
 ASSFIL: file print_coorheader.cns opened.
 CNSsolve>! print_coorheader.cns 
 CNSsolve>!    Generate the coordinate header (REMARKS) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>if ($Data.flags.dihed eq FALSE) then evaluate ($dihe = 0) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $DIHE set to    0.00000     (real)
 CNSsolve>if ($Data.flags.sani  eq FALSE) then evaluate ($sani = 0) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $SANI set to    0.00000     (real)
 CNSsolve>if ($Data.flags.xrdc  eq FALSE) then evaluate ($xrdc = 0) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $XRDC set to    0.00000     (real)
 CNSsolve>if ($Data.flags.xpcs  eq FALSE) then evaluate ($xpcs = 0) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $XPCS set to    0.00000     (real)
 CNSsolve>if ($Data.flags.dani  eq FALSE) then evaluate ($dani = 0) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $DANI set to    0.00000     (real)
 CNSsolve>if ($Data.flags.coup  eq FALSE) then evaluate ($coup = 0) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COUP set to    0.00000     (real)
 CNSsolve>if ($Data.flags.vean  eq FALSE) then evaluate ($vean = 0) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $VEAN set to    0.00000     (real)
 CNSsolve>if ($Data.flags.cdih  eq FALSE) then evaluate ($cdih = 0) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $CDIH set to    0.00000     (real)
 CNSsolve>if ($Data.flags.noe   eq FALSE) then evaluate ($noe  = 0) end if 
 NEXTCD: condition evaluated as false
 CNSsolve>if ($Data.flags.rg    eq FALSE) then evaluate ($coll = 0) end if 
 NEXTCD: condition evaluated as true
 EVALUATE: symbol $COLL set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>evaluate($enerall=$etot) 
 EVALUATE: symbol $ENERALL set to   -43.2537     (real)
 CNSsolve>evaluate($bondall=$bond) 
 EVALUATE: symbol $BONDALL set to    0.00000     (real)
 CNSsolve>evaluate($anglall=$angl) 
 EVALUATE: symbol $ANGLALL set to    0.00000     (real)
 CNSsolve>evaluate($imprall=$impr) 
 EVALUATE: symbol $IMPRALL set to    0.00000     (real)
 CNSsolve>evaluate($diheall=$dihe) 
 EVALUATE: symbol $DIHEALL set to    0.00000     (real)
 CNSsolve>evaluate($vdwall=$vdw) 
 EVALUATE: symbol $VDWALL set to   -34.8391     (real)
 CNSsolve>evaluate($elecall=$elec) 
 EVALUATE: symbol $ELECALL set to   -8.50068     (real)
 CNSsolve>evaluate($noeall=$noe) 
 EVALUATE: symbol $NOEALL set to   0.860909E-01 (real)
 CNSsolve>evaluate($rgall=$coll) 
 EVALUATE: symbol $RGALL set to    0.00000     (real)
 CNSsolve>evaluate($cdihall=$cdih) 
 EVALUATE: symbol $CDIHALL set to    0.00000     (real)
 CNSsolve>evaluate($coupall=$coup) 
 EVALUATE: symbol $COUPALL set to    0.00000     (real)
 CNSsolve>evaluate($saniall=$sani+$xrdc) 
 EVALUATE: symbol $SANIALL set to    0.00000     (real)
 CNSsolve>evaluate($veanall=$vean) 
 EVALUATE: symbol $VEANALL set to    0.00000     (real)
 CNSsolve>evaluate($xpcsall=$xpcs) 
 EVALUATE: symbol $XPCSALL set to    0.00000     (real)
 CNSsolve>evaluate($daniall=$dani) 
 EVALUATE: symbol $DANIALL set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  print threshold=0.3 noe 
 CNSsolve>  evaluate ($rms_noe=$result) 
 CNSsolve>  evaluate ($violations_noe=$violations) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.noecv eq false) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($violations_test_noe= 0) 
 EVALUATE: symbol $VIOLATIONS_TEST_NOE set to    0.00000     (real)
 CNSsolve>  evaluate ($rms_test_noe = 0) 
 EVALUATE: symbol $RMS_TEST_NOE set to    0.00000     (real)
 CNSsolve>  evaluate ($npart = 0) 
 EVALUATE: symbol $NPART set to    0.00000     (real)
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($result=0) 
 EVALUATE: symbol $RESULT set to    0.00000     (real)
 CNSsolve>evaluate ($violations=0) 
 EVALUATE: symbol $VIOLATIONS set to    0.00000     (real)
 CNSsolve>print threshold=5. cdih 
 Total number of dihedral angle restraints=     0
  overall scale =    1.0000
 Number of dihedral angle restraints=    0
 Number of violations greater than    5.000:     0
 RMS deviation=   0.000
 CNSsolve>evaluate ($rms_cdih=$result) 
 EVALUATE: symbol $RMS_CDIH set to    0.00000     (real)
 CNSsolve>evaluate ($violations_cdih=$violations) 
 EVALUATE: symbol $VIOLATIONS_CDIH set to    0.00000     (real)
 CNSsolve>evaluate ($result=0) 
 EVALUATE: symbol $RESULT set to    0.00000     (real)
 CNSsolve>print thres=0.05 bonds 
 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 (atom-i        |atom-j        )    dist.   equil.   delta    energy   const. 

 Number of violations greater    0.050:     0
 CNSsolve>evaluate ($rms_bonds=$result) 
 EVALUATE: symbol $RMS_BONDS set to    0.00000     (real)
 CNSsolve>evaluate ($result=0) 
 EVALUATE: symbol $RESULT set to    0.00000     (real)
 CNSsolve>print thres=5. angles 
 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 (atom-i        |atom-j        |atom-k        )  angle    equil.     delta    energy  const. 

 Number of violations greater    5.000:     0
 CNSsolve>evaluate ($rms_angles=$result) 
 EVALUATE: symbol $RMS_ANGLES set to    0.00000     (real)
 CNSsolve>evaluate ($result=0) 
 EVALUATE: symbol $RESULT set to    0.00000     (real)
 CNSsolve>print thres=5. impropers 
 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 Number of violations greater    5.000:     0
 CNSsolve>evaluate ($rms_impropers=$result) 
 EVALUATE: symbol $RMS_IMPROPERS set to    0.00000     (real)
 CNSsolve>evaluate ($result=0) 
 EVALUATE: symbol $RESULT set to    0.00000     (real)
 CNSsolve>print thres=30. dihedrals 
 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 (atom-i        |atom-j        |atom-k        |atom-L        )    angle    equil.   delta    energy   const.   period

 Number of violations greater   30.000:     0
 CNSsolve>evaluate ($rms_dihedrals=$result) 
 EVALUATE: symbol $RMS_DIHEDRALS set to    0.00000     (real)
 CNSsolve>evaluate ($result=0) 
 EVALUATE: symbol $RESULT set to    0.00000     (real)
 CNSsolve>evaluate ($violations=0) 
 EVALUATE: symbol $VIOLATIONS set to    0.00000     (real)
 CNSsolve>coupl print thres=1.0 class * end 
The following couplings have delta J
greater than the cutoff:
  (calculated J) (observed J) (delta J)
  RMS diff. =   0.000, #(violat.> 1.00)=    0. of      0 J-couplings
 CNSsolve>evaluate ($rms_coup = $result) 
 EVALUATE: symbol $RMS_COUP set to    0.00000     (real)
 CNSsolve>evaluate ($violations_coup = $violations) 
 EVALUATE: symbol $VIOLATIONS_COUP set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>evaluate ($result=0) 
 EVALUATE: symbol $RESULT set to    0.00000     (real)
 CNSsolve>evaluate ($violations=0) 
 EVALUATE: symbol $VIOLATIONS set to    0.00000     (real)
 CNSsolve>sani print threshold = 0.20 class rdc1 end 
The following anisotropies have
delta SANI greater than the cutoff:
(calc Anis) (obs Anis) (delta Anis)
 CNSsolve>evaluate( $rms_sani = $result) 
 EVALUATE: symbol $RMS_SANI set to    0.00000     (real)
 CNSsolve>evaluate( $violations_sani = $violations) 
 EVALUATE: symbol $VIOLATIONS_SANI set to    0.00000     (real)
 CNSsolve>evaluate ($result=0) 
 EVALUATE: symbol $RESULT set to    0.00000     (real)
 CNSsolve>evaluate ($violations=0) 
 EVALUATE: symbol $VIOLATIONS set to    0.00000     (real)
 CNSsolve>sani print threshold = 0.20 class rdc2 end 
The following anisotropies have
delta SANI greater than the cutoff:
(calc Anis) (obs Anis) (delta Anis)
 CNSsolve>if ($result > 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 EVALUATE: symbol $VIOLATIONS_SANI set to    0.00000     (real)
 CNSsolve>evaluate ($result=0) 
 EVALUATE: symbol $RESULT set to    0.00000     (real)
 CNSsolve>evaluate ($violations=0) 
 EVALUATE: symbol $VIOLATIONS set to    0.00000     (real)
 CNSsolve>sani print threshold = 0.20 class rdc3 end 
The following anisotropies have
delta SANI greater than the cutoff:
(calc Anis) (obs Anis) (delta Anis)
 CNSsolve>if ($result > 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 EVALUATE: symbol $VIOLATIONS_SANI set to    0.00000     (real)
 CNSsolve>evaluate ($result=0) 
 EVALUATE: symbol $RESULT set to    0.00000     (real)
 CNSsolve>evaluate ($violations=0) 
 EVALUATE: symbol $VIOLATIONS set to    0.00000     (real)
 CNSsolve>sani print threshold = 0.20 class rdc4 end 
The following anisotropies have
delta SANI greater than the cutoff:
(calc Anis) (obs Anis) (delta Anis)
 CNSsolve>if ($result > 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 EVALUATE: symbol $VIOLATIONS_SANI set to    0.00000     (real)
 CNSsolve>evaluate ($result=0) 
 EVALUATE: symbol $RESULT set to    0.00000     (real)
 CNSsolve>evaluate ($violations=0) 
 EVALUATE: symbol $VIOLATIONS set to    0.00000     (real)
 CNSsolve>sani print threshold = 0.20 class rdc5 end 
The following anisotropies have
delta SANI greater than the cutoff:
(calc Anis) (obs Anis) (delta Anis)
 CNSsolve>if ($result > 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 EVALUATE: symbol $VIOLATIONS_SANI set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>if ($Data.flags.xrdc  eq TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  xrdc print threshold = 0.2 class xrd1 end 
 CNSsolve>  evaluate( $rms_xrdc = $result) 
 CNSsolve>  evaluate( $violations_xrdc = $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  xrdc print threshold = 0.2 class xrd2 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xrdc = (0.5 * $rms_xrdc) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xrdc = $violations_xrdc + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  xrdc print threshold = 0.2 class xrd3 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xrdc = (0.5 * $rms_xrdc) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xrdc = $violations_xrdc + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  xrdc print threshold = 0.2 class xrd4 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xrdc = (0.5 * $rms_xrdc) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xrdc = $violations_xrdc + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  xrdc print threshold = 0.2 class xrd5 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xrdc = (0.5 * $rms_xrdc) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xrdc = $violations_xrdc + $violations) 
 CNSsolve>else 
 CNSsolve>  evaluate( $rms_xrdc = 0) 
 EVALUATE: symbol $RMS_XRDC set to    0.00000     (real)
 CNSsolve>  evaluate( $violations_xrdc = 0) 
 EVALUATE: symbol $VIOLATIONS_XRDC set to    0.00000     (real)
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations_xrdc) 
 EVALUATE: symbol $VIOLATIONS_SANI set to    0.00000     (real)
 CNSsolve>evaluate( $rms_sani = $rms_sani + $rms_xrdc) 
 EVALUATE: symbol $RMS_SANI set to    0.00000     (real)
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($Data.flags.xpcs  eq TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs1 end 
 CNSsolve>  evaluate( $rms_xpcs = $result) 
 CNSsolve>  evaluate( $violations_xpcs = $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs2 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs3 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs4 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs5 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs6 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs7 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs8 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs9 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcsA end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>else 
 CNSsolve>  evaluate( $rms_xpcs = 0) 
 EVALUATE: symbol $RMS_XPCS set to    0.00000     (real)
 CNSsolve>  evaluate( $violations_xpcs = 0) 
 EVALUATE: symbol $VIOLATIONS_XPCS set to    0.00000     (real)
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.vean  eq TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea1 end 
 CNSsolve>  evaluate( $rms_vean = $result) 
 CNSsolve>  evaluate( $violations_vean = $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea2 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea3 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea4 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea5 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>else 
 CNSsolve>  evaluate( $rms_vean = 0) 
 EVALUATE: symbol $RMS_VEAN set to    0.00000     (real)
 CNSsolve>  evaluate( $violations_vean = 0) 
 EVALUATE: symbol $VIOLATIONS_VEAN set to    0.00000     (real)
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($Data.flags.dani  eq TRUE) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan1 end 
 CNSsolve>  evaluate( $rms_dani = $result) 
 CNSsolve>  evaluate( $violations_dani = $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan2 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan3 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan4 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan5 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>else 
 CNSsolve>  evaluate( $rms_dani = 0) 
 EVALUATE: symbol $RMS_DANI set to    0.00000     (real)
 CNSsolve>  evaluate( $violations_dani = 0) 
 EVALUATE: symbol $VIOLATIONS_DANI set to    0.00000     (real)
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>{====>} {* define ASA-based solvation parameters *} 
 CNSsolve>inline @RUN:protocols/def_solv_param.cns 
 ASSFIL: file def_solv_param.cns opened.
 CNSsolve>! def_solv_param.cns 
 CNSsolve>!    Define atomic solvation parameters taken from Fernandez-Recio et al. JMB 335:843 (2004) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($arofac = 6.26) 
 EVALUATE: symbol $AROFAC set to    6.26000     (real)
 CNSsolve>evaluate ($alifac = 1.27) 
 EVALUATE: symbol $ALIFAC set to    1.27000     (real)
 CNSsolve>evaluate ($polfac = 2.30) 
 EVALUATE: symbol $POLFAC set to    2.30000     (real)
 CNSsolve>do (store1 =  0.0000) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (store1 =  0.0151 * $alifac) (name C*) 
 SELRPN:   1598 atoms have been selected out of   3007
 CNSsolve>do (store1 =  0.0176 * $arofac) ((name CG* or name CD* or name CE* or name CH* or name CZ*) and (resn PHE or resn TYR or resn HIS or resn TRP)) 
 SELRPN:    183 atoms have been selected out of   3007
 CNSsolve>do (store1 = -0.0170 * $polfac) (name N*) 
 SELRPN:    415 atoms have been selected out of   3007
 CNSsolve>do (store1 = -0.0548 * $polfac) (name NT* or (name NZ* and resn LYS)) 
 SELRPN:     23 atoms have been selected out of   3007
 CNSsolve>do (store1 = -0.0273 * $polfac) (name NH* and resn ARG) 
 SELRPN:     28 atoms have been selected out of   3007
 CNSsolve>do (store1 = -0.0136 * $polfac) (name O*) 
 SELRPN:    452 atoms have been selected out of   3007
 CNSsolve>do (store1 = -0.0185 * $polfac) (name OG* or name OH) 
 SELRPN:     38 atoms have been selected out of   3007
 CNSsolve>do (store1 = -0.0299 * $polfac) ((name OD* and resn ASP) or (name OE* and resn GLU)) 
 SELRPN:     90 atoms have been selected out of   3007
 CNSsolve>do (store1 =  0.0112 * $polfac) (name S*) 
 SELRPN:     16 atoms have been selected out of   3007
 CNSsolve>do (store1 =  0.0022 * $polfac) ((name S* and attr charge = -0.3) or (name SD and resn MET)) 
 SELRPN:     10 atoms have been selected out of   3007
 CNSsolve> 
 CNSsolve>{====>} {* buried surface area *} 
 CNSsolve>evaluate ($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve>evaluate ($saafree = 0) 
 EVALUATE: symbol $SAAFREE set to    0.00000     (real)
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>  {====>} {* buried surface area *} 
 CNSsolve>  do (rmsd = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  surface mode=access accu=0.075 rh2o=1.4 sele=(segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) end 
 SELRPN:   2970 atoms have been selected out of   3007
 SURFAC: half the sigma value being used for atomic radii.
 SURFAC: ACCEssible surface area
 SURFAC: ACCUracy= 0.07 RH2O=  1.40
         Z-grid=  0.32 number-of-Z-sections=  145
         measures-of-arc= 26677 and 34135
 CNSsolve>  show sum (rmsd) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 SELRPN:   2970 atoms have been selected out of   3007
 SHOW: sum over selected elements =   15108.619683
 CNSsolve>  evaluate ($saafree = $saafree + $result) 
 EVALUATE: symbol $SAAFREE set to    15108.6     (real)
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>  {====>} {* buried surface area *} 
 CNSsolve>  do (rmsd = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>  surface mode=access accu=0.075 rh2o=1.4 sele=(segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) end 
 SELRPN:     37 atoms have been selected out of   3007
 SURFAC: half the sigma value being used for atomic radii.
 SURFAC: ACCEssible surface area
 SURFAC: ACCUracy= 0.07 RH2O=  1.40
         Z-grid=  0.32 number-of-Z-sections=   52
         measures-of-arc=    44 and   147
 CNSsolve>  show sum (rmsd) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 SELRPN:     37 atoms have been selected out of   3007
 SHOW: sum over selected elements =     651.030041
 CNSsolve>  evaluate ($saafree = $saafree + $result) 
 EVALUATE: symbol $SAAFREE set to    15759.6     (real)
 CNSsolve>end loop nloop1 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($nchain1 = $nchain1 + 1) 
 CNSsolve>  {====>} {* buried surface area *} 
 CNSsolve>  do (rmsd = 0) (all) 
 CNSsolve>  surface mode=access accu=0.075 rh2o=1.4 sele=(segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) end 
 CNSsolve>  show sum (rmsd) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 CNSsolve>  evaluate ($saafree = $saafree + $result) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>do (rmsd = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>do (store2 = 0) (all) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>surface mode=access accu=0.075 rh2o=1.4 sele=(not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) end 
 SELRPN:   3007 atoms have been selected out of   3007
 SURFAC: half the sigma value being used for atomic radii.
 SURFAC: ACCEssible surface area
 SURFAC: ACCUracy= 0.07 RH2O=  1.40
         Z-grid=  0.32 number-of-Z-sections=  145
         measures-of-arc= 27284 and 34345
 CNSsolve>show sum (rmsd) (not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =   14938.639336
 CNSsolve>evaluate ($satot = $result) 
 EVALUATE: symbol $SATOT set to    14938.6     (real)
 CNSsolve>do (store2 = rmsd * store1) (not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 SELRPN:   3007 atoms have been selected out of   3007
 CNSsolve>show sum (store2) (not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 SELRPN:   3007 atoms have been selected out of   3007
 SHOW: sum over selected elements =     -78.047163
 CNSsolve>evaluate ($esolcplx = $result) 
 EVALUATE: symbol $ESOLCPLX set to   -78.0472     (real)
 CNSsolve>evaluate ($saburied = $saafree - $satot) 
 EVALUATE: symbol $SABURIED set to    821.010     (real)
 CNSsolve>if ($saburied < 0) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($saburied = -999999) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($refine.calcdesolv eq false) then 
 NEXTCD: condition evaluated as true
 CNSsolve>  evaluate ($edesolv = $esolcplx - $esolfree) 
 EVALUATE: symbol $EDESOLV set to   -7.71516     (real)
 CNSsolve>elseif ($iteration < 2) then 
 CNSsolve>  evaluate ($edesolv = $esolcplx - $esolfree) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($dhbinding = $edesolv + $eintcplx - $eintfree + $elec + $vdw) 
 EVALUATE: symbol $DHBINDING set to   -440.909     (real)
 CNSsolve> 
 CNSsolve>if ($data.ncomponents = 1) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($saburied = 0) 
 CNSsolve>  evaluate ($edesolv = 0) 
 CNSsolve>  evaluate ($dhbinding = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($enerall = $enerall + $esym) 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.ncs eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($enerall = $enerall + $ncs) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($procwat = false) 
 EVALUATE: symbol $PROCWAT set to FALSE (logical)
 CNSsolve>if ($refine.keepwater eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($procwat = true) 
 CNSsolve>end if 
 CNSsolve>if ($data.waterdock eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  evaluate ($procwat = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($procwat eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>  if ($iteration eq 2) then 
 CNSsolve>    do (store3 = 0) (all) 
 CNSsolve>    eval($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>      eval($nchain2 = $nchain1) 
 CNSsolve>      while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>        eval($nchain2 = $nchain2 + 1) 
 CNSsolve>        do (store3 = 1) (byres ((resn WAT or resn HOH or resn TIP* or resn DMS) and (segid $Toppar.prot_segid_$nchain1) around 3.5 
 CNSsolve>                                          and (segid $Toppar.prot_segid_$nchain2) around 3.5)) 
 CNSsolve>      end loop nloop2 
 CNSsolve>    end loop nloop1 
 CNSsolve>    dele sele=(attr store3=0 and (resn DMS or (resn WAT or resn HOH or resn TIP*))) end 
 CNSsolve>  end if 
 CNSsolve>  if ($iteration ne 0) then 
 CNSsolve>    ident (store3) (not all) 
 CNSsolve>  end if 
 CNSsolve>  flag exclude * include vdw elec  end 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    igroup 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) (((resn WAT or resn HOH or resn TIP*) or resn DMS) and not store3) weight * 1.0 end 
 CNSsolve>      interaction (not segid $Toppar.prot_segid_$nchain1) ((resn WAT or resn HOH or resn TIP*) or resn DMS) weight * 0.0 end 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) (not (((resn WAT or resn HOH or resn TIP*) or resn DMS) and store3)) weight * 0.0 end 
 CNSsolve>    end 
 CNSsolve>    energy end 
 CNSsolve>    evaluate ($ener_water_$nchain1 = $ener) 
 CNSsolve>    evaluate ($enerall = $enerall + $ener) 
 CNSsolve>    evaluate ($vdw_water_$nchain1 = $vdw) 
 CNSsolve>    evaluate ($elec_water_$nchain1 = $elec) 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve>  if ($data.ncomponents < 6) then 
 CNSsolve>    eval($nchain1 = $data.ncomponents) 
 CNSsolve>    while ($nchain1 < 6) loop nloop1 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>      evaluate ($ener_water_$nchain1 = 0.0) 
 CNSsolve>      evaluate ($vdw_water_$nchain1 = 0.0) 
 CNSsolve>      evaluate ($elec_water_$nchain1 = 0.0) 
 CNSsolve>    end loop nloop1 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  igroup 
 CNSsolve>    while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) (all) weight * 0.0 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>    interaction (((resn WAT or resn HOH or resn TIP*) or resn DMS) and not store3) 
 CNSsolve>                (((resn WAT or resn HOH or resn TIP*) or resn DMS) and not store3)  weight * 1.0 end 
 CNSsolve>    interaction (store3) (store3)  weight * 0.0 end 
 CNSsolve>  end 
 CNSsolve>  energy end 
 CNSsolve>  evaluate ($ener_water_water = $ener) 
 CNSsolve>  evaluate ($enerall = $enerall + $ener) 
 CNSsolve>  evaluate ($vdw_water_water = $vdw) 
 CNSsolve>  evaluate ($elec_water_water = $elec) 
 CNSsolve>else 
 CNSsolve>  eval($nchain1 = 0) 
 EVALUATE: symbol $NCHAIN1 set to    0.00000     (real)
 CNSsolve> 
 CNSsolve>  while ($nchain1 < 6) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    1.00000     (real)
 CNSsolve>    evaluate ($ener_water_$nchain1 = 0.0) 
 EVALUATE: symbol $ENER_WATER_1 set to    0.00000     (real)
 CNSsolve>    evaluate ($vdw_water_$nchain1 = 0.0) 
 EVALUATE: symbol $VDW_WATER_1 set to    0.00000     (real)
 CNSsolve>    evaluate ($elec_water_$nchain1 = 0.0) 
 EVALUATE: symbol $ELEC_WATER_1 set to    0.00000     (real)
 CNSsolve>  end loop nloop1 
 CNSsolve>  while ($nchain1 < 6) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    2.00000     (real)
 CNSsolve>    evaluate ($ener_water_$nchain1 = 0.0) 
 EVALUATE: symbol $ENER_WATER_2 set to    0.00000     (real)
 CNSsolve>    evaluate ($vdw_water_$nchain1 = 0.0) 
 EVALUATE: symbol $VDW_WATER_2 set to    0.00000     (real)
 CNSsolve>    evaluate ($elec_water_$nchain1 = 0.0) 
 EVALUATE: symbol $ELEC_WATER_2 set to    0.00000     (real)
 CNSsolve>  end loop nloop1 
 CNSsolve>  while ($nchain1 < 6) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    3.00000     (real)
 CNSsolve>    evaluate ($ener_water_$nchain1 = 0.0) 
 EVALUATE: symbol $ENER_WATER_3 set to    0.00000     (real)
 CNSsolve>    evaluate ($vdw_water_$nchain1 = 0.0) 
 EVALUATE: symbol $VDW_WATER_3 set to    0.00000     (real)
 CNSsolve>    evaluate ($elec_water_$nchain1 = 0.0) 
 EVALUATE: symbol $ELEC_WATER_3 set to    0.00000     (real)
 CNSsolve>  end loop nloop1 
 CNSsolve>  while ($nchain1 < 6) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    4.00000     (real)
 CNSsolve>    evaluate ($ener_water_$nchain1 = 0.0) 
 EVALUATE: symbol $ENER_WATER_4 set to    0.00000     (real)
 CNSsolve>    evaluate ($vdw_water_$nchain1 = 0.0) 
 EVALUATE: symbol $VDW_WATER_4 set to    0.00000     (real)
 CNSsolve>    evaluate ($elec_water_$nchain1 = 0.0) 
 EVALUATE: symbol $ELEC_WATER_4 set to    0.00000     (real)
 CNSsolve>  end loop nloop1 
 CNSsolve>  while ($nchain1 < 6) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    5.00000     (real)
 CNSsolve>    evaluate ($ener_water_$nchain1 = 0.0) 
 EVALUATE: symbol $ENER_WATER_5 set to    0.00000     (real)
 CNSsolve>    evaluate ($vdw_water_$nchain1 = 0.0) 
 EVALUATE: symbol $VDW_WATER_5 set to    0.00000     (real)
 CNSsolve>    evaluate ($elec_water_$nchain1 = 0.0) 
 EVALUATE: symbol $ELEC_WATER_5 set to    0.00000     (real)
 CNSsolve>  end loop nloop1 
 CNSsolve>  while ($nchain1 < 6) loop nloop1 
 NEXTCD: condition evaluated as true
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 EVALUATE: symbol $NCHAIN1 set to    6.00000     (real)
 CNSsolve>    evaluate ($ener_water_$nchain1 = 0.0) 
 EVALUATE: symbol $ENER_WATER_6 set to    0.00000     (real)
 CNSsolve>    evaluate ($vdw_water_$nchain1 = 0.0) 
 EVALUATE: symbol $VDW_WATER_6 set to    0.00000     (real)
 CNSsolve>    evaluate ($elec_water_$nchain1 = 0.0) 
 EVALUATE: symbol $ELEC_WATER_6 set to    0.00000     (real)
 CNSsolve>  end loop nloop1 
 CNSsolve>  while ($nchain1 < 6) loop nloop1 
 NEXTCD: condition evaluated as false
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    evaluate ($ener_water_$nchain1 = 0.0) 
 CNSsolve>    evaluate ($vdw_water_$nchain1 = 0.0) 
 CNSsolve>    evaluate ($elec_water_$nchain1 = 0.0) 
 CNSsolve>  end loop nloop1 
 CNSsolve>  evaluate ($ener_water_water = 0.0) 
 EVALUATE: symbol $ENER_WATER_WATER set to    0.00000     (real)
 CNSsolve>  evaluate ($vdw_water_water = 0.0) 
 EVALUATE: symbol $VDW_WATER_WATER set to    0.00000     (real)
 CNSsolve>  evaluate ($elec_water_water = 0.0) 
 EVALUATE: symbol $ELEC_WATER_WATER set to    0.00000     (real)
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! File name 
 CNSsolve>evaluate ($initialstruct = $file - "PREVIT:") 
 EVALUATE: symbol $INITIALSTRUCT set to "complex_1.pdb" (string)
 CNSsolve> 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks HADDOCK run for $Filenames.fileroot 
 CNSsolve>remarks initial structure: $initialstruct 
 CNSsolve>remarks final NOE weights: unambig $Data.unamb_cool3 amb: $Data.amb_cool3 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks            total,bonds,angles,improper,dihe,vdw,elec,air,cdih,coup,rdcs,vean,dani,xpcs,rg 
 CNSsolve>remarks energies: $enerall, $bondall, $anglall, $imprall, $diheall, $vdwall, $elecall, $noeall, $cdihall, $coupall, $saniall, $veanall, $daniall, $xpcsall, $rgall 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks            bonds,angles,impropers,dihe,air,cdih,coup,rdcs,vean,dani,xpcs 
 CNSsolve>remarks rms-dev.: $rms_bonds,$rms_angles,$rms_impropers,$rms_dihedrals,$rms_noe,$rms_cdih,$rms_coup, $rms_sani, $rms_vean, $rms_dani, $rms_xpcs 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks               air,cdih,coup,rdcs,vean,dani,xpcs 
 CNSsolve>remarks               >0.3,>5,>1,>0,>5,>0.2,>0.2 
 CNSsolve>remarks violations.: $violations_noe, $violations_cdih, $violations_coup, $violations_sani, $violations_vean, $violations_dani, $violations_xpcs 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks                        CVpartition#,violations,rms 
 CNSsolve>remarks AIRs cross-validation: $npart, $violations_test_noe, $rms_test_noe 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks NCS energy: $ncs 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks Symmetry energy: $esym 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks Desolvation energy: $edesolv 
 CNSsolve>remarks Internal energy free molecules: $eintfree 
 CNSsolve>remarks Internal energy complex: $eintcplx 
 CNSsolve>remarks Binding energy: $dhbinding 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks buried surface area: $saburied 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks water - chain1: $ener_water_1 $vdw_water_1 $elec_water_1 
 CNSsolve>remarks water - chain2: $ener_water_2 $vdw_water_2 $elec_water_2 
 CNSsolve>remarks water - chain3: $ener_water_3 $vdw_water_3 $elec_water_3 
 CNSsolve>remarks water - chain4: $ener_water_4 $vdw_water_4 $elec_water_4 
 CNSsolve>remarks water - chain5: $ener_water_5 $vdw_water_5 $elec_water_5 
 CNSsolve>remarks water - chain6: $ener_water_6 $vdw_water_6 $elec_water_6 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks water - water: $ener_water_water $vdw_water_water $elec_water_water 
 CNSsolve>remarks =============================================================== 
 CNSsolve>  coor sele= (not name h* and not resn ani and not resn xan and not resn dan) orient end 
 SELRPN:   2481 atoms have been selected out of   3007
 COOR: using atom subset.
 MOMENTS
 171898.54750742   4744.71653949  -2662.70264681
                 282742.50225649   3230.17196630
                                 525174.37508385


 Oriented coordinate set r' related to original set r by r'=R*r  + T
 Translation vector T = (   -0.0967   -0.1454   -0.1117)

 Rotation matrix =
    0.999886    0.013175   -0.007358
   -0.012847    0.998992    0.043008
    0.007917   -0.042908    0.999048
 Corresp. Eulerian angles (theta1,theta2,theta3)    10.4544    2.5008  350.2914
 Corresp. spherical polar angles (psi,phi,kappa)    99.6570  163.1496  357.3904
 Corresp. rotation angle     2.6096 about axis       0.9435    0.1677    0.2858
 Corresp. quaternions     0.9997    0.0215    0.0038    0.0065

 CNSsolve>  if ($data.waterdock eq true) then 
 NEXTCD: condition evaluated as false
 CNSsolve>    write coordinates sele=(not (resn WAT or resn HOH)) output=$filename end 
 CNSsolve>    inline @RUN:protocols/waterdock_out1.cns 
 ASSFIL: file waterdock_out1.cns opened.
 CNSsolve>! waterdock_out1.cns 
 CNSsolve>!    Output information about waters in solvated docking 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($filename="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + "_water.pdbw") 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH) and not store3) 
 CNSsolve>show sum (store1) (all) 
 CNSsolve>if ($result > 0) then 
 CNSsolve>  write coordinates sele= ((resn WAT or resn HOH) and not store3) output =$filename end 
 CNSsolve>else 
 CNSsolve>  set display=$filename end 
 CNSsolve>  display REMARK no water kept 
 CNSsolve>  display END 
 CNSsolve>  close $filename end 
 CNSsolve>end if 
 CNSsolve>if ($data.water_analysis eq true) then 
 CNSsolve>  coor sele=((resn WAT or resn HOH)) orient end 
 CNSsolve>  show aver (x*x) ((resn WAT or resn HOH)) 
 CNSsolve>  evaluate ($rx = $result) 
 CNSsolve>  show aver (y*y) ((resn WAT or resn HOH)) 
 CNSsolve>  evaluate ($ry = $result) 
 CNSsolve>  show aver (z*z) ((resn WAT or resn HOH)) 
 CNSsolve>  evaluate ($rz = $result) 
 CNSsolve>  evaluate ($filename = "NEWIT:"+"rxyz_"+encode($count)+".disp") 
 CNSsolve>  set display=$filename end 
 CNSsolve>  display $rx $ry $rz 
 CNSsolve>  close $filename end 
 CNSsolve>  show sum(1) ((resn WAT or resn HOH) and name OH2) 
 CNSsolve>  eval ($nrwater=$result) 
 CNSsolve>  evaluate ($filename = "NEWIT:"+"nwater_"+encode($count)+".disp") 
 CNSsolve>  set display=$filename end 
 CNSsolve>  display $nrwater 
 CNSsolve>  close $filename end 
 CNSsolve>end if 
 CNSsolve>  else 
 CNSsolve>    write coordinates output=$filename end 
 ASSFIL: file complex_1.pdb0 opened.
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  coor swap end 
 COOR: selected coordinates swaped (main<->comp)
 CNSsolve> 
 CNSsolve>end loop rotloop2 
 CNSsolve>while ($nlcount < $rotiter) loop rotloop2 
 NEXTCD: condition evaluated as false
 CNSsolve> 
 CNSsolve>  evaluate ($nlcount = $nlcount + 1) 
 CNSsolve> 
 CNSsolve>{* ===================== calculate complex internal energy *} 
 CNSsolve>  evaluate ($kinter = 1.0) 
 CNSsolve>   
 CNSsolve>! scale_intra_only.cns 
 CNSsolve>!    Scaling of intramolecular energies (no intermolecular energies) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 end 
 CNSsolve> 
 CNSsolve> end loop nloop1 
 CNSsolve> 
 CNSsolve> interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  energy end 
 CNSsolve>  evaluate ($eintcplx = $bond + $angl + $impr + $dihe + $vdw + $elec) 
 CNSsolve>  if ($data.ncomponents = 1) then 
 CNSsolve>    evaluate ($eintfree = $eintcplx) 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>{* ===================== calculate final energies and write structure *} 
 CNSsolve>  evaluate ($cdih=0.0) 
 CNSsolve>  flag incl noe cdih end 
 CNSsolve>  if ($Data.flags.sani eq true) then 
 CNSsolve>    flag incl sani end 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.flags.xrdc eq true) then 
 CNSsolve>    flag incl xrdc end 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.flags.xpcs eq true) then 
 CNSsolve>    flag incl xpcs end 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.flags.dani eq true) then 
 CNSsolve>    flag incl dani end 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.flags.vean eq true) then 
 CNSsolve>    flag incl vean end 
 CNSsolve>  end if 
 CNSsolve>  if ($Data.ncomponents > 1) then 
 CNSsolve>    evaluate ($kinter = 1.0) 
 CNSsolve>     
 CNSsolve>! scale_inter_final.cns 
 CNSsolve>!   Scaling of intermolecular interactions 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    eval($nchain2 = $nchain1 ) 
 CNSsolve>    while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain2 = $nchain2 + 1) 
 CNSsolve>      eval($scalfac = $kinter * $Toppar.int_$nchain1_$nchain2) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                  (segid $Toppar.prot_segid_$nchain2 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 vdw $scalfac elec $scalfac end 
 CNSsolve>    end loop nloop2 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve> 
 CNSsolve>  interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve>  interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  else 
 CNSsolve>     
 CNSsolve>! scale_intra_only.cns 
 CNSsolve>!    Scaling of intramolecular energies (no intermolecular energies) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>igroup interaction (not all) (not all) end 
 CNSsolve> 
 CNSsolve>igroup 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    interaction (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) 
 CNSsolve>                (segid $Toppar.prot_segid_$nchain1 and not (resn ANI or resn DAN or resn XAN)) weight * 1.0 end 
 CNSsolve> 
 CNSsolve> end loop nloop1 
 CNSsolve> 
 CNSsolve> interaction (resn ANI) (resn ANI) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> interaction (resn DAN) (resn DAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> interaction (resn XAN) (resn XAN) weight * 1.0 vdw 0.0 elec 0.0 end 
 CNSsolve> 
 CNSsolve>end 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  noe 
 CNSsolve>    scale dist $Data.unamb_cool3 
 CNSsolve>    scale ambi $Data.amb_cool3 
 CNSsolve>    scale hbon 0.0 
 CNSsolve>    scale symm 0.0 
 CNSsolve>    scale cont 0.0 
 CNSsolve>  end 
 CNSsolve>  energy end 
 CNSsolve>  evaluate ($eair= $noe) 
 CNSsolve> 
 CNSsolve>  evaluate ($esym = 0.0) 
 CNSsolve>  evaluate ($ncs = 0.0) 
 CNSsolve>  if ($Data.flags.sym  eq true) then 
 CNSsolve>    noe reset nres= 200000 end 
 CNSsolve>     
 CNSsolve>! symmultimer.cns 
 CNSsolve>!    Define symmetry restraints 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>! Define NCS restraints for symmetrical multimers 
 CNSsolve>if ($Data.flags.ncs eq true) then 
 CNSsolve> 
 CNSsolve>  ncs restraints 
 CNSsolve>    initialize 
 CNSsolve>    eval ($ncount = 0) 
 CNSsolve>    while ($ncount < $data.numncs) loop ncsloop 
 CNSsolve>      eval ($ncount = $ncount + 1) 
 CNSsolve>      group 
 CNSsolve>        equi (not name H* and resid $Toppar.ncs_sta1_$ncount : $Toppar.ncs_end1_$ncount and segid $Toppar.ncs_seg1_$ncount) 
 CNSsolve>        equi (not name H* and resid $Toppar.ncs_sta2_$ncount : $Toppar.ncs_end2_$ncount and segid $Toppar.ncs_seg2_$ncount) 
 CNSsolve>	weight = $Data.kncs 
 CNSsolve>      end 
 CNSsolve>    end loop ncsloop 
 CNSsolve>    ? 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym eq true) then 
 CNSsolve> 
 CNSsolve>  noe class symm end 
 CNSsolve> 
 CNSsolve>! Define C2 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc2sym) loop c2symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c2sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c2sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c2sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c2sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c2sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c2sym_seg2_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc2sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resid1 = $i1start) 
 CNSsolve>      evaluate ($resid2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resid3 = $i2start) 
 CNSsolve>      evaluate ($resid4 = $i1end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve>	assign (resid $resid1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>	       (resid $resid2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>	assign (resid $resid3 and (name CA or name P)  and segid $chain2) 
 CNSsolve>	       (resid $resid4 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + 1) 
 CNSsolve>      evaluate ($i1start = $i1start + 1) 
 CNSsolve>      evaluate ($i2start = $i2start + 1) 
 CNSsolve> 
 CNSsolve>    end loop genc2sym 
 CNSsolve> 
 CNSsolve>  end loop c2symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! Define C3 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc3sym) loop c3symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c3sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c3sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c3sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c3sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c3sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c3sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.c3sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.c3sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.c3sym_seg3_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc3sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst1 = $i1start) 
 CNSsolve>      evaluate ($resst2 = $i2start) 
 CNSsolve>      evaluate ($resst3 = $i3start) 
 CNSsolve>      evaluate ($resen1 = $i1end - $icount) 
 CNSsolve>      evaluate ($resen2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resen3 = $i3end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve> 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resen1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resen1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + 2) 
 CNSsolve>      evaluate ($i1start = $i1start + 2) 
 CNSsolve>      evaluate ($i2start = $i2start + 2) 
 CNSsolve>      evaluate ($i3start = $i3start + 2) 
 CNSsolve> 
 CNSsolve>    end loop genc3sym 
 CNSsolve> 
 CNSsolve>  end loop c3symloop 
 CNSsolve> 
 CNSsolve>! Define S3 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.nums3sym) loop s3symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.s3sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.s3sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.s3sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.s3sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.s3sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.s3sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.s3sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.s3sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.s3sym_seg3_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    eval ($istep = 4) 
 CNSsolve>    eval ($istop = $i1end - $istep) 
 CNSsolve>    while ($i1start < $istop) loop gens3sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst11 = $i1start) 
 CNSsolve>      evaluate ($resst21 = $i1start+1) 
 CNSsolve>      evaluate ($resst12 = $i2start) 
 CNSsolve>      evaluate ($resst22 = $i2start+1) 
 CNSsolve>      evaluate ($resst13 = $i3start) 
 CNSsolve>      evaluate ($resst23 = $i3start+1) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve> 
 CNSsolve>!         assign (resid $resst11 and (name CA or name P)  and segid $chain1) 
 CNSsolve>!                (resid $resst12 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>!         assign (resid $resst21 and (name CA or name P)  and segid $chain1) 
 CNSsolve>!                (resid $resst22 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>! 
 CNSsolve>!         assign (resid $resst12 and (name CA or name P)  and segid $chain2) 
 CNSsolve>!                (resid $resst13 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>!         assign (resid $resst22 and (name CA or name P)  and segid $chain2) 
 CNSsolve>!                (resid $resst23 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst11 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst12 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst12 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst13 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst21 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst22 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst22 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst23 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + $istep) 
 CNSsolve>      evaluate ($i1start = $i1start + $istep) 
 CNSsolve>      evaluate ($i2start = $i2start + $istep) 
 CNSsolve>      evaluate ($i3start = $i3start + $istep) 
 CNSsolve> 
 CNSsolve>    end loop gens3sym 
 CNSsolve> 
 CNSsolve>  end loop s3symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! Define C4 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>  eval ($istep = 10) 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc4sym) loop c4symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c4sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c4sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c4sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c4sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c4sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c4sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.c4sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.c4sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.c4sym_seg3_$ncount) 
 CNSsolve>    evaluate ($i4start = decode($Toppar.c4sym_sta4_$ncount)) 
 CNSsolve>    evaluate ($i4end   = decode($Toppar.c4sym_end4_$ncount)) 
 CNSsolve>    evaluate ($chain4  = $Toppar.c4sym_seg4_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the four defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    evaluate ($diff4 = $i4end - $i4start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff3 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc4sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst1 = $i1start) 
 CNSsolve>      evaluate ($resst2 = $i2start) 
 CNSsolve>      evaluate ($resst3 = $i3start) 
 CNSsolve>      evaluate ($resst4 = $i4start) 
 CNSsolve>      evaluate ($resen1 = $i1end - $icount) 
 CNSsolve>      evaluate ($resen2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resen3 = $i3end - $icount) 
 CNSsolve>      evaluate ($resen4 = $i4end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve>		 
 CNSsolve>		! N to N sequential restraints to prevent anti-parallel arrangements 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resst4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resst4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>		 
 CNSsolve>		! N to C sequential restraints to assure planarity 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resen4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resen4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resen1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resen1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>		 
 CNSsolve>	 assign (resid $resen1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resen2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resen2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resen3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resst4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resen3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resst4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resen4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resen4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resen1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve> 
 CNSsolve>		! Cross restraints 
 CNSsolve>		{ 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resen3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resen1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resen4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resen2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>		} 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + $istep) 
 CNSsolve>      evaluate ($i1start = $i1start + $istep) 
 CNSsolve>      evaluate ($i2start = $i2start + $istep) 
 CNSsolve>      evaluate ($i3start = $i3start + $istep) 
 CNSsolve>      evaluate ($i4start = $i4start + $istep) 
 CNSsolve> 
 CNSsolve>    end loop genc4sym 
 CNSsolve> 
 CNSsolve>  end loop c4symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>! Define C5 symmetry restraints for symmetrical multimers 
 CNSsolve>! 
 CNSsolve>  eval ($istep = 4) 
 CNSsolve>  eval ($ncount = 0) 
 CNSsolve>  while ($ncount < $data.numc5sym) loop c5symloop 
 CNSsolve> 
 CNSsolve>    eval ($ncount = $ncount + 1) 
 CNSsolve>    evaluate ($i1start = decode($Toppar.c5sym_sta1_$ncount)) 
 CNSsolve>    evaluate ($i1end   = decode($Toppar.c5sym_end1_$ncount)) 
 CNSsolve>    evaluate ($chain1  = $Toppar.c5sym_seg1_$ncount) 
 CNSsolve>    evaluate ($i2start = decode($Toppar.c5sym_sta2_$ncount)) 
 CNSsolve>    evaluate ($i2end   = decode($Toppar.c5sym_end2_$ncount)) 
 CNSsolve>    evaluate ($chain2  = $Toppar.c5sym_seg2_$ncount) 
 CNSsolve>    evaluate ($i3start = decode($Toppar.c5sym_sta3_$ncount)) 
 CNSsolve>    evaluate ($i3end   = decode($Toppar.c5sym_end3_$ncount)) 
 CNSsolve>    evaluate ($chain3  = $Toppar.c5sym_seg3_$ncount) 
 CNSsolve>    evaluate ($i4start = decode($Toppar.c5sym_sta4_$ncount)) 
 CNSsolve>    evaluate ($i4end   = decode($Toppar.c5sym_end4_$ncount)) 
 CNSsolve>    evaluate ($chain4  = $Toppar.c5sym_seg4_$ncount) 
 CNSsolve>    evaluate ($i5start = decode($Toppar.c5sym_sta5_$ncount)) 
 CNSsolve>    evaluate ($i5end   = decode($Toppar.c5sym_end5_$ncount)) 
 CNSsolve>    evaluate ($chain5  = $Toppar.c5sym_seg5_$ncount) 
 CNSsolve> 
 CNSsolve>    !first check that the chain lengths are equal for the two defined molecules 
 CNSsolve>    evaluate ($diff1 = $i1end - $i1start) 
 CNSsolve>    evaluate ($diff2 = $i2end - $i2start) 
 CNSsolve>    evaluate ($diff3 = $i3end - $i3start) 
 CNSsolve>    evaluate ($diff4 = $i4end - $i4start) 
 CNSsolve>    evaluate ($diff5 = $i5end - $i5start) 
 CNSsolve>    if ($diff1 ne $diff2) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff1 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff2 ne $diff3) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff3 ne $diff4) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve>    if ($diff4 ne $diff5) then 
 CNSsolve>      display CHAIN LENGHT FOR SYMMETRY RESTRAINTS DO NOT MATCH 
 CNSsolve>      display PLEASE CHECK CAREFULLY YOUR INPUT 
 CNSsolve>      display ... stopping ... 
 CNSsolve>      stop 
 CNSsolve>    end if 
 CNSsolve> 
 CNSsolve>    eval ($icount = 0) 
 CNSsolve>    while ($i1start < $i1end) loop genc5sym 
 CNSsolve> 
 CNSsolve>      evaluate ($resst1 = $i1start) 
 CNSsolve>      evaluate ($resst2 = $i2start) 
 CNSsolve>      evaluate ($resst3 = $i3start) 
 CNSsolve>      evaluate ($resst4 = $i4start) 
 CNSsolve>      evaluate ($resst5 = $i5start) 
 CNSsolve>      evaluate ($resen1 = $i1end - $icount) 
 CNSsolve>      evaluate ($resen2 = $i2end - $icount) 
 CNSsolve>      evaluate ($resen3 = $i3end - $icount) 
 CNSsolve>      evaluate ($resen4 = $i4end - $icount) 
 CNSsolve>      evaluate ($resen5 = $i5end - $icount) 
 CNSsolve> 
 CNSsolve>      noe 
 CNSsolve>{ 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resen3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resen4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resen4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resen5 and (name CA or name P)  and segid $chain5) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resen5 and (name CA or name P)  and segid $chain5) 0 0 0 
 CNSsolve>         assign (resid $resst5 and (name CA or name P)  and segid $chain5) 
 CNSsolve>                (resid $resen1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst5 and (name CA or name P)  and segid $chain5) 
 CNSsolve>                (resid $resen1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resen2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>} 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve>         assign (resid $resst1 and (name CA or name P)  and segid $chain1) 
 CNSsolve>                (resid $resst4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst4 and (name CA or name P)  and segid $chain4) 0 0 0 
 CNSsolve>         assign (resid $resst2 and (name CA or name P)  and segid $chain2) 
 CNSsolve>                (resid $resst5 and (name CA or name P)  and segid $chain5) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resst5 and (name CA or name P)  and segid $chain5) 0 0 0 
 CNSsolve>         assign (resid $resst3 and (name CA or name P)  and segid $chain3) 
 CNSsolve>                (resid $resst1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resst1 and (name CA or name P)  and segid $chain1) 0 0 0 
 CNSsolve>         assign (resid $resst4 and (name CA or name P)  and segid $chain4) 
 CNSsolve>                (resid $resst2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve> 
 CNSsolve>         assign (resid $resst5 and (name CA or name P)  and segid $chain5) 
 CNSsolve>                (resid $resst2 and (name CA or name P)  and segid $chain2) 0 0 0 
 CNSsolve>         assign (resid $resst5 and (name CA or name P)  and segid $chain5) 
 CNSsolve>                (resid $resst3 and (name CA or name P)  and segid $chain3) 0 0 0 
 CNSsolve> 
 CNSsolve>      end 
 CNSsolve> 
 CNSsolve>      evaluate ($icount = $icount + $istep) 
 CNSsolve>      evaluate ($i1start = $i1start + $istep) 
 CNSsolve>      evaluate ($i2start = $i2start + $istep) 
 CNSsolve>      evaluate ($i3start = $i3start + $istep) 
 CNSsolve>      evaluate ($i4start = $i4start + $istep) 
 CNSsolve>      evaluate ($i5start = $i5start + $istep) 
 CNSsolve> 
 CNSsolve>    end loop genc5sym 
 CNSsolve> 
 CNSsolve>  end loop c5symloop 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  noe 
 CNSsolve>    potential  symm symmetry 
 CNSsolve>    scale      symm $Data.ksym 
 CNSsolve>    sqconstant symm 1.0 
 CNSsolve>    sqexponent symm 2 
 CNSsolve>    soexponent symm 1 
 CNSsolve>    rswitch    symm 0.5 
 CNSsolve>    sqoffset   symm 0.0 
 CNSsolve>    asymptote  symm 1.0 
 CNSsolve>  end 
 CNSsolve> 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>    noe 
 CNSsolve>      scale symm $Data.ksym 
 CNSsolve>    end 
 CNSsolve>    energy end 
 CNSsolve>    evaluate ($esym = $noe) 
 CNSsolve>    if ($Data.noecv eq true) then 
 CNSsolve>      evaluate ($violations_test_noe=0) 
 CNSsolve>      evaluate ($rms_test_noe=0.0) 
 CNSsolve>      display Print out of cross-validated violations and rms not 
 CNSsolve>      display possible in combination with symmetry restraints 
 CNSsolve>      display CV values set therefore to 0 
 CNSsolve>    end if 
 CNSsolve>    noe reset end 
 CNSsolve>    set message=normal echo=on end 
 CNSsolve>    !read all the experimental Data: 
 CNSsolve>    @@RUN:protocols/read_noes.cns(Iteration=$Iteration; Data=$Data; count=$count) 
 CNSsolve>    if ( $log_level = verbose ) then 
 CNSsolve>      set message=normal echo=on end 
 CNSsolve>    else 
 CNSsolve>      set message=off echo=off end 
 CNSsolve>    end if 
 CNSsolve>  else 
 CNSsolve>    print threshold=0.3 noe 
 CNSsolve>    evaluate ($rms_noe=$result) 
 CNSsolve>    evaluate ($violations_noe=$violations) 
 CNSsolve>    if ($Data.noecv eq true) then 
 CNSsolve>      evaluate ($rms_test_noe=$test_rms) 
 CNSsolve>      evaluate ($violations_test_noe=$test_violations) 
 CNSsolve>    else 
 CNSsolve>      evaluate ($rms_test_noe=0.0) 
 CNSsolve>      evaluate ($violations_test_noe=0) 
 CNSsolve>    end if 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  if ($Data.dnarest eq true) then 
 CNSsolve>    @RUN:data/sequence/dna-rna_restraints.def 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  energy end 
 CNSsolve>  evaluate ($etot = $ener - $noe) 
 CNSsolve>  evaluate ($noe = $eair) 
 CNSsolve>  evaluate ($etot = $etot + $noe) 
 CNSsolve> 
 CNSsolve>  evaluate ($Data.flags.dihed = false) 
 CNSsolve>  if ($nlcount = 1) then 
 CNSsolve>    evaluate ($filename="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + ".pdb0") 
 CNSsolve>  else 
 CNSsolve>    evaluate ($num = $count + $iterations.structures) 
 CNSsolve>    evaluate ($filename="NEWIT:" + $Filenames.fileroot + "_" + encode($num) + ".pdb0") 
 CNSsolve>  end if 
 CNSsolve>   
 CNSsolve>! print_coorheader.cns 
 CNSsolve>!    Generate the coordinate header (REMARKS) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * Originally adapted from Aria 1.2 from Nilges and Linge, EMBL.       * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve> 
 CNSsolve>if ($Data.flags.dihed eq FALSE) then evaluate ($dihe = 0) end if 
 CNSsolve>if ($Data.flags.sani  eq FALSE) then evaluate ($sani = 0) end if 
 CNSsolve>if ($Data.flags.xrdc  eq FALSE) then evaluate ($xrdc = 0) end if 
 CNSsolve>if ($Data.flags.xpcs  eq FALSE) then evaluate ($xpcs = 0) end if 
 CNSsolve>if ($Data.flags.dani  eq FALSE) then evaluate ($dani = 0) end if 
 CNSsolve>if ($Data.flags.coup  eq FALSE) then evaluate ($coup = 0) end if 
 CNSsolve>if ($Data.flags.vean  eq FALSE) then evaluate ($vean = 0) end if 
 CNSsolve>if ($Data.flags.cdih  eq FALSE) then evaluate ($cdih = 0) end if 
 CNSsolve>if ($Data.flags.noe   eq FALSE) then evaluate ($noe  = 0) end if 
 CNSsolve>if ($Data.flags.rg    eq FALSE) then evaluate ($coll = 0) end if 
 CNSsolve> 
 CNSsolve>evaluate($enerall=$etot) 
 CNSsolve>evaluate($bondall=$bond) 
 CNSsolve>evaluate($anglall=$angl) 
 CNSsolve>evaluate($imprall=$impr) 
 CNSsolve>evaluate($diheall=$dihe) 
 CNSsolve>evaluate($vdwall=$vdw) 
 CNSsolve>evaluate($elecall=$elec) 
 CNSsolve>evaluate($noeall=$noe) 
 CNSsolve>evaluate($rgall=$coll) 
 CNSsolve>evaluate($cdihall=$cdih) 
 CNSsolve>evaluate($coupall=$coup) 
 CNSsolve>evaluate($saniall=$sani+$xrdc) 
 CNSsolve>evaluate($veanall=$vean) 
 CNSsolve>evaluate($xpcsall=$xpcs) 
 CNSsolve>evaluate($daniall=$dani) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym eq true) then 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  print threshold=0.3 noe 
 CNSsolve>  evaluate ($rms_noe=$result) 
 CNSsolve>  evaluate ($violations_noe=$violations) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.noecv eq false) then 
 CNSsolve>  evaluate ($violations_test_noe= 0) 
 CNSsolve>  evaluate ($rms_test_noe = 0) 
 CNSsolve>  evaluate ($npart = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>print threshold=5. cdih 
 CNSsolve>evaluate ($rms_cdih=$result) 
 CNSsolve>evaluate ($violations_cdih=$violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>print thres=0.05 bonds 
 CNSsolve>evaluate ($rms_bonds=$result) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>print thres=5. angles 
 CNSsolve>evaluate ($rms_angles=$result) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>print thres=5. impropers 
 CNSsolve>evaluate ($rms_impropers=$result) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>print thres=30. dihedrals 
 CNSsolve>evaluate ($rms_dihedrals=$result) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>coupl print thres=1.0 class * end 
 CNSsolve>evaluate ($rms_coup = $result) 
 CNSsolve>evaluate ($violations_coup = $violations) 
 CNSsolve> 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc1 end 
 CNSsolve>evaluate( $rms_sani = $result) 
 CNSsolve>evaluate( $violations_sani = $violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc2 end 
 CNSsolve>if ($result > 0) then 
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc3 end 
 CNSsolve>if ($result > 0) then 
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc4 end 
 CNSsolve>if ($result > 0) then 
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 CNSsolve>evaluate ($result=0) 
 CNSsolve>evaluate ($violations=0) 
 CNSsolve>sani print threshold = 0.20 class rdc5 end 
 CNSsolve>if ($result > 0) then 
 CNSsolve>  evaluate( $rms_sani = (0.5 * $rms_sani) + (0.5 * $result)) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations) 
 CNSsolve> 
 CNSsolve>if ($Data.flags.xrdc  eq TRUE) then 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  xrdc print threshold = 0.2 class xrd1 end 
 CNSsolve>  evaluate( $rms_xrdc = $result) 
 CNSsolve>  evaluate( $violations_xrdc = $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  xrdc print threshold = 0.2 class xrd2 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xrdc = (0.5 * $rms_xrdc) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xrdc = $violations_xrdc + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  xrdc print threshold = 0.2 class xrd3 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xrdc = (0.5 * $rms_xrdc) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xrdc = $violations_xrdc + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  xrdc print threshold = 0.2 class xrd4 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xrdc = (0.5 * $rms_xrdc) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xrdc = $violations_xrdc + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  xrdc print threshold = 0.2 class xrd5 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xrdc = (0.5 * $rms_xrdc) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xrdc = $violations_xrdc + $violations) 
 CNSsolve>else 
 CNSsolve>  evaluate( $rms_xrdc = 0) 
 CNSsolve>  evaluate( $violations_xrdc = 0) 
 CNSsolve>end if 
 CNSsolve>evaluate( $violations_sani = $violations_sani + $violations_xrdc) 
 CNSsolve>evaluate( $rms_sani = $rms_sani + $rms_xrdc) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($Data.flags.xpcs  eq TRUE) then 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs1 end 
 CNSsolve>  evaluate( $rms_xpcs = $result) 
 CNSsolve>  evaluate( $violations_xpcs = $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs2 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs3 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs4 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs5 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs6 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs7 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs8 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcs9 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve> 
 CNSsolve>  xpcs print threshold = 0.2 class pcsA end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_xpcs = (0.5 * $rms_xpcs) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_xpcs = $violations_xpcs + $violations) 
 CNSsolve>else 
 CNSsolve>  evaluate( $rms_xpcs = 0) 
 CNSsolve>  evaluate( $violations_xpcs = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.vean  eq TRUE) then 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea1 end 
 CNSsolve>  evaluate( $rms_vean = $result) 
 CNSsolve>  evaluate( $violations_vean = $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea2 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea3 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea4 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  vean print threshold = 5.00 class vea5 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_vean = (0.5 * $rms_vean) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_vean = $violations_vean + $violations) 
 CNSsolve>else 
 CNSsolve>  evaluate( $rms_vean = 0) 
 CNSsolve>  evaluate( $violations_vean = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>if ($Data.flags.dani  eq TRUE) then 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan1 end 
 CNSsolve>  evaluate( $rms_dani = $result) 
 CNSsolve>  evaluate( $violations_dani = $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan2 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan3 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan4 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>  evaluate ($result=0) 
 CNSsolve>  evaluate ($violations=0) 
 CNSsolve>  dani print threshold = 0.20 class dan5 end 
 CNSsolve>  if ($result > 0) then 
 CNSsolve>    evaluate( $rms_dani = (0.5 * $rms_dani) + (0.5 * $result)) 
 CNSsolve>  end if 
 CNSsolve>  evaluate( $violations_dani = $violations_dani + $violations) 
 CNSsolve>else 
 CNSsolve>  evaluate( $rms_dani = 0) 
 CNSsolve>  evaluate( $violations_dani = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>{====>} {* define ASA-based solvation parameters *} 
 CNSsolve>inline  
 CNSsolve>! def_solv_param.cns 
 CNSsolve>!    Define atomic solvation parameters taken from Fernandez-Recio et al. JMB 335:843 (2004) 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($arofac = 6.26) 
 CNSsolve>evaluate ($alifac = 1.27) 
 CNSsolve>evaluate ($polfac = 2.30) 
 CNSsolve>do (store1 =  0.0000) (all) 
 CNSsolve>do (store1 =  0.0151 * $alifac) (name C*) 
 CNSsolve>do (store1 =  0.0176 * $arofac) ((name CG* or name CD* or name CE* or name CH* or name CZ*) and (resn PHE or resn TYR or resn HIS or resn TRP)) 
 CNSsolve>do (store1 = -0.0170 * $polfac) (name N*) 
 CNSsolve>do (store1 = -0.0548 * $polfac) (name NT* or (name NZ* and resn LYS)) 
 CNSsolve>do (store1 = -0.0273 * $polfac) (name NH* and resn ARG) 
 CNSsolve>do (store1 = -0.0136 * $polfac) (name O*) 
 CNSsolve>do (store1 = -0.0185 * $polfac) (name OG* or name OH) 
 CNSsolve>do (store1 = -0.0299 * $polfac) ((name OD* and resn ASP) or (name OE* and resn GLU)) 
 CNSsolve>do (store1 =  0.0112 * $polfac) (name S*) 
 CNSsolve>do (store1 =  0.0022 * $polfac) ((name S* and attr charge = -0.3) or (name SD and resn MET)) 
 CNSsolve> 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>{====>} {* buried surface area *} 
 CNSsolve>evaluate ($nchain1 = 0) 
 CNSsolve>evaluate ($saafree = 0) 
 CNSsolve>while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>  evaluate ($nchain1 = $nchain1 + 1) 
 CNSsolve>  {====>} {* buried surface area *} 
 CNSsolve>  do (rmsd = 0) (all) 
 CNSsolve>  surface mode=access accu=0.075 rh2o=1.4 sele=(segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) end 
 CNSsolve>  show sum (rmsd) (segid $Toppar.prot_segid_$nchain1 and not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 CNSsolve>  evaluate ($saafree = $saafree + $result) 
 CNSsolve>end loop nloop1 
 CNSsolve> 
 CNSsolve>do (rmsd = 0) (all) 
 CNSsolve>do (store2 = 0) (all) 
 CNSsolve>surface mode=access accu=0.075 rh2o=1.4 sele=(not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) end 
 CNSsolve>show sum (rmsd) (not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 CNSsolve>evaluate ($satot = $result) 
 CNSsolve>do (store2 = rmsd * store1) (not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 CNSsolve>show sum (store2) (not ((resn WAT or resn HOH or resn TIP*) or resn DMS)) 
 CNSsolve>evaluate ($esolcplx = $result) 
 CNSsolve>evaluate ($saburied = $saafree - $satot) 
 CNSsolve>if ($saburied < 0) then 
 CNSsolve>  evaluate ($saburied = -999999) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($refine.calcdesolv eq false) then 
 CNSsolve>  evaluate ($edesolv = $esolcplx - $esolfree) 
 CNSsolve>elseif ($iteration < 2) then 
 CNSsolve>  evaluate ($edesolv = $esolcplx - $esolfree) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($dhbinding = $edesolv + $eintcplx - $eintfree + $elec + $vdw) 
 CNSsolve> 
 CNSsolve>if ($data.ncomponents = 1) then 
 CNSsolve>  evaluate ($saburied = 0) 
 CNSsolve>  evaluate ($edesolv = 0) 
 CNSsolve>  evaluate ($dhbinding = 0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($Data.flags.sym eq true) then 
 CNSsolve>  evaluate ($enerall = $enerall + $esym) 
 CNSsolve>end if 
 CNSsolve>if ($Data.flags.ncs eq true) then 
 CNSsolve>  evaluate ($enerall = $enerall + $ncs) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>evaluate ($procwat = false) 
 CNSsolve>if ($refine.keepwater eq true) then 
 CNSsolve>  evaluate ($procwat = true) 
 CNSsolve>end if 
 CNSsolve>if ($data.waterdock eq true) then 
 CNSsolve>  evaluate ($procwat = true) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>if ($procwat eq true) then 
 CNSsolve>  if ($iteration eq 2) then 
 CNSsolve>    do (store3 = 0) (all) 
 CNSsolve>    eval($nchain1 = 0) 
 CNSsolve>    while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>      eval($nchain2 = $nchain1) 
 CNSsolve>      while ($nchain2 < $data.ncomponents) loop nloop2 
 CNSsolve>        eval($nchain2 = $nchain2 + 1) 
 CNSsolve>        do (store3 = 1) (byres ((resn WAT or resn HOH or resn TIP* or resn DMS) and (segid $Toppar.prot_segid_$nchain1) around 3.5 
 CNSsolve>                                          and (segid $Toppar.prot_segid_$nchain2) around 3.5)) 
 CNSsolve>      end loop nloop2 
 CNSsolve>    end loop nloop1 
 CNSsolve>    dele sele=(attr store3=0 and (resn DMS or (resn WAT or resn HOH or resn TIP*))) end 
 CNSsolve>  end if 
 CNSsolve>  if ($iteration ne 0) then 
 CNSsolve>    ident (store3) (not all) 
 CNSsolve>  end if 
 CNSsolve>  flag exclude * include vdw elec  end 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < $data.ncomponents) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve> 
 CNSsolve>    igroup 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) (((resn WAT or resn HOH or resn TIP*) or resn DMS) and not store3) weight * 1.0 end 
 CNSsolve>      interaction (not segid $Toppar.prot_segid_$nchain1) ((resn WAT or resn HOH or resn TIP*) or resn DMS) weight * 0.0 end 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) (not (((resn WAT or resn HOH or resn TIP*) or resn DMS) and store3)) weight * 0.0 end 
 CNSsolve>    end 
 CNSsolve>    energy end 
 CNSsolve>    evaluate ($ener_water_$nchain1 = $ener) 
 CNSsolve>    evaluate ($enerall = $enerall + $ener) 
 CNSsolve>    evaluate ($vdw_water_$nchain1 = $vdw) 
 CNSsolve>    evaluate ($elec_water_$nchain1 = $elec) 
 CNSsolve> 
 CNSsolve>  end loop nloop1 
 CNSsolve>  if ($data.ncomponents < 6) then 
 CNSsolve>    eval($nchain1 = $data.ncomponents) 
 CNSsolve>    while ($nchain1 < 6) loop nloop1 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>      evaluate ($ener_water_$nchain1 = 0.0) 
 CNSsolve>      evaluate ($vdw_water_$nchain1 = 0.0) 
 CNSsolve>      evaluate ($elec_water_$nchain1 = 0.0) 
 CNSsolve>    end loop nloop1 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  igroup 
 CNSsolve>    while ($nchain1 < $data.ncomponents) loop nloop2 
 CNSsolve>      eval($nchain1 = $nchain1 + 1) 
 CNSsolve>      interaction (segid $Toppar.prot_segid_$nchain1) (all) weight * 0.0 end 
 CNSsolve>    end loop nloop2 
 CNSsolve>    interaction (((resn WAT or resn HOH or resn TIP*) or resn DMS) and not store3) 
 CNSsolve>                (((resn WAT or resn HOH or resn TIP*) or resn DMS) and not store3)  weight * 1.0 end 
 CNSsolve>    interaction (store3) (store3)  weight * 0.0 end 
 CNSsolve>  end 
 CNSsolve>  energy end 
 CNSsolve>  evaluate ($ener_water_water = $ener) 
 CNSsolve>  evaluate ($enerall = $enerall + $ener) 
 CNSsolve>  evaluate ($vdw_water_water = $vdw) 
 CNSsolve>  evaluate ($elec_water_water = $elec) 
 CNSsolve>else 
 CNSsolve>  eval($nchain1 = 0) 
 CNSsolve> 
 CNSsolve>  while ($nchain1 < 6) loop nloop1 
 CNSsolve>    eval($nchain1 = $nchain1 + 1) 
 CNSsolve>    evaluate ($ener_water_$nchain1 = 0.0) 
 CNSsolve>    evaluate ($vdw_water_$nchain1 = 0.0) 
 CNSsolve>    evaluate ($elec_water_$nchain1 = 0.0) 
 CNSsolve>  end loop nloop1 
 CNSsolve>  evaluate ($ener_water_water = 0.0) 
 CNSsolve>  evaluate ($vdw_water_water = 0.0) 
 CNSsolve>  evaluate ($elec_water_water = 0.0) 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve>! File name 
 CNSsolve>evaluate ($initialstruct = $file - "PREVIT:") 
 CNSsolve> 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks HADDOCK run for $Filenames.fileroot 
 CNSsolve>remarks initial structure: $initialstruct 
 CNSsolve>remarks final NOE weights: unambig $Data.unamb_cool3 amb: $Data.amb_cool3 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks            total,bonds,angles,improper,dihe,vdw,elec,air,cdih,coup,rdcs,vean,dani,xpcs,rg 
 CNSsolve>remarks energies: $enerall, $bondall, $anglall, $imprall, $diheall, $vdwall, $elecall, $noeall, $cdihall, $coupall, $saniall, $veanall, $daniall, $xpcsall, $rgall 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks            bonds,angles,impropers,dihe,air,cdih,coup,rdcs,vean,dani,xpcs 
 CNSsolve>remarks rms-dev.: $rms_bonds,$rms_angles,$rms_impropers,$rms_dihedrals,$rms_noe,$rms_cdih,$rms_coup, $rms_sani, $rms_vean, $rms_dani, $rms_xpcs 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks               air,cdih,coup,rdcs,vean,dani,xpcs 
 CNSsolve>remarks               >0.3,>5,>1,>0,>5,>0.2,>0.2 
 CNSsolve>remarks violations.: $violations_noe, $violations_cdih, $violations_coup, $violations_sani, $violations_vean, $violations_dani, $violations_xpcs 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks                        CVpartition#,violations,rms 
 CNSsolve>remarks AIRs cross-validation: $npart, $violations_test_noe, $rms_test_noe 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks NCS energy: $ncs 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks Symmetry energy: $esym 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks Desolvation energy: $edesolv 
 CNSsolve>remarks Internal energy free molecules: $eintfree 
 CNSsolve>remarks Internal energy complex: $eintcplx 
 CNSsolve>remarks Binding energy: $dhbinding 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks buried surface area: $saburied 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks water - chain1: $ener_water_1 $vdw_water_1 $elec_water_1 
 CNSsolve>remarks water - chain2: $ener_water_2 $vdw_water_2 $elec_water_2 
 CNSsolve>remarks water - chain3: $ener_water_3 $vdw_water_3 $elec_water_3 
 CNSsolve>remarks water - chain4: $ener_water_4 $vdw_water_4 $elec_water_4 
 CNSsolve>remarks water - chain5: $ener_water_5 $vdw_water_5 $elec_water_5 
 CNSsolve>remarks water - chain6: $ener_water_6 $vdw_water_6 $elec_water_6 
 CNSsolve>remarks =============================================================== 
 CNSsolve>remarks water - water: $ener_water_water $vdw_water_water $elec_water_water 
 CNSsolve>remarks =============================================================== 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  coor sele= (not name h* and not resn ani and not resn xan and not resn dan) orient end 
 CNSsolve>  if ($data.waterdock eq true) then 
 CNSsolve>    write coordinates sele=(not (resn WAT or resn HOH)) output=$filename end 
 CNSsolve>    inline  
 CNSsolve>! waterdock_out1.cns 
 CNSsolve>!    Output information about waters in solvated docking 
 CNSsolve>! 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! * Copyright 2003-2015 Alexandre Bonvin, Utrecht University.           * 
 CNSsolve>! * All rights reserved.                                                * 
 CNSsolve>! * This code is part of the HADDOCK software and governed by its       * 
 CNSsolve>! * license. Please see the LICENSE file that should have been included * 
 CNSsolve>! * as part of this package.                                            * 
 CNSsolve>! *********************************************************************** 
 CNSsolve>! 
 CNSsolve>evaluate ($filename="NEWIT:" + $Filenames.fileroot + "_" + encode($count) + "_water.pdbw") 
 CNSsolve>do (store1 = 0) (all) 
 CNSsolve>do (store1 = 1) ((resn WAT or resn HOH) and not store3) 
 CNSsolve>show sum (store1) (all) 
 CNSsolve>if ($result > 0) then 
 CNSsolve>  write coordinates sele= ((resn WAT or resn HOH) and not store3) output =$filename end 
 CNSsolve>else 
 CNSsolve>  set display=$filename end 
 CNSsolve>  display REMARK no water kept 
 CNSsolve>  display END 
 CNSsolve>  close $filename end 
 CNSsolve>end if 
 CNSsolve>if ($data.water_analysis eq true) then 
 CNSsolve>  coor sele=((resn WAT or resn HOH)) orient end 
 CNSsolve>  show aver (x*x) ((resn WAT or resn HOH)) 
 CNSsolve>  evaluate ($rx = $result) 
 CNSsolve>  show aver (y*y) ((resn WAT or resn HOH)) 
 CNSsolve>  evaluate ($ry = $result) 
 CNSsolve>  show aver (z*z) ((resn WAT or resn HOH)) 
 CNSsolve>  evaluate ($rz = $result) 
 CNSsolve>  evaluate ($filename = "NEWIT:"+"rxyz_"+encode($count)+".disp") 
 CNSsolve>  set display=$filename end 
 CNSsolve>  display $rx $ry $rz 
 CNSsolve>  close $filename end 
 CNSsolve>  show sum(1) ((resn WAT or resn HOH) and name OH2) 
 CNSsolve>  eval ($nrwater=$result) 
 CNSsolve>  evaluate ($filename = "NEWIT:"+"nwater_"+encode($count)+".disp") 
 CNSsolve>  set display=$filename end 
 CNSsolve>  display $nrwater 
 CNSsolve>  close $filename end 
 CNSsolve>end if 
 CNSsolve> 
 CNSsolve> 
 CNSsolve>  else 
 CNSsolve>    write coordinates output=$filename end 
 CNSsolve>  end if 
 CNSsolve> 
 CNSsolve>  coor swap end 
 CNSsolve> 
 CNSsolve>end loop rotloop2 
 CNSsolve>stop 
 HEAP: maximum use      =   991076856 current use      =       96000 bytes
 HEAP: maximum overhead =        3504 current overhead =         752 bytes
          ============================================================
           Maximum dynamic memory allocation:   991076856 bytes
           Maximum dynamic memory overhead:          3504 bytes
           Program started at: 21:29:50 on 28-Dec-2019
           Program stopped at: 21:29:53 on 28-Dec-2019
           CPU time used:       3.0456 seconds
          ============================================================
